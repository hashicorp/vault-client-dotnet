/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsRolesName(string name, string mountPath = default(string));
        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCubbyholePath(string path, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGcpRolesetName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGcpStaticAccountName(string name, string mountPath = default(string));
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string mountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGcpkmsKeysKey(string key, string mountPath = default(string));
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string mountPath = default(string));
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLdapLibraryName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLdapRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLdapStaticRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteNomadConfigAccess(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePkiJson(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePkiKeyKeyRef(string keyRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePkiRoot(string mountPath = default(string));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSecretDataPath(string path, string mountPath = default(string));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSecretMetadataPath(string path, string mountPath = default(string));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSshConfigZeroaddress(string mountPath = default(string));
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSshKeysKeyName(string keyName, string mountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSshRolesRole(string role, string mountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteTotpKeysName(string name, string mountPath = default(string));
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsRoles(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListGcpRolesets(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListGcpStaticAccounts(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListLdapLibrary(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListLdapRole(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListLdapStaticRole(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListPkiCerts(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListPkiIssuers(string list, string mountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListTotpKeys(string list, string mountPath = default(string));
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigLease(string mountPath = default(string));
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigRoot(string mountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsCreds(string mountPath = default(string));
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsRolesName(string name, string mountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsStsName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAzureCredsRole(string role, string mountPath = default(string));
        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadCubbyholePath(string path, string mountPath = default(string), string list = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpConfig(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpKeyRoleset(string roleset, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpRolesetName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpRolesetRolesetKey(string roleset, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpRolesetRolesetToken(string roleset, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpStaticAccountName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpStaticAccountNameKey(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpStaticAccountNameToken(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpTokenRoleset(string roleset, string mountPath = default(string));
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpkmsKeysConfigKey(string key, string mountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpkmsKeysKey(string key, string mountPath = default(string));
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGcpkmsPubkeyKey(string key, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapCredsName(string name, string mountPath = default(string));
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapLibraryName(string name, string mountPath = default(string));
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapLibraryNameStatus(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapStaticCredName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadLdapStaticRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadNomadConfigAccess(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCa(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCaChain(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCaPem(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCertCaChain(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCertSerial(string serial, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCertSerialRaw(string serial, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCertSerialRawPem(string serial, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiConfigAutoTidy(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiConfigCrl(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiConfigIssuers(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiConfigKeys(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiConfigUrls(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCrl(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCrlRotate(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiCrlRotateDelta(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiDelta(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiDeltaCrl(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiDeltaPem(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiDer(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiIssuerRefDerPem(string issuerRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiJson(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiKeyKeyRef(string keyRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiOcspReq(string req, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiPem(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadPkiTidyStatus(string mountPath = default(string));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSecretDataPath(string path, string mountPath = default(string));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSecretMetadataPath(string path, string mountPath = default(string), string list = default(string));
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSecretSubkeysPath(string path, string mountPath = default(string));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSshConfigZeroaddress(string mountPath = default(string));
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSshPublicKey(string mountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadSshRolesRole(string role, string mountPath = default(string));
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTotpCodeName(string name, string mountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTotpKeysName(string name, string mountPath = default(string));
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTransitBackupName(string name, string mountPath = default(string));
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTransitCacheConfig(string mountPath = default(string));
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTransitExportTypeName(string name, string type, string mountPath = default(string));
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTransitExportTypeNameVersion(string name, string type, string version, string mountPath = default(string));
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTransitWrappingKey(string mountPath = default(string));
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigLeaseRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigLease(string mountPath = default(string), AwsConfigLeaseRequest awsConfigLeaseRequest = default(AwsConfigLeaseRequest));
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigRootRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigRoot(string mountPath = default(string), AwsConfigRootRequest awsConfigRootRequest = default(AwsConfigRootRequest));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsCredsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsCreds(string mountPath = default(string), AwsCredsRequest awsCredsRequest = default(AwsCredsRequest));
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsRolesName(string name, string mountPath = default(string), AwsRolesRequest awsRolesRequest = default(AwsRolesRequest));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsStsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsStsName(string name, string mountPath = default(string), AwsStsRequest awsStsRequest = default(AwsStsRequest));
        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateCubbyholePath(string path, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpConfig(string mountPath = default(string), GcpConfigRequest gcpConfigRequest = default(GcpConfigRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpConfigRotateRoot(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpKeyRoleset(string roleset, string mountPath = default(string), GcpKeyRequest gcpKeyRequest = default(GcpKeyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRolesetName(string name, string mountPath = default(string), GcpRolesetRequest gcpRolesetRequest = default(GcpRolesetRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRolesetNameRotate(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRolesetNameRotateKey(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRolesetRolesetKey(string roleset, string mountPath = default(string), GcpRolesetKeyRequest gcpRolesetKeyRequest = default(GcpRolesetKeyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRolesetRolesetToken(string roleset, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpStaticAccountName(string name, string mountPath = default(string), GcpStaticAccountRequest gcpStaticAccountRequest = default(GcpStaticAccountRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpStaticAccountNameKey(string name, string mountPath = default(string), GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest = default(GcpStaticAccountKeyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpStaticAccountNameRotateKey(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpStaticAccountNameToken(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpTokenRoleset(string roleset, string mountPath = default(string));
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsDecryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsDecryptKey(string key, string mountPath = default(string), GcpkmsDecryptRequest gcpkmsDecryptRequest = default(GcpkmsDecryptRequest));
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsEncryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsEncryptKey(string key, string mountPath = default(string), GcpkmsEncryptRequest gcpkmsEncryptRequest = default(GcpkmsEncryptRequest));
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysConfigKey(string key, string mountPath = default(string), GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest = default(GcpkmsKeysConfigRequest));
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysDeregisterKey(string key, string mountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysKey(string key, string mountPath = default(string), GcpkmsKeysRequest gcpkmsKeysRequest = default(GcpkmsKeysRequest));
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRegisterRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysRegisterKey(string key, string mountPath = default(string), GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest = default(GcpkmsKeysRegisterRequest));
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysRotateKey(string key, string mountPath = default(string));
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsKeysTrimKey(string key, string mountPath = default(string));
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsReencryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsReencryptKey(string key, string mountPath = default(string), GcpkmsReencryptRequest gcpkmsReencryptRequest = default(GcpkmsReencryptRequest));
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsSignKey(string key, string mountPath = default(string), GcpkmsSignRequest gcpkmsSignRequest = default(GcpkmsSignRequest));
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpkmsVerifyKey(string key, string mountPath = default(string), GcpkmsVerifyRequest gcpkmsVerifyRequest = default(GcpkmsVerifyRequest));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryManageCheckInRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapLibraryManageNameCheckIn(string name, string mountPath = default(string), LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest = default(LdapLibraryManageCheckInRequest));
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapLibraryName(string name, string mountPath = default(string), LdapLibraryRequest ldapLibraryRequest = default(LdapLibraryRequest));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckInRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapLibraryNameCheckIn(string name, string mountPath = default(string), LdapLibraryCheckInRequest ldapLibraryCheckInRequest = default(LdapLibraryCheckInRequest));
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckOutRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapLibraryNameCheckOut(string name, string mountPath = default(string), LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest = default(LdapLibraryCheckOutRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapRoleName(string name, string mountPath = default(string), LdapRoleRequest ldapRoleRequest = default(LdapRoleRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapRotateRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapRotateRoot(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapStaticRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateLdapStaticRoleName(string name, string mountPath = default(string), LdapStaticRoleRequest ldapStaticRoleRequest = default(LdapStaticRoleRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="nomadConfigAccessRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateNomadConfigAccess(string mountPath = default(string), NomadConfigAccessRequest nomadConfigAccessRequest = default(NomadConfigAccessRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiBundleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiBundle(string mountPath = default(string), PkiBundleRequest pkiBundleRequest = default(PkiBundleRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiCertRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiCert(string mountPath = default(string), PkiCertRequest pkiCertRequest = default(PkiCertRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigAutoTidyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigAutoTidy(string mountPath = default(string), PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest = default(PkiConfigAutoTidyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCaRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigCa(string mountPath = default(string), PkiConfigCaRequest pkiConfigCaRequest = default(PkiConfigCaRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCrlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigCrl(string mountPath = default(string), PkiConfigCrlRequest pkiConfigCrlRequest = default(PkiConfigCrlRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigIssuersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigIssuers(string mountPath = default(string), PkiConfigIssuersRequest pkiConfigIssuersRequest = default(PkiConfigIssuersRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigKeys(string mountPath = default(string), PkiConfigKeysRequest pkiConfigKeysRequest = default(PkiConfigKeysRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigUrlsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiConfigUrls(string mountPath = default(string), PkiConfigUrlsRequest pkiConfigUrlsRequest = default(PkiConfigUrlsRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateCrossSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIntermediateCrossSign(string mountPath = default(string), PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest = default(PkiIntermediateCrossSignRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateGenerateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIntermediateGenerateExported(string exported, string mountPath = default(string), PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest = default(PkiIntermediateGenerateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateSetSignedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIntermediateSetSigned(string mountPath = default(string), PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest = default(PkiIntermediateSetSignedRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssueRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssueRole(string role, string mountPath = default(string), PkiIssueRequest pkiIssueRequest = default(PkiIssueRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerIssueRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefIssueRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerIssueRequest pkiIssuerIssueRequest = default(PkiIssuerIssueRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefRevoke(string issuerRef, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefSignIntermediate(string issuerRef, string mountPath = default(string), PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest = default(PkiIssuerSignIntermediateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefSignRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignRequest pkiIssuerSignRequest = default(PkiIssuerSignRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefSignSelfIssued(string issuerRef, string mountPath = default(string), PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest = default(PkiIssuerSignSelfIssuedRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatim(string issuerRef, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuersGenerateIntermediateExported(string exported, string mountPath = default(string), PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest = default(PkiIssuersGenerateIntermediateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateRootRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiIssuersGenerateRootExported(string exported, string mountPath = default(string), PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest = default(PkiIssuersGenerateRootRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiJsonRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiJson(string mountPath = default(string), PkiJsonRequest pkiJsonRequest = default(PkiJsonRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiKeyKeyRef(string keyRef, string mountPath = default(string), PkiKeyRequest pkiKeyRequest = default(PkiKeyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeysImportRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiKeysImport(string mountPath = default(string), PkiKeysImportRequest pkiKeysImportRequest = default(PkiKeysImportRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKmsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiKms(string mountPath = default(string), PkiKmsRequest pkiKmsRequest = default(PkiKmsRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiOcsp(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRevoke(string mountPath = default(string), PkiRevokeRequest pkiRevokeRequest = default(PkiRevokeRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeWithKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRevokeWithKey(string mountPath = default(string), PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest = default(PkiRevokeWithKeyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootGenerateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRootGenerateExported(string exported, string mountPath = default(string), PkiRootGenerateRequest pkiRootGenerateRequest = default(PkiRootGenerateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootReplaceRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRootReplace(string mountPath = default(string), PkiRootReplaceRequest pkiRootReplaceRequest = default(PkiRootReplaceRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootRotateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRootRotateExported(string exported, string mountPath = default(string), PkiRootRotateRequest pkiRootRotateRequest = default(PkiRootRotateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRootSignIntermediate(string mountPath = default(string), PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest = default(PkiRootSignIntermediateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignSelfIssuedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiRootSignSelfIssued(string mountPath = default(string), PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest = default(PkiRootSignSelfIssuedRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiSignRole(string role, string mountPath = default(string), PkiSignRequest pkiSignRequest = default(PkiSignRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiSignVerbatim(string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiSignVerbatimRole(string role, string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiTidyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiTidy(string mountPath = default(string), PkiTidyRequest pkiTidyRequest = default(PkiTidyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdatePkiTidyCancel(string mountPath = default(string));
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="rabbitmqConfigConnectionRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateRabbitmqConfigConnection(string mountPath = default(string), RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest = default(RabbitmqConfigConnectionRequest));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDataRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSecretDataPath(string path, string mountPath = default(string), KvDataRequest kvDataRequest = default(KvDataRequest));
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDeleteRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSecretDeletePath(string path, string mountPath = default(string), KvDeleteRequest kvDeleteRequest = default(KvDeleteRequest));
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSecretDestroyPath(string path, string mountPath = default(string), KvDestroyRequest kvDestroyRequest = default(KvDestroyRequest));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSecretMetadataPath(string path, string mountPath = default(string), KvMetadataRequest kvMetadataRequest = default(KvMetadataRequest));
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvUndeleteRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSecretUndeletePath(string path, string mountPath = default(string), KvUndeleteRequest kvUndeleteRequest = default(KvUndeleteRequest));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshConfigZeroaddressRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSshConfigZeroaddress(string mountPath = default(string), SshConfigZeroaddressRequest sshConfigZeroaddressRequest = default(SshConfigZeroaddressRequest));
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSshKeysKeyName(string keyName, string mountPath = default(string), SshKeysRequest sshKeysRequest = default(SshKeysRequest));
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSshLookup(string mountPath = default(string), SshLookupRequest sshLookupRequest = default(SshLookupRequest));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSshRolesRole(string role, string mountPath = default(string), SshRolesRequest sshRolesRequest = default(SshRolesRequest));
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSshVerify(string mountPath = default(string), SshVerifyRequest sshVerifyRequest = default(SshVerifyRequest));
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpCodeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTotpCodeName(string name, string mountPath = default(string), TotpCodeRequest totpCodeRequest = default(TotpCodeRequest));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTotpKeysName(string name, string mountPath = default(string), TotpKeysRequest totpKeysRequest = default(TotpKeysRequest));
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitCacheConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitCacheConfig(string mountPath = default(string), TransitCacheConfigRequest transitCacheConfigRequest = default(TransitCacheConfigRequest));
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDatakeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitDatakeyPlaintextName(string name, string plaintext, string mountPath = default(string), TransitDatakeyRequest transitDatakeyRequest = default(TransitDatakeyRequest));
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDecryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitDecryptName(string name, string mountPath = default(string), TransitDecryptRequest transitDecryptRequest = default(TransitDecryptRequest));
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitEncryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitEncryptName(string name, string mountPath = default(string), TransitEncryptRequest transitEncryptRequest = default(TransitEncryptRequest));
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitHash(string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest));
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitHashUrlalgorithm(string urlalgorithm, string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest));
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitHmacName(string name, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest));
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitHmacNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest));
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitKeysNameConfig(string name, string mountPath = default(string), TransitKeysConfigRequest transitKeysConfigRequest = default(TransitKeysConfigRequest));
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitKeysNameImport(string name, string mountPath = default(string), TransitKeysImportRequest transitKeysImportRequest = default(TransitKeysImportRequest));
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportVersionRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitKeysNameImportVersion(string name, string mountPath = default(string), TransitKeysImportVersionRequest transitKeysImportVersionRequest = default(TransitKeysImportVersionRequest));
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitKeysNameRotate(string name, string mountPath = default(string));
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysTrimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitKeysNameTrim(string name, string mountPath = default(string), TransitKeysTrimRequest transitKeysTrimRequest = default(TransitKeysTrimRequest));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRandom(string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRandomSource(string source, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRandomSourceUrlbytes(string source, string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRandomUrlbytes(string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest));
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRestore(string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest));
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRestoreName(string name, string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest));
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRewrapRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitRewrapName(string name, string mountPath = default(string), TransitRewrapRequest transitRewrapRequest = default(TransitRewrapRequest));
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitSignName(string name, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest));
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitSignNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest));
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitVerifyName(string name, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest));
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsRolesNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteCubbyholePathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGcpRolesetNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteLdapLibraryNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteLdapRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteNomadConfigAccessAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeletePkiJsonAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeletePkiRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteSecretDataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteSecretMetadataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteSshConfigZeroaddressAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteSshRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteTotpKeysNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsRolesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListGcpRolesetsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListGcpStaticAccountsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListLdapLibraryAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListLdapRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListLdapStaticRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListPkiCertsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListPkiIssuersAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListTotpKeysAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigLeaseAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsCredsAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsRolesNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsStsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAzureCredsRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadCubbyholePathAsync(string path, string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpKeyRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpRolesetNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpRolesetRolesetKeyAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpRolesetRolesetTokenAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpStaticAccountNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpStaticAccountNameKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpStaticAccountNameTokenAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpTokenRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpkmsKeysConfigKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpkmsKeysKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGcpkmsPubkeyKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapCredsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapLibraryNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapLibraryNameStatusAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapStaticCredNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadLdapStaticRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadNomadConfigAccessAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCaChainAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCaPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCertCaChainAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCertSerialAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCertSerialRawAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCertSerialRawPemAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiConfigAutoTidyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiConfigCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiConfigIssuersAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiConfigKeysAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiConfigUrlsAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCrlRotateAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiCrlRotateDeltaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiDeltaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiDeltaCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiDeltaPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiDerAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiIssuerRefDerPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiJsonAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiOcspReqAsync(string req, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadPkiTidyStatusAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSecretDataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSecretMetadataPathAsync(string path, string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSecretSubkeysPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSshConfigZeroaddressAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSshPublicKeyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadSshRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTotpCodeNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTotpKeysNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTransitBackupNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTransitCacheConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTransitExportTypeNameAsync(string name, string type, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTransitExportTypeNameVersionAsync(string name, string type, string version, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTransitWrappingKeyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigLeaseRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigLeaseAsync(string mountPath = default(string), AwsConfigLeaseRequest awsConfigLeaseRequest = default(AwsConfigLeaseRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigRootRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigRootAsync(string mountPath = default(string), AwsConfigRootRequest awsConfigRootRequest = default(AwsConfigRootRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsCredsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsCredsAsync(string mountPath = default(string), AwsCredsRequest awsCredsRequest = default(AwsCredsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsRolesNameAsync(string name, string mountPath = default(string), AwsRolesRequest awsRolesRequest = default(AwsRolesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsStsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsStsNameAsync(string name, string mountPath = default(string), AwsStsRequest awsStsRequest = default(AwsStsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateCubbyholePathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpConfigAsync(string mountPath = default(string), GcpConfigRequest gcpConfigRequest = default(GcpConfigRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpConfigRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpKeyRolesetAsync(string roleset, string mountPath = default(string), GcpKeyRequest gcpKeyRequest = default(GcpKeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRolesetNameAsync(string name, string mountPath = default(string), GcpRolesetRequest gcpRolesetRequest = default(GcpRolesetRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRolesetNameRotateAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRolesetNameRotateKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRolesetRolesetKeyAsync(string roleset, string mountPath = default(string), GcpRolesetKeyRequest gcpRolesetKeyRequest = default(GcpRolesetKeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRolesetRolesetTokenAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpStaticAccountNameAsync(string name, string mountPath = default(string), GcpStaticAccountRequest gcpStaticAccountRequest = default(GcpStaticAccountRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpStaticAccountNameKeyAsync(string name, string mountPath = default(string), GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest = default(GcpStaticAccountKeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpStaticAccountNameRotateKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpStaticAccountNameTokenAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpTokenRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsDecryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsDecryptKeyAsync(string key, string mountPath = default(string), GcpkmsDecryptRequest gcpkmsDecryptRequest = default(GcpkmsDecryptRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsEncryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsEncryptKeyAsync(string key, string mountPath = default(string), GcpkmsEncryptRequest gcpkmsEncryptRequest = default(GcpkmsEncryptRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysConfigKeyAsync(string key, string mountPath = default(string), GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest = default(GcpkmsKeysConfigRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysKeyAsync(string key, string mountPath = default(string), GcpkmsKeysRequest gcpkmsKeysRequest = default(GcpkmsKeysRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRegisterRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysRegisterKeyAsync(string key, string mountPath = default(string), GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest = default(GcpkmsKeysRegisterRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysRotateKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsKeysTrimKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsReencryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsReencryptKeyAsync(string key, string mountPath = default(string), GcpkmsReencryptRequest gcpkmsReencryptRequest = default(GcpkmsReencryptRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsSignKeyAsync(string key, string mountPath = default(string), GcpkmsSignRequest gcpkmsSignRequest = default(GcpkmsSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpkmsVerifyKeyAsync(string key, string mountPath = default(string), GcpkmsVerifyRequest gcpkmsVerifyRequest = default(GcpkmsVerifyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryManageCheckInRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapLibraryManageNameCheckInAsync(string name, string mountPath = default(string), LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest = default(LdapLibraryManageCheckInRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapLibraryNameAsync(string name, string mountPath = default(string), LdapLibraryRequest ldapLibraryRequest = default(LdapLibraryRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckInRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapLibraryNameCheckInAsync(string name, string mountPath = default(string), LdapLibraryCheckInRequest ldapLibraryCheckInRequest = default(LdapLibraryCheckInRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckOutRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapLibraryNameCheckOutAsync(string name, string mountPath = default(string), LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest = default(LdapLibraryCheckOutRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapRoleNameAsync(string name, string mountPath = default(string), LdapRoleRequest ldapRoleRequest = default(LdapRoleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapRotateRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapStaticRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateLdapStaticRoleNameAsync(string name, string mountPath = default(string), LdapStaticRoleRequest ldapStaticRoleRequest = default(LdapStaticRoleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="nomadConfigAccessRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateNomadConfigAccessAsync(string mountPath = default(string), NomadConfigAccessRequest nomadConfigAccessRequest = default(NomadConfigAccessRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiBundleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiBundleAsync(string mountPath = default(string), PkiBundleRequest pkiBundleRequest = default(PkiBundleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiCertRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiCertAsync(string mountPath = default(string), PkiCertRequest pkiCertRequest = default(PkiCertRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigAutoTidyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigAutoTidyAsync(string mountPath = default(string), PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest = default(PkiConfigAutoTidyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCaRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigCaAsync(string mountPath = default(string), PkiConfigCaRequest pkiConfigCaRequest = default(PkiConfigCaRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigCrlAsync(string mountPath = default(string), PkiConfigCrlRequest pkiConfigCrlRequest = default(PkiConfigCrlRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigIssuersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigIssuersAsync(string mountPath = default(string), PkiConfigIssuersRequest pkiConfigIssuersRequest = default(PkiConfigIssuersRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigKeysAsync(string mountPath = default(string), PkiConfigKeysRequest pkiConfigKeysRequest = default(PkiConfigKeysRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigUrlsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiConfigUrlsAsync(string mountPath = default(string), PkiConfigUrlsRequest pkiConfigUrlsRequest = default(PkiConfigUrlsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateCrossSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIntermediateCrossSignAsync(string mountPath = default(string), PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest = default(PkiIntermediateCrossSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateGenerateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIntermediateGenerateExportedAsync(string exported, string mountPath = default(string), PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest = default(PkiIntermediateGenerateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateSetSignedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIntermediateSetSignedAsync(string mountPath = default(string), PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest = default(PkiIntermediateSetSignedRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssueRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssueRoleAsync(string role, string mountPath = default(string), PkiIssueRequest pkiIssueRequest = default(PkiIssueRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerIssueRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerIssueRequest pkiIssuerIssueRequest = default(PkiIssuerIssueRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefRevokeAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest = default(PkiIssuerSignIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignRequest pkiIssuerSignRequest = default(PkiIssuerSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest = default(PkiIssuerSignSelfIssuedRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuersGenerateIntermediateExportedAsync(string exported, string mountPath = default(string), PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest = default(PkiIssuersGenerateIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateRootRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiIssuersGenerateRootExportedAsync(string exported, string mountPath = default(string), PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest = default(PkiIssuersGenerateRootRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiJsonRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiJsonAsync(string mountPath = default(string), PkiJsonRequest pkiJsonRequest = default(PkiJsonRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), PkiKeyRequest pkiKeyRequest = default(PkiKeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeysImportRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiKeysImportAsync(string mountPath = default(string), PkiKeysImportRequest pkiKeysImportRequest = default(PkiKeysImportRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKmsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiKmsAsync(string mountPath = default(string), PkiKmsRequest pkiKmsRequest = default(PkiKmsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiOcspAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRevokeAsync(string mountPath = default(string), PkiRevokeRequest pkiRevokeRequest = default(PkiRevokeRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeWithKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRevokeWithKeyAsync(string mountPath = default(string), PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest = default(PkiRevokeWithKeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootGenerateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRootGenerateExportedAsync(string exported, string mountPath = default(string), PkiRootGenerateRequest pkiRootGenerateRequest = default(PkiRootGenerateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootReplaceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRootReplaceAsync(string mountPath = default(string), PkiRootReplaceRequest pkiRootReplaceRequest = default(PkiRootReplaceRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootRotateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRootRotateExportedAsync(string exported, string mountPath = default(string), PkiRootRotateRequest pkiRootRotateRequest = default(PkiRootRotateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRootSignIntermediateAsync(string mountPath = default(string), PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest = default(PkiRootSignIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignSelfIssuedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiRootSignSelfIssuedAsync(string mountPath = default(string), PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest = default(PkiRootSignSelfIssuedRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiSignRoleAsync(string role, string mountPath = default(string), PkiSignRequest pkiSignRequest = default(PkiSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiSignVerbatimAsync(string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiSignVerbatimRoleAsync(string role, string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiTidyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiTidyAsync(string mountPath = default(string), PkiTidyRequest pkiTidyRequest = default(PkiTidyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdatePkiTidyCancelAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="rabbitmqConfigConnectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateRabbitmqConfigConnectionAsync(string mountPath = default(string), RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest = default(RabbitmqConfigConnectionRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSecretDataPathAsync(string path, string mountPath = default(string), KvDataRequest kvDataRequest = default(KvDataRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDeleteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSecretDeletePathAsync(string path, string mountPath = default(string), KvDeleteRequest kvDeleteRequest = default(KvDeleteRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSecretDestroyPathAsync(string path, string mountPath = default(string), KvDestroyRequest kvDestroyRequest = default(KvDestroyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSecretMetadataPathAsync(string path, string mountPath = default(string), KvMetadataRequest kvMetadataRequest = default(KvMetadataRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvUndeleteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSecretUndeletePathAsync(string path, string mountPath = default(string), KvUndeleteRequest kvUndeleteRequest = default(KvUndeleteRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshConfigZeroaddressRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSshConfigZeroaddressAsync(string mountPath = default(string), SshConfigZeroaddressRequest sshConfigZeroaddressRequest = default(SshConfigZeroaddressRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSshKeysKeyNameAsync(string keyName, string mountPath = default(string), SshKeysRequest sshKeysRequest = default(SshKeysRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSshLookupAsync(string mountPath = default(string), SshLookupRequest sshLookupRequest = default(SshLookupRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSshRolesRoleAsync(string role, string mountPath = default(string), SshRolesRequest sshRolesRequest = default(SshRolesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateSshVerifyAsync(string mountPath = default(string), SshVerifyRequest sshVerifyRequest = default(SshVerifyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpCodeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTotpCodeNameAsync(string name, string mountPath = default(string), TotpCodeRequest totpCodeRequest = default(TotpCodeRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTotpKeysNameAsync(string name, string mountPath = default(string), TotpKeysRequest totpKeysRequest = default(TotpKeysRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitCacheConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitCacheConfigAsync(string mountPath = default(string), TransitCacheConfigRequest transitCacheConfigRequest = default(TransitCacheConfigRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDatakeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitDatakeyPlaintextNameAsync(string name, string plaintext, string mountPath = default(string), TransitDatakeyRequest transitDatakeyRequest = default(TransitDatakeyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDecryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitDecryptNameAsync(string name, string mountPath = default(string), TransitDecryptRequest transitDecryptRequest = default(TransitDecryptRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitEncryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitEncryptNameAsync(string name, string mountPath = default(string), TransitEncryptRequest transitEncryptRequest = default(TransitEncryptRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitHashAsync(string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitHashUrlalgorithmAsync(string urlalgorithm, string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitHmacNameAsync(string name, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitKeysNameConfigAsync(string name, string mountPath = default(string), TransitKeysConfigRequest transitKeysConfigRequest = default(TransitKeysConfigRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitKeysNameImportAsync(string name, string mountPath = default(string), TransitKeysImportRequest transitKeysImportRequest = default(TransitKeysImportRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportVersionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitKeysNameImportVersionAsync(string name, string mountPath = default(string), TransitKeysImportVersionRequest transitKeysImportVersionRequest = default(TransitKeysImportVersionRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitKeysNameRotateAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysTrimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitKeysNameTrimAsync(string name, string mountPath = default(string), TransitKeysTrimRequest transitKeysTrimRequest = default(TransitKeysTrimRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRandomAsync(string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRandomSourceAsync(string source, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRandomSourceUrlbytesAsync(string source, string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRandomUrlbytesAsync(string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRestoreAsync(string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRestoreNameAsync(string name, string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRewrapRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitRewrapNameAsync(string name, string mountPath = default(string), TransitRewrapRequest transitRewrapRequest = default(TransitRewrapRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitSignNameAsync(string name, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitVerifyNameAsync(string name, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest), CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecrets : ISecretsSync, ISecretsAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Secrets : ISecrets
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Secrets
        /// </summary>
        public Secrets(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsRolesName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsRolesNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCubbyholePath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteCubbyholePathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGcpRolesetName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGcpRolesetNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGcpStaticAccountName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGcpkmsKeysKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLdapLibraryName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteLdapLibraryNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLdapRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteLdapRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLdapStaticRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteNomadConfigAccess(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteNomadConfigAccessAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string mountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeletePkiJson(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeletePkiJsonAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeletePkiKeyKeyRef(string keyRef, string mountPath = default(string))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeletePkiRoot(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeletePkiRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSecretDataPath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteSecretDataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSecretMetadataPath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteSecretMetadataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSshConfigZeroaddress(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteSshConfigZeroaddressAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSshKeysKeyName(string keyName, string mountPath = default(string))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSshRolesRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteSshRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteTotpKeysName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteTotpKeysNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsRoles(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListAwsRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoles", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsRolesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListAwsRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoles", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListGcpRolesets(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpRolesets");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/rolesets", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpRolesets", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListGcpRolesetsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpRolesets");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/rolesets", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpRolesets", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListGcpStaticAccounts(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpStaticAccounts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpStaticAccounts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListGcpStaticAccountsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpStaticAccounts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpStaticAccounts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListLdapLibrary(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapLibrary");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapLibrary", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListLdapLibraryAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapLibrary");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapLibrary", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListLdapRole(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListLdapRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListLdapStaticRole(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapStaticRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListLdapStaticRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLdapStaticRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListPkiCerts(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCerts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPkiCerts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListPkiCertsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCerts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPkiCerts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListPkiIssuers(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiIssuers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPkiIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListPkiIssuersAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiIssuers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPkiIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListTotpKeys(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListTotpKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTotpKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListTotpKeysAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListTotpKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTotpKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigLease(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigLease", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigLeaseAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigLease", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigRoot(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsCreds(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsCreds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsCredsAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsCreds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsRolesName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsRolesNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsStsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsStsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsStsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsStsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAzureCredsRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadAzureCredsRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAzureCredsRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAzureCredsRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadAzureCredsRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAzureCredsRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadCubbyholePath(string path, string mountPath = default(string), string list = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadCubbyholePathAsync(string path, string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpConfig(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpKeyRoleset(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpKeyRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpKeyRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpKeyRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpRolesetName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpRolesetNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpRolesetRolesetKey(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetRolesetKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpRolesetRolesetKeyAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetRolesetKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpRolesetRolesetToken(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetRolesetToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpRolesetRolesetTokenAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpRolesetRolesetToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpStaticAccountName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpStaticAccountNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpStaticAccountNameKey(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountNameKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpStaticAccountNameKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountNameKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpStaticAccountNameToken(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountNameToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpStaticAccountNameTokenAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpStaticAccountNameToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpTokenRoleset(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpTokenRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpTokenRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpTokenRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpkmsKeysConfigKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsKeysConfigKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpkmsKeysConfigKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsKeysConfigKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpkmsKeysKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpkmsKeysKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGcpkmsPubkeyKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsPubkeyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/pubkey/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsPubkeyKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGcpkmsPubkeyKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsPubkeyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/pubkey/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGcpkmsPubkeyKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapCredsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapCredsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapCredsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapCredsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapLibraryName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapLibraryNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapLibraryNameStatus(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryNameStatus");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapLibraryNameStatus", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapLibraryNameStatusAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryNameStatus");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapLibraryNameStatus", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapStaticCredName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticCredName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-cred/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapStaticCredName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapStaticCredNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticCredName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-cred/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapStaticCredName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadLdapStaticRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadLdapStaticRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadNomadConfigAccess(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadNomadConfigAccessAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCa(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCa", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCa", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCaChain(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCaChain", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCaChainAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCaChain", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCaPem(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCaPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCertCaChain(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertCaChain", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCertCaChainAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertCaChain", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCertSerial(string serial, string mountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerial");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerial", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCertSerialAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerial");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerial", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCertSerialRaw(string serial, string mountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRaw");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerialRaw", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCertSerialRawAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRaw");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerialRaw", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCertSerialRawPem(string serial, string mountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRawPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}/raw/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerialRawPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCertSerialRawPemAsync(string serial, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRawPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}/raw/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCertSerialRawPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiConfigAutoTidy(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigAutoTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiConfigAutoTidyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigAutoTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiConfigCrl(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiConfigCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiConfigIssuers(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiConfigIssuersAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiConfigKeys(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiConfigKeysAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiConfigUrls(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigUrls", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiConfigUrlsAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiConfigUrls", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCrl(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCrlRotate(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrlRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCrlRotateAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrlRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiCrlRotateDelta(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl/rotate-delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrlRotateDelta", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiCrlRotateDeltaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl/rotate-delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiCrlRotateDelta", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiDelta(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDelta", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiDeltaAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDelta", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiDeltaCrl(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/delta-crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDeltaCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiDeltaCrlAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/delta-crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDeltaCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiDeltaPem(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDeltaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiDeltaPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDeltaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiDer(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDer", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiDerAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiDer", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string mountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefCrlPemDerDeltaPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiIssuerRefCrlPemDerDeltaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefCrlPemDerDeltaPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiIssuerRefCrlPemDerDeltaPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiIssuerRefDerPem(string issuerRef, string mountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiIssuerRefDerPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiIssuerRefDerPemAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiIssuerRefDerPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiJson(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiJsonAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiKeyKeyRef(string keyRef, string mountPath = default(string))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->ReadPkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->ReadPkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiOcspReq(string req, string mountPath = default(string))
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->ReadPkiOcspReq");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ocsp/{req}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiOcspReq", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiOcspReqAsync(string req, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->ReadPkiOcspReq");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ocsp/{req}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiOcspReq", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiPem(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiPemAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiPem", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadPkiTidyStatus(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/tidy-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiTidyStatus", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadPkiTidyStatusAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/tidy-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadPkiTidyStatus", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSecretDataPath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSecretDataPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSecretMetadataPath(string path, string mountPath = default(string), string list = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSecretMetadataPathAsync(string path, string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSecretSubkeysPath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretSubkeysPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/subkeys/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretSubkeysPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSecretSubkeysPathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretSubkeysPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/subkeys/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSecretSubkeysPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSshConfigZeroaddress(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSshConfigZeroaddressAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSshPublicKey(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/public_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshPublicKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSshPublicKeyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/public_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshPublicKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadSshRolesRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadSshRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTotpCodeName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTotpCodeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTotpCodeNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTotpCodeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTotpKeysName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTotpKeysNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTransitBackupName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitBackupName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/backup/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitBackupName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTransitBackupNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitBackupName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/backup/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitBackupName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTransitCacheConfig(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitCacheConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTransitCacheConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitCacheConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTransitExportTypeName(string name, string type, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/export/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitExportTypeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTransitExportTypeNameAsync(string name, string type, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/export/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitExportTypeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTransitExportTypeNameVersion(string name, string type, string version, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->ReadTransitExportTypeNameVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/export/{type}/{name}/{version}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitExportTypeNameVersion", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTransitExportTypeNameVersionAsync(string name, string type, string version, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->ReadTransitExportTypeNameVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/export/{type}/{name}/{version}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitExportTypeNameVersion", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTransitWrappingKey(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/wrapping_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitWrappingKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTransitWrappingKeyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/wrapping_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTransitWrappingKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigLeaseRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigLease(string mountPath = default(string), AwsConfigLeaseRequest awsConfigLeaseRequest = default(AwsConfigLeaseRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigLease", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigLeaseRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigLeaseAsync(string mountPath = default(string), AwsConfigLeaseRequest awsConfigLeaseRequest = default(AwsConfigLeaseRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigLease", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigRootRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigRoot(string mountPath = default(string), AwsConfigRootRequest awsConfigRootRequest = default(AwsConfigRootRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigRootRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigRootAsync(string mountPath = default(string), AwsConfigRootRequest awsConfigRootRequest = default(AwsConfigRootRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsCredsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsCreds(string mountPath = default(string), AwsCredsRequest awsCredsRequest = default(AwsCredsRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsCreds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsCredsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsCredsAsync(string mountPath = default(string), AwsCredsRequest awsCredsRequest = default(AwsCredsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsCreds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsRolesName(string name, string mountPath = default(string), AwsRolesRequest awsRolesRequest = default(AwsRolesRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsRolesNameAsync(string name, string mountPath = default(string), AwsRolesRequest awsRolesRequest = default(AwsRolesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRolesName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsStsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsStsName(string name, string mountPath = default(string), AwsStsRequest awsStsRequest = default(AwsStsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsStsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsStsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsStsNameAsync(string name, string mountPath = default(string), AwsStsRequest awsStsRequest = default(AwsStsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsStsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateCubbyholePath(string path, string mountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateCubbyholePathAsync(string path, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCubbyholePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpConfig(string mountPath = default(string), GcpConfigRequest gcpConfigRequest = default(GcpConfigRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpConfigAsync(string mountPath = default(string), GcpConfigRequest gcpConfigRequest = default(GcpConfigRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpConfigRotateRoot(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpConfigRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpConfigRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpConfigRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpKeyRoleset(string roleset, string mountPath = default(string), GcpKeyRequest gcpKeyRequest = default(GcpKeyRequest))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpKeyRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpKeyRolesetAsync(string roleset, string mountPath = default(string), GcpKeyRequest gcpKeyRequest = default(GcpKeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpKeyRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRolesetName(string name, string mountPath = default(string), GcpRolesetRequest gcpRolesetRequest = default(GcpRolesetRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRolesetNameAsync(string name, string mountPath = default(string), GcpRolesetRequest gcpRolesetRequest = default(GcpRolesetRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRolesetNameRotate(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetNameRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRolesetNameRotateAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetNameRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRolesetNameRotateKey(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetNameRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRolesetNameRotateKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetNameRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRolesetRolesetKey(string roleset, string mountPath = default(string), GcpRolesetKeyRequest gcpRolesetKeyRequest = default(GcpRolesetKeyRequest))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetRolesetKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRolesetKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRolesetRolesetKeyAsync(string roleset, string mountPath = default(string), GcpRolesetKeyRequest gcpRolesetKeyRequest = default(GcpRolesetKeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetRolesetKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRolesetRolesetToken(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetRolesetToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRolesetRolesetTokenAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRolesetRolesetToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpStaticAccountName(string name, string mountPath = default(string), GcpStaticAccountRequest gcpStaticAccountRequest = default(GcpStaticAccountRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpStaticAccountNameAsync(string name, string mountPath = default(string), GcpStaticAccountRequest gcpStaticAccountRequest = default(GcpStaticAccountRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpStaticAccountNameKey(string name, string mountPath = default(string), GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest = default(GcpStaticAccountKeyRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpStaticAccountKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpStaticAccountNameKeyAsync(string name, string mountPath = default(string), GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest = default(GcpStaticAccountKeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpStaticAccountNameRotateKey(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpStaticAccountNameRotateKeyAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpStaticAccountNameToken(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpStaticAccountNameTokenAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpStaticAccountNameToken", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpTokenRoleset(string roleset, string mountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpTokenRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpTokenRolesetAsync(string roleset, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpTokenRoleset", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsDecryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsDecryptKey(string key, string mountPath = default(string), GcpkmsDecryptRequest gcpkmsDecryptRequest = default(GcpkmsDecryptRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsDecryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/decrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsDecryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsDecryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsDecryptKeyAsync(string key, string mountPath = default(string), GcpkmsDecryptRequest gcpkmsDecryptRequest = default(GcpkmsDecryptRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsDecryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/decrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsDecryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsEncryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsEncryptKey(string key, string mountPath = default(string), GcpkmsEncryptRequest gcpkmsEncryptRequest = default(GcpkmsEncryptRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsEncryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/encrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsEncryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsEncryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsEncryptKeyAsync(string key, string mountPath = default(string), GcpkmsEncryptRequest gcpkmsEncryptRequest = default(GcpkmsEncryptRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsEncryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/encrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsEncryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysConfigKey(string key, string mountPath = default(string), GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest = default(GcpkmsKeysConfigRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysConfigKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysConfigKeyAsync(string key, string mountPath = default(string), GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest = default(GcpkmsKeysConfigRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysConfigKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysDeregisterKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysDeregisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysDeregisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysKey(string key, string mountPath = default(string), GcpkmsKeysRequest gcpkmsKeysRequest = default(GcpkmsKeysRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysKeyAsync(string key, string mountPath = default(string), GcpkmsKeysRequest gcpkmsKeysRequest = default(GcpkmsKeysRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRegisterRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysRegisterKey(string key, string mountPath = default(string), GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest = default(GcpkmsKeysRegisterRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRegisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/register/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysRegisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsKeysRegisterRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysRegisterKeyAsync(string key, string mountPath = default(string), GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest = default(GcpkmsKeysRegisterRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRegisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/register/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysRegisterKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysRotateKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/rotate/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysRotateKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/rotate/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysRotateKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsKeysTrimKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysTrimKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsKeysTrimKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsKeysTrimKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsReencryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsReencryptKey(string key, string mountPath = default(string), GcpkmsReencryptRequest gcpkmsReencryptRequest = default(GcpkmsReencryptRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsReencryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/reencrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsReencryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsReencryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsReencryptKeyAsync(string key, string mountPath = default(string), GcpkmsReencryptRequest gcpkmsReencryptRequest = default(GcpkmsReencryptRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsReencryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/reencrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsReencryptKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsSignKey(string key, string mountPath = default(string), GcpkmsSignRequest gcpkmsSignRequest = default(GcpkmsSignRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsSignKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsSignKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsSignKeyAsync(string key, string mountPath = default(string), GcpkmsSignRequest gcpkmsSignRequest = default(GcpkmsSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsSignKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsSignKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpkmsVerifyKey(string key, string mountPath = default(string), GcpkmsVerifyRequest gcpkmsVerifyRequest = default(GcpkmsVerifyRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsVerifyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsVerifyKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="gcpkmsVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpkmsVerifyKeyAsync(string key, string mountPath = default(string), GcpkmsVerifyRequest gcpkmsVerifyRequest = default(GcpkmsVerifyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsVerifyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpkmsVerifyKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryManageCheckInRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapLibraryManageNameCheckIn(string name, string mountPath = default(string), LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest = default(LdapLibraryManageCheckInRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryManageNameCheckIn", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryManageCheckInRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapLibraryManageNameCheckInAsync(string name, string mountPath = default(string), LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest = default(LdapLibraryManageCheckInRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryManageNameCheckIn", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapLibraryName(string name, string mountPath = default(string), LdapLibraryRequest ldapLibraryRequest = default(LdapLibraryRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapLibraryNameAsync(string name, string mountPath = default(string), LdapLibraryRequest ldapLibraryRequest = default(LdapLibraryRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckInRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapLibraryNameCheckIn(string name, string mountPath = default(string), LdapLibraryCheckInRequest ldapLibraryCheckInRequest = default(LdapLibraryCheckInRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckIn", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckInRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapLibraryNameCheckInAsync(string name, string mountPath = default(string), LdapLibraryCheckInRequest ldapLibraryCheckInRequest = default(LdapLibraryCheckInRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckIn", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckOutRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapLibraryNameCheckOut(string name, string mountPath = default(string), LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest = default(LdapLibraryCheckOutRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckOut", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapLibraryCheckOutRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapLibraryNameCheckOutAsync(string name, string mountPath = default(string), LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest = default(LdapLibraryCheckOutRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckOut", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapRoleName(string name, string mountPath = default(string), LdapRoleRequest ldapRoleRequest = default(LdapRoleRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapRoleNameAsync(string name, string mountPath = default(string), LdapRoleRequest ldapRoleRequest = default(LdapRoleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapRotateRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRotateRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapRotateRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRotateRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapRotateRoot(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapStaticRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateLdapStaticRoleName(string name, string mountPath = default(string), LdapStaticRoleRequest ldapStaticRoleRequest = default(LdapStaticRoleRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="ldapStaticRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateLdapStaticRoleNameAsync(string name, string mountPath = default(string), LdapStaticRoleRequest ldapStaticRoleRequest = default(LdapStaticRoleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLdapStaticRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="nomadConfigAccessRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateNomadConfigAccess(string mountPath = default(string), NomadConfigAccessRequest nomadConfigAccessRequest = default(NomadConfigAccessRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="nomadConfigAccessRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateNomadConfigAccessAsync(string mountPath = default(string), NomadConfigAccessRequest nomadConfigAccessRequest = default(NomadConfigAccessRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateNomadConfigAccess", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiBundleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiBundle(string mountPath = default(string), PkiBundleRequest pkiBundleRequest = default(PkiBundleRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/bundle", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiBundle", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiBundleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiBundleAsync(string mountPath = default(string), PkiBundleRequest pkiBundleRequest = default(PkiBundleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/bundle", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiBundle", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiCertRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiCert(string mountPath = default(string), PkiCertRequest pkiCertRequest = default(PkiCertRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiCert", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiCertRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiCertAsync(string mountPath = default(string), PkiCertRequest pkiCertRequest = default(PkiCertRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiCert", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigAutoTidyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigAutoTidy(string mountPath = default(string), PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest = default(PkiConfigAutoTidyRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigAutoTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigAutoTidyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigAutoTidyAsync(string mountPath = default(string), PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest = default(PkiConfigAutoTidyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigAutoTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCaRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigCa(string mountPath = default(string), PkiConfigCaRequest pkiConfigCaRequest = default(PkiConfigCaRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCaRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigCa", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCaRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigCaAsync(string mountPath = default(string), PkiConfigCaRequest pkiConfigCaRequest = default(PkiConfigCaRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCaRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigCa", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCrlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigCrl(string mountPath = default(string), PkiConfigCrlRequest pkiConfigCrlRequest = default(PkiConfigCrlRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigCrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigCrlAsync(string mountPath = default(string), PkiConfigCrlRequest pkiConfigCrlRequest = default(PkiConfigCrlRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigCrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigIssuersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigIssuers(string mountPath = default(string), PkiConfigIssuersRequest pkiConfigIssuersRequest = default(PkiConfigIssuersRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigIssuersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigIssuersAsync(string mountPath = default(string), PkiConfigIssuersRequest pkiConfigIssuersRequest = default(PkiConfigIssuersRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigIssuers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigKeys(string mountPath = default(string), PkiConfigKeysRequest pkiConfigKeysRequest = default(PkiConfigKeysRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigKeysAsync(string mountPath = default(string), PkiConfigKeysRequest pkiConfigKeysRequest = default(PkiConfigKeysRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigKeys", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigUrlsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiConfigUrls(string mountPath = default(string), PkiConfigUrlsRequest pkiConfigUrlsRequest = default(PkiConfigUrlsRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigUrls", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiConfigUrlsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiConfigUrlsAsync(string mountPath = default(string), PkiConfigUrlsRequest pkiConfigUrlsRequest = default(PkiConfigUrlsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiConfigUrls", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateCrossSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIntermediateCrossSign(string mountPath = default(string), PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest = default(PkiIntermediateCrossSignRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/cross-sign", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateCrossSign", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateCrossSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIntermediateCrossSignAsync(string mountPath = default(string), PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest = default(PkiIntermediateCrossSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/cross-sign", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateCrossSign", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateGenerateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIntermediateGenerateExported(string exported, string mountPath = default(string), PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest = default(PkiIntermediateGenerateRequest))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIntermediateGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateGenerateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateGenerateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIntermediateGenerateExportedAsync(string exported, string mountPath = default(string), PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest = default(PkiIntermediateGenerateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIntermediateGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateGenerateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateSetSignedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIntermediateSetSigned(string mountPath = default(string), PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest = default(PkiIntermediateSetSignedRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/set-signed", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateSetSigned", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIntermediateSetSignedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIntermediateSetSignedAsync(string mountPath = default(string), PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest = default(PkiIntermediateSetSignedRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/set-signed", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIntermediateSetSigned", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssueRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssueRole(string role, string mountPath = default(string), PkiIssueRequest pkiIssueRequest = default(PkiIssueRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssueRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssueRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssueRoleAsync(string role, string mountPath = default(string), PkiIssueRequest pkiIssueRequest = default(PkiIssueRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssueRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerIssueRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefIssueRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerIssueRequest pkiIssuerIssueRequest = default(PkiIssuerIssueRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefIssueRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerIssueRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerIssueRequest pkiIssuerIssueRequest = default(PkiIssuerIssueRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefIssueRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefRevoke(string issuerRef, string mountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefRevokeAsync(string issuerRef, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefSignIntermediate(string issuerRef, string mountPath = default(string), PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest = default(PkiIssuerSignIntermediateRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignIntermediate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest = default(PkiIssuerSignIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignIntermediate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefSignRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignRequest pkiIssuerSignRequest = default(PkiIssuerSignRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignRequest pkiIssuerSignRequest = default(PkiIssuerSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefSignSelfIssued(string issuerRef, string mountPath = default(string), PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest = default(PkiIssuerSignSelfIssuedRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignSelfIssued", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest = default(PkiIssuerSignSelfIssuedRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignSelfIssued", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatim(string issuerRef, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatimRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuerSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, string mountPath = default(string), PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest = default(PkiIssuerSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatimRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuersGenerateIntermediateExported(string exported, string mountPath = default(string), PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest = default(PkiIssuersGenerateIntermediateRequest))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuers/generate/intermediate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuersGenerateIntermediateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuersGenerateIntermediateExportedAsync(string exported, string mountPath = default(string), PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest = default(PkiIssuersGenerateIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuers/generate/intermediate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuersGenerateIntermediateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateRootRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiIssuersGenerateRootExported(string exported, string mountPath = default(string), PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest = default(PkiIssuersGenerateRootRequest))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateRootExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuers/generate/root/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuersGenerateRootExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiIssuersGenerateRootRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiIssuersGenerateRootExportedAsync(string exported, string mountPath = default(string), PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest = default(PkiIssuersGenerateRootRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateRootExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuers/generate/root/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiIssuersGenerateRootExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiJsonRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiJson(string mountPath = default(string), PkiJsonRequest pkiJsonRequest = default(PkiJsonRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiJsonRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiJsonAsync(string mountPath = default(string), PkiJsonRequest pkiJsonRequest = default(PkiJsonRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiJson", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiKeyKeyRef(string keyRef, string mountPath = default(string), PkiKeyRequest pkiKeyRequest = default(PkiKeyRequest))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->UpdatePkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiKeyKeyRefAsync(string keyRef, string mountPath = default(string), PkiKeyRequest pkiKeyRequest = default(PkiKeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->UpdatePkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKeyKeyRef", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeysImportRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiKeysImport(string mountPath = default(string), PkiKeysImportRequest pkiKeysImportRequest = default(PkiKeysImportRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKeysImport", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKeysImportRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiKeysImportAsync(string mountPath = default(string), PkiKeysImportRequest pkiKeysImportRequest = default(PkiKeysImportRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKeysImport", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKmsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiKms(string mountPath = default(string), PkiKmsRequest pkiKmsRequest = default(PkiKmsRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/kms", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKms", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiKmsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiKmsAsync(string mountPath = default(string), PkiKmsRequest pkiKmsRequest = default(PkiKmsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/kms", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiKms", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiOcsp(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/ocsp", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiOcsp", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiOcspAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/ocsp", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiOcsp", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRevoke(string mountPath = default(string), PkiRevokeRequest pkiRevokeRequest = default(PkiRevokeRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRevokeAsync(string mountPath = default(string), PkiRevokeRequest pkiRevokeRequest = default(PkiRevokeRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeWithKeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRevokeWithKey(string mountPath = default(string), PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest = default(PkiRevokeWithKeyRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/revoke-with-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRevokeWithKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRevokeWithKeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRevokeWithKeyAsync(string mountPath = default(string), PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest = default(PkiRevokeWithKeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/revoke-with-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRevokeWithKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootGenerateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRootGenerateExported(string exported, string mountPath = default(string), PkiRootGenerateRequest pkiRootGenerateRequest = default(PkiRootGenerateRequest))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootGenerateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootGenerateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRootGenerateExportedAsync(string exported, string mountPath = default(string), PkiRootGenerateRequest pkiRootGenerateRequest = default(PkiRootGenerateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootGenerateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootReplaceRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRootReplace(string mountPath = default(string), PkiRootReplaceRequest pkiRootReplaceRequest = default(PkiRootReplaceRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/replace", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootReplace", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootReplaceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRootReplaceAsync(string mountPath = default(string), PkiRootReplaceRequest pkiRootReplaceRequest = default(PkiRootReplaceRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/replace", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootReplace", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootRotateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRootRotateExported(string exported, string mountPath = default(string), PkiRootRotateRequest pkiRootRotateRequest = default(PkiRootRotateRequest))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootRotateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/rotate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootRotateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootRotateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRootRotateExportedAsync(string exported, string mountPath = default(string), PkiRootRotateRequest pkiRootRotateRequest = default(PkiRootRotateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootRotateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/rotate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootRotateExported", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignIntermediateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRootSignIntermediate(string mountPath = default(string), PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest = default(PkiRootSignIntermediateRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootSignIntermediate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignIntermediateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRootSignIntermediateAsync(string mountPath = default(string), PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest = default(PkiRootSignIntermediateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootSignIntermediate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignSelfIssuedRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiRootSignSelfIssued(string mountPath = default(string), PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest = default(PkiRootSignSelfIssuedRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootSignSelfIssued", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiRootSignSelfIssuedRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiRootSignSelfIssuedAsync(string mountPath = default(string), PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest = default(PkiRootSignSelfIssuedRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiRootSignSelfIssued", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiSignRole(string role, string mountPath = default(string), PkiSignRequest pkiSignRequest = default(PkiSignRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiSignRoleAsync(string role, string mountPath = default(string), PkiSignRequest pkiSignRequest = default(PkiSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiSignVerbatim(string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignVerbatim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiSignVerbatimAsync(string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignVerbatim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiSignVerbatimRole(string role, string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignVerbatimRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiSignVerbatimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiSignVerbatimRoleAsync(string role, string mountPath = default(string), PkiSignVerbatimRequest pkiSignVerbatimRequest = default(PkiSignVerbatimRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiSignVerbatimRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiTidyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiTidy(string mountPath = default(string), PkiTidyRequest pkiTidyRequest = default(PkiTidyRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="pkiTidyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiTidyAsync(string mountPath = default(string), PkiTidyRequest pkiTidyRequest = default(PkiTidyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdatePkiTidyCancel(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/tidy-cancel", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiTidyCancel", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdatePkiTidyCancelAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/tidy-cancel", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePkiTidyCancel", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="rabbitmqConfigConnectionRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateRabbitmqConfigConnection(string mountPath = default(string), RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest = default(RabbitmqConfigConnectionRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/connection", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRabbitmqConfigConnection", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="rabbitmqConfigConnectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateRabbitmqConfigConnectionAsync(string mountPath = default(string), RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest = default(RabbitmqConfigConnectionRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/connection", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRabbitmqConfigConnection", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDataRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSecretDataPath(string path, string mountPath = default(string), KvDataRequest kvDataRequest = default(KvDataRequest))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSecretDataPathAsync(string path, string mountPath = default(string), KvDataRequest kvDataRequest = default(KvDataRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDeleteRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSecretDeletePath(string path, string mountPath = default(string), KvDeleteRequest kvDeleteRequest = default(KvDeleteRequest))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/delete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDeletePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDeleteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSecretDeletePathAsync(string path, string mountPath = default(string), KvDeleteRequest kvDeleteRequest = default(KvDeleteRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/delete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDeletePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSecretDestroyPath(string path, string mountPath = default(string), KvDestroyRequest kvDestroyRequest = default(KvDestroyRequest))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDestroyPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/destroy/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDestroyPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSecretDestroyPathAsync(string path, string mountPath = default(string), KvDestroyRequest kvDestroyRequest = default(KvDestroyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDestroyPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/destroy/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretDestroyPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvMetadataRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSecretMetadataPath(string path, string mountPath = default(string), KvMetadataRequest kvMetadataRequest = default(KvMetadataRequest))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvMetadataRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSecretMetadataPathAsync(string path, string mountPath = default(string), KvMetadataRequest kvMetadataRequest = default(KvMetadataRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretMetadataPath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvUndeleteRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSecretUndeletePath(string path, string mountPath = default(string), KvUndeleteRequest kvUndeleteRequest = default(KvUndeleteRequest))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretUndeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/undelete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretUndeletePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="kvUndeleteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSecretUndeletePathAsync(string path, string mountPath = default(string), KvUndeleteRequest kvUndeleteRequest = default(KvUndeleteRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretUndeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/undelete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSecretUndeletePath", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshConfigZeroaddressRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSshConfigZeroaddress(string mountPath = default(string), SshConfigZeroaddressRequest sshConfigZeroaddressRequest = default(SshConfigZeroaddressRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshConfigZeroaddressRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSshConfigZeroaddressAsync(string mountPath = default(string), SshConfigZeroaddressRequest sshConfigZeroaddressRequest = default(SshConfigZeroaddressRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshConfigZeroaddress", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSshKeysKeyName(string keyName, string mountPath = default(string), SshKeysRequest sshKeysRequest = default(SshKeysRequest))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->UpdateSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshKeysKeyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSshKeysKeyNameAsync(string keyName, string mountPath = default(string), SshKeysRequest sshKeysRequest = default(SshKeysRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->UpdateSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshKeysKeyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSshLookup(string mountPath = default(string), SshLookupRequest sshLookupRequest = default(SshLookupRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSshLookupAsync(string mountPath = default(string), SshLookupRequest sshLookupRequest = default(SshLookupRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSshRolesRole(string role, string mountPath = default(string), SshRolesRequest sshRolesRequest = default(SshRolesRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSshRolesRoleAsync(string role, string mountPath = default(string), SshRolesRequest sshRolesRequest = default(SshRolesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSshVerify(string mountPath = default(string), SshVerifyRequest sshVerifyRequest = default(SshVerifyRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshVerify", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="sshVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateSshVerifyAsync(string mountPath = default(string), SshVerifyRequest sshVerifyRequest = default(SshVerifyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSshVerify", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpCodeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTotpCodeName(string name, string mountPath = default(string), TotpCodeRequest totpCodeRequest = default(TotpCodeRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTotpCodeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpCodeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTotpCodeNameAsync(string name, string mountPath = default(string), TotpCodeRequest totpCodeRequest = default(TotpCodeRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTotpCodeName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpKeysRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTotpKeysName(string name, string mountPath = default(string), TotpKeysRequest totpKeysRequest = default(TotpKeysRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="totpKeysRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTotpKeysNameAsync(string name, string mountPath = default(string), TotpKeysRequest totpKeysRequest = default(TotpKeysRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTotpKeysName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitCacheConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitCacheConfig(string mountPath = default(string), TransitCacheConfigRequest transitCacheConfigRequest = default(TransitCacheConfigRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitCacheConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitCacheConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitCacheConfigAsync(string mountPath = default(string), TransitCacheConfigRequest transitCacheConfigRequest = default(TransitCacheConfigRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitCacheConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDatakeyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitDatakeyPlaintextName(string name, string plaintext, string mountPath = default(string), TransitDatakeyRequest transitDatakeyRequest = default(TransitDatakeyRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/datakey/{plaintext}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitDatakeyPlaintextName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDatakeyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitDatakeyPlaintextNameAsync(string name, string plaintext, string mountPath = default(string), TransitDatakeyRequest transitDatakeyRequest = default(TransitDatakeyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->UpdateTransitDatakeyPlaintextName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/datakey/{plaintext}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitDatakeyPlaintextName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDecryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitDecryptName(string name, string mountPath = default(string), TransitDecryptRequest transitDecryptRequest = default(TransitDecryptRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDecryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/decrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitDecryptName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitDecryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitDecryptNameAsync(string name, string mountPath = default(string), TransitDecryptRequest transitDecryptRequest = default(TransitDecryptRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDecryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/decrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitDecryptName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitEncryptRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitEncryptName(string name, string mountPath = default(string), TransitEncryptRequest transitEncryptRequest = default(TransitEncryptRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitEncryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/encrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitEncryptName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitEncryptRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitEncryptNameAsync(string name, string mountPath = default(string), TransitEncryptRequest transitEncryptRequest = default(TransitEncryptRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitEncryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/encrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitEncryptName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitHash(string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hash", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHash", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitHashAsync(string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hash", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHash", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitHashUrlalgorithm(string urlalgorithm, string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHashUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hash/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHashUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHashRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitHashUrlalgorithmAsync(string urlalgorithm, string mountPath = default(string), TransitHashRequest transitHashRequest = default(TransitHashRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHashUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hash/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHashUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitHmacName(string name, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hmac/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHmacName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitHmacNameAsync(string name, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hmac/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHmacName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitHmacNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hmac/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHmacNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitHmacRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitHmacRequest transitHmacRequest = default(TransitHmacRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hmac/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitHmacNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitKeysNameConfig(string name, string mountPath = default(string), TransitKeysConfigRequest transitKeysConfigRequest = default(TransitKeysConfigRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitKeysNameConfigAsync(string name, string mountPath = default(string), TransitKeysConfigRequest transitKeysConfigRequest = default(TransitKeysConfigRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitKeysNameImport(string name, string mountPath = default(string), TransitKeysImportRequest transitKeysImportRequest = default(TransitKeysImportRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImport");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameImport", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitKeysNameImportAsync(string name, string mountPath = default(string), TransitKeysImportRequest transitKeysImportRequest = default(TransitKeysImportRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImport");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameImport", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportVersionRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitKeysNameImportVersion(string name, string mountPath = default(string), TransitKeysImportVersionRequest transitKeysImportVersionRequest = default(TransitKeysImportVersionRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImportVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/import_version", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameImportVersion", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysImportVersionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitKeysNameImportVersionAsync(string name, string mountPath = default(string), TransitKeysImportVersionRequest transitKeysImportVersionRequest = default(TransitKeysImportVersionRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImportVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/import_version", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameImportVersion", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitKeysNameRotate(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitKeysNameRotateAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameRotate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysTrimRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitKeysNameTrim(string name, string mountPath = default(string), TransitKeysTrimRequest transitKeysTrimRequest = default(TransitKeysTrimRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameTrim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/trim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameTrim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitKeysTrimRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitKeysNameTrimAsync(string name, string mountPath = default(string), TransitKeysTrimRequest transitKeysTrimRequest = default(TransitKeysTrimRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameTrim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/trim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitKeysNameTrim", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRandom(string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandom", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRandomAsync(string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandom", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRandomSource(string source, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSource");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomSource", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRandomSourceAsync(string source, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSource");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomSource", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRandomSourceUrlbytes(string source, string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{source}/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomSourceUrlbytes", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRandomSourceUrlbytesAsync(string source, string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomSourceUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{source}/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomSourceUrlbytes", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRandomUrlbytes(string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomUrlbytes", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRandomRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRandomUrlbytesAsync(string urlbytes, string mountPath = default(string), TransitRandomRequest transitRandomRequest = default(TransitRandomRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRandomUrlbytes", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRestore(string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/restore", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRestore", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRestoreAsync(string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/restore", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRestore", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRestoreName(string name, string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRestoreName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/restore/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRestoreName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRestoreRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRestoreNameAsync(string name, string mountPath = default(string), TransitRestoreRequest transitRestoreRequest = default(TransitRestoreRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRestoreName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/restore/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRestoreName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRewrapRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitRewrapName(string name, string mountPath = default(string), TransitRewrapRequest transitRewrapRequest = default(TransitRewrapRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRewrapName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rewrap/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRewrapName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitRewrapRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitRewrapNameAsync(string name, string mountPath = default(string), TransitRewrapRequest transitRewrapRequest = default(TransitRewrapRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRewrapName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rewrap/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitRewrapName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitSignName(string name, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitSignName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitSignNameAsync(string name, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitSignName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitSignNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitSignNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitSignRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitSignRequest transitSignRequest = default(TransitSignRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitSignNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitSignNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitVerifyName(string name, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitVerifyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitVerifyNameAsync(string name, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitVerifyName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitVerifyNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="transitVerifyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, string mountPath = default(string), TransitVerifyRequest transitVerifyRequest = default(TransitVerifyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTransitVerifyNameUrlalgorithm", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }

    }
}
