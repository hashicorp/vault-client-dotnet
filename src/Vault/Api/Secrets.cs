/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteConsulRolesName(string name, string mountPath = "consul");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpRolesetName(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpStaticAccountName(string name, string mountPath = "gcp");
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapConfig(string mountPath = "ldap");
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapLibraryName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapRoleName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapStaticRoleName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteNomadConfigAccess(string mountPath = "nomad");
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteNomadConfigLease(string mountPath = "nomad");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiJson(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiKeyKeyRef(string keyRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiRoot(string mountPath = "pki");
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretDataPath(string path, string mountPath = "secret");
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretMetadataPath(string path, string mountPath = "secret");
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretPath(string path, string mountPath = "secret");
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshConfigCa(string mountPath = "ssh");
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshConfigZeroaddress(string mountPath = "ssh");
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshKeysKeyName(string keyName, string mountPath = "ssh");
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshRolesRole(string role, string mountPath = "ssh");
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTotpKeysName(string name, string mountPath = "totp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListGcpRolesets(string list, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListGcpStaticAccounts(string list, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListLdapLibrary(string list, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListLdapRole(string list, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListLdapStaticRole(string list, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListPkiCerts(string list, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListPkiCertsRevoked(string list, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListPkiIssuers(string list, string mountPath = "pki");
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSshRoles(string list, string mountPath = "ssh");
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListTotpKeys(string list, string mountPath = "totp");
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigRoot(string mountPath = "aws");
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsCreds(string mountPath = "aws");
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsStsName(string name, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadConsulRolesName(string name, string mountPath = "consul");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpKeyRoleset(string roleset, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpRolesetName(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpRolesetRolesetKey(string roleset, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpRolesetRolesetToken(string roleset, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpStaticAccountName(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpStaticAccountNameKey(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpStaticAccountNameToken(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpTokenRoleset(string roleset, string mountPath = "gcp");
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpkmsKeysConfigKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpkmsKeysKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGcpkmsPubkeyKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapConfig(string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapCredsName(string name, string mountPath = "ldap");
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapLibraryName(string name, string mountPath = "ldap");
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapLibraryNameStatus(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapRoleName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapStaticCredName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadLdapStaticRoleName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadNomadConfigAccess(string mountPath = "nomad");
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadNomadConfigLease(string mountPath = "nomad");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCa(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCaChain(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCaPem(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCertCaChain(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCertSerial(string serial, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCertSerialRaw(string serial, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCertSerialRawPem(string serial, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiConfigAutoTidy(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiConfigCrl(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiConfigIssuers(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiConfigKeys(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiConfigUrls(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCrl(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCrlRotate(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiCrlRotateDelta(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiDelta(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiDeltaCrl(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiDeltaPem(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiDer(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiIssuerRefDerPem(string issuerRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiJson(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiKeyKeyRef(string keyRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiOcspReq(string req, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiPem(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadPkiTidyStatus(string mountPath = "pki");
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSecretDataPath(string path, string mountPath = "secret");
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSecretMetadataPath(string path, string mountPath = "secret", string list = "false");
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSecretPath(string path, string mountPath = "secret", string list = "false");
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSecretSubkeysPath(string path, string mountPath = "secret");
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSshConfigCa(string mountPath = "ssh");
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSshConfigZeroaddress(string mountPath = "ssh");
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSshPublicKey(string mountPath = "ssh");
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSshRolesRole(string role, string mountPath = "ssh");
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTotpCodeName(string name, string mountPath = "totp");
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTotpKeysName(string name, string mountPath = "totp");
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTransitBackupName(string name, string mountPath = "transit");
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTransitCacheConfig(string mountPath = "transit");
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTransitExportTypeName(string name, string type, string mountPath = "transit");
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTransitExportTypeNameVersion(string name, string type, string version, string mountPath = "transit");
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTransitWrappingKey(string mountPath = "transit");
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigRoot(AwsConfigRootRequest awsConfigRootRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigRotateRoot(string mountPath = "aws");
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsCreds(AwsCredsRequest awsCredsRequest, string mountPath = "aws");
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsStsName(string name, AwsStsRequest awsStsRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateConsulRolesName(string name, ConsulRolesRequest consulRolesRequest, string mountPath = "consul");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpKeyRoleset(string roleset, GcpKeyRequest gcpKeyRequest, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRolesetName(string name, GcpRolesetRequest gcpRolesetRequest, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRolesetNameRotate(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRolesetNameRotateKey(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRolesetRolesetKey(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRolesetRolesetToken(string roleset, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpStaticAccountName(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpStaticAccountNameKey(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpStaticAccountNameRotateKey(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpStaticAccountNameToken(string name, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpTokenRoleset(string roleset, string mountPath = "gcp");
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsDecryptKey(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsEncryptKey(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysConfigKey(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysDeregisterKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysKey(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysRegisterKey(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysRotateKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsKeysTrimKey(string key, string mountPath = "gcpkms");
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsReencryptKey(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsSignKey(string key, GcpkmsSignRequest gcpkmsSignRequest, string mountPath = "gcpkms");
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpkmsVerifyKey(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string mountPath = "gcpkms");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapConfig(LdapConfigRequest ldapConfigRequest, string mountPath = "ldap");
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapLibraryManageNameCheckIn(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string mountPath = "ldap");
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapLibraryName(string name, LdapLibraryRequest ldapLibraryRequest, string mountPath = "ldap");
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapLibraryNameCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string mountPath = "ldap");
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapLibraryNameCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapRoleName(string name, LdapRoleRequest ldapRoleRequest, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapRotateRoleName(string name, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapRotateRoot(string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateLdapStaticRoleName(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string mountPath = "ldap");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateNomadConfigAccess(NomadConfigAccessRequest nomadConfigAccessRequest, string mountPath = "nomad");
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateNomadConfigLease(NomadConfigLeaseRequest nomadConfigLeaseRequest, string mountPath = "nomad");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiBundle(PkiBundleRequest pkiBundleRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiCert(PkiCertRequest pkiCertRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiConfigAutoTidy(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiConfigCrl(PkiConfigCrlRequest pkiConfigCrlRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiConfigIssuers(PkiConfigIssuersRequest pkiConfigIssuersRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiConfigKeys(PkiConfigKeysRequest pkiConfigKeysRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiConfigUrls(PkiConfigUrlsRequest pkiConfigUrlsRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIntermediateCrossSign(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIntermediateGenerateExported(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIntermediateSetSigned(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiInternalExported(PkiInternalExportedRequest pkiInternalExportedRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefIssueRole(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefRevoke(string issuerRef, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefSignRole(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuerRefDerPem(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuersGenerateIntermediateExported(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiIssuersGenerateRootExported(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiJson(PkiJsonRequest pkiJsonRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiKeyKeyRef(string keyRef, PkiKeyRequest pkiKeyRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiKeysImport(PkiKeysImportRequest pkiKeysImportRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiKms(PkiKmsRequest pkiKmsRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiOcsp(string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRevoke(PkiRevokeRequest pkiRevokeRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRootGenerateExported(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRootReplace(PkiRootReplaceRequest pkiRootReplaceRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRootRotateExported(string exported, PkiRootRotateRequest pkiRootRotateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiSignVerbatimRole(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiTidy(PkiTidyRequest pkiTidyRequest, string mountPath = "pki");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdatePkiTidyCancel(string mountPath = "pki");
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateRabbitmqConfigConnection(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string mountPath = "rabbitmq");
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretDataPath(string path, KvDataRequest kvDataRequest, string mountPath = "secret");
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretDeletePath(string path, KvDeleteRequest kvDeleteRequest, string mountPath = "secret");
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretDestroyPath(string path, KvDestroyRequest kvDestroyRequest, string mountPath = "secret");
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretMetadataPath(string path, KvMetadataRequest kvMetadataRequest, string mountPath = "secret");
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretPath(string path, string mountPath = "secret");
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSecretUndeletePath(string path, KvUndeleteRequest kvUndeleteRequest, string mountPath = "secret");
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshConfigCa(SshConfigCaRequest sshConfigCaRequest, string mountPath = "ssh");
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshConfigZeroaddress(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string mountPath = "ssh");
        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshCredsRole(string role, SshCredsRequest sshCredsRequest, string mountPath = "ssh");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshIssueRole(string role, SshIssueRequest sshIssueRequest, string mountPath = "ssh");
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshKeysKeyName(string keyName, SshKeysRequest sshKeysRequest, string mountPath = "ssh");
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshLookup(SshLookupRequest sshLookupRequest, string mountPath = "ssh");
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshRolesRole(string role, SshRolesRequest sshRolesRequest, string mountPath = "ssh");
        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshSignRole(string role, SshSignRequest sshSignRequest, string mountPath = "ssh");
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSshVerify(SshVerifyRequest sshVerifyRequest, string mountPath = "ssh");
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTotpCodeName(string name, TotpCodeRequest totpCodeRequest, string mountPath = "totp");
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTotpKeysName(string name, TotpKeysRequest totpKeysRequest, string mountPath = "totp");
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitCacheConfig(TransitCacheConfigRequest transitCacheConfigRequest, string mountPath = "transit");
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitDatakeyPlaintextName(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string mountPath = "transit");
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitDecryptName(string name, TransitDecryptRequest transitDecryptRequest, string mountPath = "transit");
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitEncryptName(string name, TransitEncryptRequest transitEncryptRequest, string mountPath = "transit");
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitHash(TransitHashRequest transitHashRequest, string mountPath = "transit");
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitHashUrlalgorithm(string urlalgorithm, TransitHashRequest transitHashRequest, string mountPath = "transit");
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitHmacName(string name, TransitHmacRequest transitHmacRequest, string mountPath = "transit");
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitHmacNameUrlalgorithm(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string mountPath = "transit");
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitKeysNameConfig(string name, TransitKeysConfigRequest transitKeysConfigRequest, string mountPath = "transit");
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitKeysNameImport(string name, TransitKeysImportRequest transitKeysImportRequest, string mountPath = "transit");
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitKeysNameImportVersion(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string mountPath = "transit");
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitKeysNameRotate(string name, string mountPath = "transit");
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitKeysNameTrim(string name, TransitKeysTrimRequest transitKeysTrimRequest, string mountPath = "transit");
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRandom(TransitRandomRequest transitRandomRequest, string mountPath = "transit");
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRandomSource(string source, TransitRandomRequest transitRandomRequest, string mountPath = "transit");
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRandomSourceUrlbytes(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit");
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRandomUrlbytes(string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit");
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRestore(TransitRestoreRequest transitRestoreRequest, string mountPath = "transit");
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRestoreName(string name, TransitRestoreRequest transitRestoreRequest, string mountPath = "transit");
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitRewrapName(string name, TransitRewrapRequest transitRewrapRequest, string mountPath = "transit");
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitSignName(string name, TransitSignRequest transitSignRequest, string mountPath = "transit");
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitSignNameUrlalgorithm(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string mountPath = "transit");
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitVerifyName(string name, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit");
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit");
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteConsulRolesNameAsync(string name, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpRolesetNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapConfigAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapLibraryNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteNomadConfigAccessAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteNomadConfigLeaseAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiJsonAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiRootAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretDataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretMetadataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshConfigCaAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshConfigZeroaddressAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshRolesRoleAsync(string role, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTotpKeysNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListGcpRolesetsAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListGcpStaticAccountsAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListLdapLibraryAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListLdapRoleAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListLdapStaticRoleAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListPkiCertsAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListPkiCertsRevokedAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListPkiIssuersAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSshRolesAsync(string list, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListTotpKeysAsync(string list, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsCredsAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsStsNameAsync(string name, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadConsulRolesNameAsync(string name, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpKeyRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpRolesetNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpRolesetRolesetKeyAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpRolesetRolesetTokenAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpStaticAccountNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpStaticAccountNameKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpStaticAccountNameTokenAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpTokenRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpkmsKeysConfigKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpkmsKeysKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGcpkmsPubkeyKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapConfigAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapCredsNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapLibraryNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapLibraryNameStatusAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapStaticCredNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadLdapStaticRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadNomadConfigAccessAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadNomadConfigLeaseAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCaChainAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCaPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCertCaChainAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCertSerialAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCertSerialRawAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCertSerialRawPemAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiConfigAutoTidyAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiConfigCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiConfigIssuersAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiConfigKeysAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiConfigUrlsAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCrlRotateAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiCrlRotateDeltaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiDeltaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiDeltaCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiDeltaPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiDerAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiIssuerRefDerPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiJsonAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiKeyKeyRefAsync(string keyRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiOcspReqAsync(string req, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadPkiTidyStatusAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSecretDataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSecretMetadataPathAsync(string path, string mountPath = "secret", string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSecretPathAsync(string path, string mountPath = "secret", string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSecretSubkeysPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSshConfigCaAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSshConfigZeroaddressAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSshPublicKeyAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSshRolesRoleAsync(string role, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTotpCodeNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTotpKeysNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTransitBackupNameAsync(string name, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTransitCacheConfigAsync(string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTransitExportTypeNameAsync(string name, string type, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTransitExportTypeNameVersionAsync(string name, string type, string version, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTransitWrappingKeyAsync(string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigRootAsync(AwsConfigRootRequest awsConfigRootRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigRotateRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsCredsAsync(AwsCredsRequest awsCredsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsStsNameAsync(string name, AwsStsRequest awsStsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateConsulRolesNameAsync(string name, ConsulRolesRequest consulRolesRequest, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpKeyRolesetAsync(string roleset, GcpKeyRequest gcpKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRolesetNameAsync(string name, GcpRolesetRequest gcpRolesetRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRolesetNameRotateAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRolesetNameRotateKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRolesetRolesetKeyAsync(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRolesetRolesetTokenAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpStaticAccountNameAsync(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpStaticAccountNameKeyAsync(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpStaticAccountNameRotateKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpStaticAccountNameTokenAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpTokenRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsDecryptKeyAsync(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsEncryptKeyAsync(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysConfigKeyAsync(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysKeyAsync(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysRegisterKeyAsync(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysRotateKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsKeysTrimKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsReencryptKeyAsync(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsSignKeyAsync(string key, GcpkmsSignRequest gcpkmsSignRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpkmsVerifyKeyAsync(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapLibraryManageNameCheckInAsync(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapLibraryNameAsync(string name, LdapLibraryRequest ldapLibraryRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapLibraryNameCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapLibraryNameCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapRoleNameAsync(string name, LdapRoleRequest ldapRoleRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapRotateRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapRotateRootAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateLdapStaticRoleNameAsync(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateNomadConfigAccessAsync(NomadConfigAccessRequest nomadConfigAccessRequest, string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateNomadConfigLeaseAsync(NomadConfigLeaseRequest nomadConfigLeaseRequest, string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiBundleAsync(PkiBundleRequest pkiBundleRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiCertAsync(PkiCertRequest pkiCertRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiConfigAutoTidyAsync(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiConfigCrlAsync(PkiConfigCrlRequest pkiConfigCrlRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiConfigIssuersAsync(PkiConfigIssuersRequest pkiConfigIssuersRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiConfigKeysAsync(PkiConfigKeysRequest pkiConfigKeysRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiConfigUrlsAsync(PkiConfigUrlsRequest pkiConfigUrlsRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIntermediateCrossSignAsync(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIntermediateGenerateExportedAsync(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIntermediateSetSignedAsync(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiInternalExportedAsync(PkiInternalExportedRequest pkiInternalExportedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefRevokeAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuerRefDerPemAsync(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuersGenerateIntermediateExportedAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiIssuersGenerateRootExportedAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiJsonAsync(PkiJsonRequest pkiJsonRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiKeyKeyRefAsync(string keyRef, PkiKeyRequest pkiKeyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiKeysImportAsync(PkiKeysImportRequest pkiKeysImportRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiKmsAsync(PkiKmsRequest pkiKmsRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiOcspAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRootGenerateExportedAsync(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRootReplaceAsync(PkiRootReplaceRequest pkiRootReplaceRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRootRotateExportedAsync(string exported, PkiRootRotateRequest pkiRootRotateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiSignVerbatimRoleAsync(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiTidyAsync(PkiTidyRequest pkiTidyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdatePkiTidyCancelAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateRabbitmqConfigConnectionAsync(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string mountPath = "rabbitmq", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretDataPathAsync(string path, KvDataRequest kvDataRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretDeletePathAsync(string path, KvDeleteRequest kvDeleteRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretDestroyPathAsync(string path, KvDestroyRequest kvDestroyRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretMetadataPathAsync(string path, KvMetadataRequest kvMetadataRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSecretUndeletePathAsync(string path, KvUndeleteRequest kvUndeleteRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshConfigCaAsync(SshConfigCaRequest sshConfigCaRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshConfigZeroaddressAsync(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshCredsRoleAsync(string role, SshCredsRequest sshCredsRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshIssueRoleAsync(string role, SshIssueRequest sshIssueRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshKeysKeyNameAsync(string keyName, SshKeysRequest sshKeysRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshLookupAsync(SshLookupRequest sshLookupRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshRolesRoleAsync(string role, SshRolesRequest sshRolesRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshSignRoleAsync(string role, SshSignRequest sshSignRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSshVerifyAsync(SshVerifyRequest sshVerifyRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTotpCodeNameAsync(string name, TotpCodeRequest totpCodeRequest, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTotpKeysNameAsync(string name, TotpKeysRequest totpKeysRequest, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitCacheConfigAsync(TransitCacheConfigRequest transitCacheConfigRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitDatakeyPlaintextNameAsync(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitDecryptNameAsync(string name, TransitDecryptRequest transitDecryptRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitEncryptNameAsync(string name, TransitEncryptRequest transitEncryptRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitHashAsync(TransitHashRequest transitHashRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitHashUrlalgorithmAsync(string urlalgorithm, TransitHashRequest transitHashRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitHmacNameAsync(string name, TransitHmacRequest transitHmacRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitKeysNameConfigAsync(string name, TransitKeysConfigRequest transitKeysConfigRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitKeysNameImportAsync(string name, TransitKeysImportRequest transitKeysImportRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitKeysNameImportVersionAsync(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitKeysNameRotateAsync(string name, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitKeysNameTrimAsync(string name, TransitKeysTrimRequest transitKeysTrimRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRandomAsync(TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRandomSourceAsync(string source, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRandomSourceUrlbytesAsync(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRandomUrlbytesAsync(string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRestoreAsync(TransitRestoreRequest transitRestoreRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRestoreNameAsync(string name, TransitRestoreRequest transitRestoreRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitRewrapNameAsync(string name, TransitRewrapRequest transitRewrapRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitSignNameAsync(string name, TransitSignRequest transitSignRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitVerifyNameAsync(string name, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecrets : ISecretsSync, ISecretsAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Secrets : ISecrets
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Secrets
        /// </summary>
        public Secrets(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteConsulRolesName(string name, string mountPath = "consul")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteConsulRolesNameAsync(string name, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpRolesetName(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpRolesetNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpStaticAccountName(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapConfig(string mountPath = "ldap")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapConfigAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapLibraryName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapLibraryNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapRoleName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapStaticRoleName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteNomadConfigAccess(string mountPath = "nomad")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteNomadConfigAccessAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteNomadConfigLease(string mountPath = "nomad")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteNomadConfigLeaseAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiJson(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiJsonAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiKeyKeyRef(string keyRef, string mountPath = "pki")
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiRoot(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiRootAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretDataPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretDataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretMetadataPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretMetadataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshConfigCa(string mountPath = "ssh")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshConfigCaAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshConfigZeroaddress(string mountPath = "ssh")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshConfigZeroaddressAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshKeysKeyName(string keyName, string mountPath = "ssh")
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshRolesRole(string role, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshRolesRoleAsync(string role, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTotpKeysName(string name, string mountPath = "totp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTotpKeysNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListGcpRolesets(string list, string mountPath = "gcp")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpRolesets");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/rolesets", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListGcpRolesetsAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpRolesets");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/rolesets", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListGcpStaticAccounts(string list, string mountPath = "gcp")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpStaticAccounts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListGcpStaticAccountsAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListGcpStaticAccounts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListLdapLibrary(string list, string mountPath = "ldap")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapLibrary");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListLdapLibraryAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapLibrary");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListLdapRole(string list, string mountPath = "ldap")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListLdapRoleAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListLdapStaticRole(string list, string mountPath = "ldap")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListLdapStaticRoleAsync(string list, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListLdapStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListLdapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListPkiCerts(string list, string mountPath = "pki")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCerts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListPkiCertsAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCerts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListPkiCertsRevoked(string list, string mountPath = "pki")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCertsRevoked");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/certs/revoked", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiCertsRevoked", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListPkiCertsRevokedAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiCertsRevoked");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/certs/revoked", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiCertsRevoked", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListPkiIssuers(string list, string mountPath = "pki")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiIssuers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListPkiIssuersAsync(string list, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListPkiIssuers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListPkiIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSshRoles(string list, string mountPath = "ssh")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListSshRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSshRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSshRolesAsync(string list, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListSshRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSshRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListTotpKeys(string list, string mountPath = "totp")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListTotpKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListTotpKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListTotpKeysAsync(string list, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->ListTotpKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListTotpKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigRoot(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsCreds(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsCredsAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsStsName(string name, string mountPath = "aws")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsStsNameAsync(string name, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadConsulRolesName(string name, string mountPath = "consul")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadConsulRolesNameAsync(string name, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpKeyRoleset(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpKeyRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpRolesetName(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpRolesetNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpRolesetRolesetKey(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpRolesetRolesetKeyAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpRolesetRolesetToken(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpRolesetRolesetTokenAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpStaticAccountName(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpStaticAccountNameAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpStaticAccountNameKey(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpStaticAccountNameKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpStaticAccountNameToken(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpStaticAccountNameTokenAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpTokenRoleset(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpTokenRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->ReadGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpkmsKeysConfigKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpkmsKeysConfigKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpkmsKeysKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpkmsKeysKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGcpkmsPubkeyKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsPubkeyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/pubkey/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsPubkeyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGcpkmsPubkeyKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->ReadGcpkmsPubkeyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/pubkey/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGcpkmsPubkeyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapConfig(string mountPath = "ldap")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapConfigAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapCredsName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapCredsNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapLibraryName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapLibraryNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapLibraryNameStatus(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryNameStatus");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapLibraryNameStatusAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapLibraryNameStatus");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapRoleName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapStaticCredName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticCredName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-cred/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapStaticCredNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticCredName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-cred/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadLdapStaticRoleName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadLdapStaticRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadNomadConfigAccess(string mountPath = "nomad")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadNomadConfigAccessAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadNomadConfigLease(string mountPath = "nomad")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadNomadConfigLeaseAsync(string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCa(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCaChain(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCaChainAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCaPem(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ca/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCaPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ca/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCertCaChain(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCertCaChainAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCertSerial(string serial, string mountPath = "pki")
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerial");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerial", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCertSerialAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerial");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerial", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCertSerialRaw(string serial, string mountPath = "pki")
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRaw");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerialRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCertSerialRawAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRaw");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerialRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCertSerialRawPem(string serial, string mountPath = "pki")
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRawPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cert/{serial}/raw/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerialRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCertSerialRawPemAsync(string serial, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->ReadPkiCertSerialRawPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cert/{serial}/raw/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCertSerialRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiConfigAutoTidy(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiConfigAutoTidyAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiConfigCrl(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiConfigCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiConfigIssuers(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiConfigIssuersAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiConfigKeys(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiConfigKeysAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiConfigUrls(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiConfigUrlsAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCrl(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCrlRotate(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrlRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCrlRotateAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrlRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiCrlRotateDelta(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/crl/rotate-delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrlRotateDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiCrlRotateDeltaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/crl/rotate-delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiCrlRotateDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiDelta(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiDeltaAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiDeltaCrl(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/delta-crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiDeltaCrlAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/delta-crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiDeltaPem(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiDeltaPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiDer(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiDerAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefCrlPemDerDeltaPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiIssuerRefCrlPemDerDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefCrlPemDerDeltaPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiIssuerRefCrlPemDerDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiIssuerRefDerPem(string issuerRef, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiIssuerRefDerPemAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->ReadPkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiJson(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiJsonAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiKeyKeyRef(string keyRef, string mountPath = "pki")
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->ReadPkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiKeyKeyRefAsync(string keyRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->ReadPkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiOcspReq(string req, string mountPath = "pki")
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->ReadPkiOcspReq");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/ocsp/{req}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiOcspReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiOcspReqAsync(string req, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->ReadPkiOcspReq");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/ocsp/{req}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiOcspReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiPem(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}//pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiPemAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}//pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadPkiTidyStatus(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/tidy-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadPkiTidyStatusAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/tidy-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadPkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSecretDataPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSecretDataPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSecretMetadataPath(string path, string mountPath = "secret", string list = "false")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSecretMetadataPathAsync(string path, string mountPath = "secret", string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSecretPath(string path, string mountPath = "secret", string list = "false")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSecretPathAsync(string path, string mountPath = "secret", string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSecretSubkeysPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretSubkeysPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/subkeys/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretSubkeysPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSecretSubkeysPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->ReadSecretSubkeysPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/subkeys/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSecretSubkeysPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSshConfigCa(string mountPath = "ssh")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSshConfigCaAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSshConfigZeroaddress(string mountPath = "ssh")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSshConfigZeroaddressAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSshPublicKey(string mountPath = "ssh")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/public_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSshPublicKeyAsync(string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/public_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSshRolesRole(string role, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSshRolesRoleAsync(string role, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ReadSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTotpCodeName(string name, string mountPath = "totp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTotpCodeNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTotpKeysName(string name, string mountPath = "totp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTotpKeysNameAsync(string name, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTransitBackupName(string name, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitBackupName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/backup/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitBackupName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTransitBackupNameAsync(string name, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitBackupName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/backup/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitBackupName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTransitCacheConfig(string mountPath = "transit")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTransitCacheConfigAsync(string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTransitExportTypeName(string name, string type, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/export/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitExportTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTransitExportTypeNameAsync(string name, string type, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/export/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitExportTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTransitExportTypeNameVersion(string name, string type, string version, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->ReadTransitExportTypeNameVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/export/{type}/{name}/{version}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitExportTypeNameVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTransitExportTypeNameVersionAsync(string name, string type, string version, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->ReadTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->ReadTransitExportTypeNameVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/export/{type}/{name}/{version}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitExportTypeNameVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTransitWrappingKey(string mountPath = "transit")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mount_path}/wrapping_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTransitWrappingKeyAsync(string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mount_path}/wrapping_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTransitWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigRoot(AwsConfigRootRequest awsConfigRootRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigRootRequest' is set
            if (awsConfigRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigRootRequest' when calling Secrets->UpdateAwsConfigRoot");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigRootAsync(AwsConfigRootRequest awsConfigRootRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigRootRequest' is set
            if (awsConfigRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigRootRequest' when calling Secrets->UpdateAwsConfigRoot");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigRotateRoot(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigRotateRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsCreds(AwsCredsRequest awsCredsRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsCredsRequest' is set
            if (awsCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsCredsRequest' when calling Secrets->UpdateAwsCreds");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsCredsAsync(AwsCredsRequest awsCredsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsCredsRequest' is set
            if (awsCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsCredsRequest' when calling Secrets->UpdateAwsCreds");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsStsName(string name, AwsStsRequest awsStsRequest, string mountPath = "aws")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsStsName");

            // verify the required parameter 'awsStsRequest' is set
            if (awsStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsStsRequest' when calling Secrets->UpdateAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsStsNameAsync(string name, AwsStsRequest awsStsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateAwsStsName");

            // verify the required parameter 'awsStsRequest' is set
            if (awsStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsStsRequest' when calling Secrets->UpdateAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateConsulRolesName(string name, ConsulRolesRequest consulRolesRequest, string mountPath = "consul")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateConsulRolesName");

            // verify the required parameter 'consulRolesRequest' is set
            if (consulRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulRolesRequest' when calling Secrets->UpdateConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = consulRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateConsulRolesNameAsync(string name, ConsulRolesRequest consulRolesRequest, string mountPath = "consul", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateConsulRolesName");

            // verify the required parameter 'consulRolesRequest' is set
            if (consulRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulRolesRequest' when calling Secrets->UpdateConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = consulRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpKeyRoleset(string roleset, GcpKeyRequest gcpKeyRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpKeyRoleset");

            // verify the required parameter 'gcpKeyRequest' is set
            if (gcpKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpKeyRequest' when calling Secrets->UpdateGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpKeyRolesetAsync(string roleset, GcpKeyRequest gcpKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpKeyRoleset");

            // verify the required parameter 'gcpKeyRequest' is set
            if (gcpKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpKeyRequest' when calling Secrets->UpdateGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRolesetName(string name, GcpRolesetRequest gcpRolesetRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetName");

            // verify the required parameter 'gcpRolesetRequest' is set
            if (gcpRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetRequest' when calling Secrets->UpdateGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRolesetNameAsync(string name, GcpRolesetRequest gcpRolesetRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetName");

            // verify the required parameter 'gcpRolesetRequest' is set
            if (gcpRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetRequest' when calling Secrets->UpdateGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRolesetNameRotate(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRolesetNameRotateAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRolesetNameRotateKey(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRolesetNameRotateKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpRolesetNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRolesetRolesetKey(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetKey");

            // verify the required parameter 'gcpRolesetKeyRequest' is set
            if (gcpRolesetKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetKeyRequest' when calling Secrets->UpdateGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRolesetRolesetKeyAsync(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetKey");

            // verify the required parameter 'gcpRolesetKeyRequest' is set
            if (gcpRolesetKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetKeyRequest' when calling Secrets->UpdateGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRolesetRolesetToken(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRolesetRolesetTokenAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpStaticAccountName(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountName");

            // verify the required parameter 'gcpStaticAccountRequest' is set
            if (gcpStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountRequest' when calling Secrets->UpdateGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpStaticAccountNameAsync(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountName");

            // verify the required parameter 'gcpStaticAccountRequest' is set
            if (gcpStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountRequest' when calling Secrets->UpdateGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpStaticAccountNameKey(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameKey");

            // verify the required parameter 'gcpStaticAccountKeyRequest' is set
            if (gcpStaticAccountKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountKeyRequest' when calling Secrets->UpdateGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpStaticAccountNameKeyAsync(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameKey");

            // verify the required parameter 'gcpStaticAccountKeyRequest' is set
            if (gcpStaticAccountKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountKeyRequest' when calling Secrets->UpdateGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpStaticAccountNameRotateKey(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpStaticAccountNameRotateKeyAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpStaticAccountNameToken(string name, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpStaticAccountNameTokenAsync(string name, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpTokenRoleset(string roleset, string mountPath = "gcp")
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpTokenRolesetAsync(string roleset, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->UpdateGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsDecryptKey(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsDecryptKey");

            // verify the required parameter 'gcpkmsDecryptRequest' is set
            if (gcpkmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsDecryptRequest' when calling Secrets->UpdateGcpkmsDecryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/decrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsDecryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsDecryptKeyAsync(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsDecryptKey");

            // verify the required parameter 'gcpkmsDecryptRequest' is set
            if (gcpkmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsDecryptRequest' when calling Secrets->UpdateGcpkmsDecryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/decrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsDecryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsEncryptKey(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsEncryptKey");

            // verify the required parameter 'gcpkmsEncryptRequest' is set
            if (gcpkmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsEncryptRequest' when calling Secrets->UpdateGcpkmsEncryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/encrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsEncryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsEncryptKeyAsync(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsEncryptKey");

            // verify the required parameter 'gcpkmsEncryptRequest' is set
            if (gcpkmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsEncryptRequest' when calling Secrets->UpdateGcpkmsEncryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/encrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsEncryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysConfigKey(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysConfigKey");

            // verify the required parameter 'gcpkmsKeysConfigRequest' is set
            if (gcpkmsKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysConfigRequest' when calling Secrets->UpdateGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysConfigKeyAsync(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysConfigKey");

            // verify the required parameter 'gcpkmsKeysConfigRequest' is set
            if (gcpkmsKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysConfigRequest' when calling Secrets->UpdateGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysDeregisterKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysDeregisterKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysKey(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysKey");

            // verify the required parameter 'gcpkmsKeysRequest' is set
            if (gcpkmsKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRequest' when calling Secrets->UpdateGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysKeyAsync(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysKey");

            // verify the required parameter 'gcpkmsKeysRequest' is set
            if (gcpkmsKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRequest' when calling Secrets->UpdateGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysRegisterKey(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRegisterKey");

            // verify the required parameter 'gcpkmsKeysRegisterRequest' is set
            if (gcpkmsKeysRegisterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRegisterRequest' when calling Secrets->UpdateGcpkmsKeysRegisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/register/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysRegisterKeyAsync(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRegisterKey");

            // verify the required parameter 'gcpkmsKeysRegisterRequest' is set
            if (gcpkmsKeysRegisterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRegisterRequest' when calling Secrets->UpdateGcpkmsKeysRegisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/register/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysRotateKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/rotate/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysRotateKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/rotate/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsKeysTrimKey(string key, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsKeysTrimKeyAsync(string key, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsReencryptKey(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsReencryptKey");

            // verify the required parameter 'gcpkmsReencryptRequest' is set
            if (gcpkmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsReencryptRequest' when calling Secrets->UpdateGcpkmsReencryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/reencrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsReencryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsReencryptKeyAsync(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsReencryptKey");

            // verify the required parameter 'gcpkmsReencryptRequest' is set
            if (gcpkmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsReencryptRequest' when calling Secrets->UpdateGcpkmsReencryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/reencrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsReencryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsSignKey(string key, GcpkmsSignRequest gcpkmsSignRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsSignKey");

            // verify the required parameter 'gcpkmsSignRequest' is set
            if (gcpkmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsSignRequest' when calling Secrets->UpdateGcpkmsSignKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsSignKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsSignKeyAsync(string key, GcpkmsSignRequest gcpkmsSignRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsSignKey");

            // verify the required parameter 'gcpkmsSignRequest' is set
            if (gcpkmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsSignRequest' when calling Secrets->UpdateGcpkmsSignKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsSignKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpkmsVerifyKey(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string mountPath = "gcpkms")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsVerifyKey");

            // verify the required parameter 'gcpkmsVerifyRequest' is set
            if (gcpkmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsVerifyRequest' when calling Secrets->UpdateGcpkmsVerifyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsVerifyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpkmsVerifyKeyAsync(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string mountPath = "gcpkms", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->UpdateGcpkmsVerifyKey");

            // verify the required parameter 'gcpkmsVerifyRequest' is set
            if (gcpkmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsVerifyRequest' when calling Secrets->UpdateGcpkmsVerifyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpkmsVerifyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapConfig(LdapConfigRequest ldapConfigRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Secrets->UpdateLdapConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Secrets->UpdateLdapConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapLibraryManageNameCheckIn(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");

            // verify the required parameter 'ldapLibraryManageCheckInRequest' is set
            if (ldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryManageCheckInRequest' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapLibraryManageNameCheckInAsync(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");

            // verify the required parameter 'ldapLibraryManageCheckInRequest' is set
            if (ldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryManageCheckInRequest' when calling Secrets->UpdateLdapLibraryManageNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapLibraryName(string name, LdapLibraryRequest ldapLibraryRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryName");

            // verify the required parameter 'ldapLibraryRequest' is set
            if (ldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryRequest' when calling Secrets->UpdateLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapLibraryNameAsync(string name, LdapLibraryRequest ldapLibraryRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryName");

            // verify the required parameter 'ldapLibraryRequest' is set
            if (ldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryRequest' when calling Secrets->UpdateLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapLibraryNameCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckIn");

            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->UpdateLdapLibraryNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapLibraryNameCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckIn");

            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->UpdateLdapLibraryNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapLibraryNameCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckOut");

            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->UpdateLdapLibraryNameCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapLibraryNameCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapLibraryNameCheckOut");

            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->UpdateLdapLibraryNameCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapRoleName(string name, LdapRoleRequest ldapRoleRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRoleName");

            // verify the required parameter 'ldapRoleRequest' is set
            if (ldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapRoleRequest' when calling Secrets->UpdateLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapRoleNameAsync(string name, LdapRoleRequest ldapRoleRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRoleName");

            // verify the required parameter 'ldapRoleRequest' is set
            if (ldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapRoleRequest' when calling Secrets->UpdateLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapRotateRoleName(string name, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapRotateRoleNameAsync(string name, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapRotateRoot(string mountPath = "ldap")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapRotateRootAsync(string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateLdapStaticRoleName(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string mountPath = "ldap")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapStaticRoleName");

            // verify the required parameter 'ldapStaticRoleRequest' is set
            if (ldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapStaticRoleRequest' when calling Secrets->UpdateLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateLdapStaticRoleNameAsync(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string mountPath = "ldap", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateLdapStaticRoleName");

            // verify the required parameter 'ldapStaticRoleRequest' is set
            if (ldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapStaticRoleRequest' when calling Secrets->UpdateLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateNomadConfigAccess(NomadConfigAccessRequest nomadConfigAccessRequest, string mountPath = "nomad")
        {
            // verify the required parameter 'nomadConfigAccessRequest' is set
            if (nomadConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigAccessRequest' when calling Secrets->UpdateNomadConfigAccess");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateNomadConfigAccessAsync(NomadConfigAccessRequest nomadConfigAccessRequest, string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nomadConfigAccessRequest' is set
            if (nomadConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigAccessRequest' when calling Secrets->UpdateNomadConfigAccess");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateNomadConfigLease(NomadConfigLeaseRequest nomadConfigLeaseRequest, string mountPath = "nomad")
        {
            // verify the required parameter 'nomadConfigLeaseRequest' is set
            if (nomadConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigLeaseRequest' when calling Secrets->UpdateNomadConfigLease");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateNomadConfigLeaseAsync(NomadConfigLeaseRequest nomadConfigLeaseRequest, string mountPath = "nomad", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nomadConfigLeaseRequest' is set
            if (nomadConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigLeaseRequest' when calling Secrets->UpdateNomadConfigLease");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiBundle(PkiBundleRequest pkiBundleRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiBundleRequest' is set
            if (pkiBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiBundleRequest' when calling Secrets->UpdatePkiBundle");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/bundle", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiBundleAsync(PkiBundleRequest pkiBundleRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiBundleRequest' is set
            if (pkiBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiBundleRequest' when calling Secrets->UpdatePkiBundle");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/bundle", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiCert(PkiCertRequest pkiCertRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiCertRequest' is set
            if (pkiCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCertRequest' when calling Secrets->UpdatePkiCert");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiCertAsync(PkiCertRequest pkiCertRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiCertRequest' is set
            if (pkiCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCertRequest' when calling Secrets->UpdatePkiCert");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiConfigAutoTidy(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiConfigAutoTidyRequest' is set
            if (pkiConfigAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigAutoTidyRequest' when calling Secrets->UpdatePkiConfigAutoTidy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiConfigAutoTidyAsync(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigAutoTidyRequest' is set
            if (pkiConfigAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigAutoTidyRequest' when calling Secrets->UpdatePkiConfigAutoTidy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiConfigCrl(PkiConfigCrlRequest pkiConfigCrlRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiConfigCrlRequest' is set
            if (pkiConfigCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCrlRequest' when calling Secrets->UpdatePkiConfigCrl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiConfigCrlAsync(PkiConfigCrlRequest pkiConfigCrlRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigCrlRequest' is set
            if (pkiConfigCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCrlRequest' when calling Secrets->UpdatePkiConfigCrl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiConfigIssuers(PkiConfigIssuersRequest pkiConfigIssuersRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiConfigIssuersRequest' is set
            if (pkiConfigIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigIssuersRequest' when calling Secrets->UpdatePkiConfigIssuers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiConfigIssuersAsync(PkiConfigIssuersRequest pkiConfigIssuersRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigIssuersRequest' is set
            if (pkiConfigIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigIssuersRequest' when calling Secrets->UpdatePkiConfigIssuers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiConfigKeys(PkiConfigKeysRequest pkiConfigKeysRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiConfigKeysRequest' is set
            if (pkiConfigKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigKeysRequest' when calling Secrets->UpdatePkiConfigKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiConfigKeysAsync(PkiConfigKeysRequest pkiConfigKeysRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigKeysRequest' is set
            if (pkiConfigKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigKeysRequest' when calling Secrets->UpdatePkiConfigKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiConfigUrls(PkiConfigUrlsRequest pkiConfigUrlsRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiConfigUrlsRequest' is set
            if (pkiConfigUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigUrlsRequest' when calling Secrets->UpdatePkiConfigUrls");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiConfigUrlsAsync(PkiConfigUrlsRequest pkiConfigUrlsRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigUrlsRequest' is set
            if (pkiConfigUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigUrlsRequest' when calling Secrets->UpdatePkiConfigUrls");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIntermediateCrossSign(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiIntermediateCrossSignRequest' is set
            if (pkiIntermediateCrossSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateCrossSignRequest' when calling Secrets->UpdatePkiIntermediateCrossSign");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/cross-sign", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateCrossSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIntermediateCrossSignAsync(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiIntermediateCrossSignRequest' is set
            if (pkiIntermediateCrossSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateCrossSignRequest' when calling Secrets->UpdatePkiIntermediateCrossSign");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/cross-sign", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateCrossSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIntermediateGenerateExported(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIntermediateGenerateExported");

            // verify the required parameter 'pkiIntermediateGenerateRequest' is set
            if (pkiIntermediateGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateGenerateRequest' when calling Secrets->UpdatePkiIntermediateGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIntermediateGenerateExportedAsync(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIntermediateGenerateExported");

            // verify the required parameter 'pkiIntermediateGenerateRequest' is set
            if (pkiIntermediateGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateGenerateRequest' when calling Secrets->UpdatePkiIntermediateGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIntermediateSetSigned(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiIntermediateSetSignedRequest' is set
            if (pkiIntermediateSetSignedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateSetSignedRequest' when calling Secrets->UpdatePkiIntermediateSetSigned");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/intermediate/set-signed", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateSetSigned", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIntermediateSetSignedAsync(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiIntermediateSetSignedRequest' is set
            if (pkiIntermediateSetSignedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateSetSignedRequest' when calling Secrets->UpdatePkiIntermediateSetSigned");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/intermediate/set-signed", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIntermediateSetSigned", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiInternalExported(PkiInternalExportedRequest pkiInternalExportedRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiInternalExportedRequest' is set
            if (pkiInternalExportedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiInternalExportedRequest' when calling Secrets->UpdatePkiInternalExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiInternalExportedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/internal|exported", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiInternalExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiInternalExportedAsync(PkiInternalExportedRequest pkiInternalExportedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiInternalExportedRequest' is set
            if (pkiInternalExportedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiInternalExportedRequest' when calling Secrets->UpdatePkiInternalExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiInternalExportedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/internal|exported", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiInternalExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefIssueRole(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'pkiIssuerIssueRequest' is set
            if (pkiIssuerIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueRequest' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'pkiIssuerIssueRequest' is set
            if (pkiIssuerIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueRequest' when calling Secrets->UpdatePkiIssuerIssuerRefIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefRevoke(string issuerRef, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefRevokeAsync(string issuerRef, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");

            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");

            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefSignRole(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'pkiIssuerSignRequest' is set
            if (pkiIssuerSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");

            // verify the required parameter 'pkiIssuerSignRequest' is set
            if (pkiIssuerSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");

            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");

            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->UpdatePkiIssuerIssuerRefSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerIssuerRefSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuerRefDerPem(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string mountPath = "pki")
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerRefDerPem");

            // verify the required parameter 'pkiDerPemRequest' is set
            if (pkiDerPemRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiDerPemRequest' when calling Secrets->UpdatePkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiDerPemRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuerRefDerPemAsync(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->UpdatePkiIssuerRefDerPem");

            // verify the required parameter 'pkiDerPemRequest' is set
            if (pkiDerPemRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiDerPemRequest' when calling Secrets->UpdatePkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiDerPemRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuersGenerateIntermediateExported(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");

            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuers/generate/intermediate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuersGenerateIntermediateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuersGenerateIntermediateExportedAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");

            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->UpdatePkiIssuersGenerateIntermediateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuers/generate/intermediate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuersGenerateIntermediateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiIssuersGenerateRootExported(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string mountPath = "pki")
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateRootExported");

            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->UpdatePkiIssuersGenerateRootExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issuers/generate/root/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuersGenerateRootExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiIssuersGenerateRootExportedAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiIssuersGenerateRootExported");

            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->UpdatePkiIssuersGenerateRootExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issuers/generate/root/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiIssuersGenerateRootExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiJson(PkiJsonRequest pkiJsonRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiJsonRequest' is set
            if (pkiJsonRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiJsonRequest' when calling Secrets->UpdatePkiJson");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiJsonAsync(PkiJsonRequest pkiJsonRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiJsonRequest' is set
            if (pkiJsonRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiJsonRequest' when calling Secrets->UpdatePkiJson");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiKeyKeyRef(string keyRef, PkiKeyRequest pkiKeyRequest, string mountPath = "pki")
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->UpdatePkiKeyKeyRef");

            // verify the required parameter 'pkiKeyRequest' is set
            if (pkiKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeyRequest' when calling Secrets->UpdatePkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiKeyKeyRefAsync(string keyRef, PkiKeyRequest pkiKeyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->UpdatePkiKeyKeyRef");

            // verify the required parameter 'pkiKeyRequest' is set
            if (pkiKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeyRequest' when calling Secrets->UpdatePkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiKeysImport(PkiKeysImportRequest pkiKeysImportRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiKeysImportRequest' is set
            if (pkiKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeysImportRequest' when calling Secrets->UpdatePkiKeysImport");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKeysImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiKeysImportAsync(PkiKeysImportRequest pkiKeysImportRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiKeysImportRequest' is set
            if (pkiKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeysImportRequest' when calling Secrets->UpdatePkiKeysImport");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKeysImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiKms(PkiKmsRequest pkiKmsRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiKmsRequest' is set
            if (pkiKmsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKmsRequest' when calling Secrets->UpdatePkiKms");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/kms", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKms", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiKmsAsync(PkiKmsRequest pkiKmsRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiKmsRequest' is set
            if (pkiKmsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKmsRequest' when calling Secrets->UpdatePkiKms");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/kms", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiKms", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiOcsp(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/ocsp", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiOcspAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/ocsp", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRevoke(PkiRevokeRequest pkiRevokeRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->UpdatePkiRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->UpdatePkiRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->UpdatePkiRevokeWithKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/revoke-with-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->UpdatePkiRevokeWithKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/revoke-with-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRootGenerateExported(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootGenerateExported");

            // verify the required parameter 'pkiRootGenerateRequest' is set
            if (pkiRootGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootGenerateRequest' when calling Secrets->UpdatePkiRootGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRootGenerateExportedAsync(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootGenerateExported");

            // verify the required parameter 'pkiRootGenerateRequest' is set
            if (pkiRootGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootGenerateRequest' when calling Secrets->UpdatePkiRootGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRootReplace(PkiRootReplaceRequest pkiRootReplaceRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiRootReplaceRequest' is set
            if (pkiRootReplaceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootReplaceRequest' when calling Secrets->UpdatePkiRootReplace");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/replace", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootReplace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRootReplaceAsync(PkiRootReplaceRequest pkiRootReplaceRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootReplaceRequest' is set
            if (pkiRootReplaceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootReplaceRequest' when calling Secrets->UpdatePkiRootReplace");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/replace", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootReplace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRootRotateExported(string exported, PkiRootRotateRequest pkiRootRotateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootRotateExported");

            // verify the required parameter 'pkiRootRotateRequest' is set
            if (pkiRootRotateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootRotateRequest' when calling Secrets->UpdatePkiRootRotateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/rotate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootRotateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRootRotateExportedAsync(string exported, PkiRootRotateRequest pkiRootRotateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->UpdatePkiRootRotateExported");

            // verify the required parameter 'pkiRootRotateRequest' is set
            if (pkiRootRotateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootRotateRequest' when calling Secrets->UpdatePkiRootRotateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/rotate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootRotateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->UpdatePkiRootSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->UpdatePkiRootSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->UpdatePkiRootSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/root/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->UpdatePkiRootSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/root/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->UpdatePkiSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->UpdatePkiSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiSignVerbatimRole(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignVerbatimRole");

            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->UpdatePkiSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiSignVerbatimRoleAsync(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdatePkiSignVerbatimRole");

            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->UpdatePkiSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiTidy(PkiTidyRequest pkiTidyRequest, string mountPath = "pki")
        {
            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->UpdatePkiTidy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiTidyAsync(PkiTidyRequest pkiTidyRequest, string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->UpdatePkiTidy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdatePkiTidyCancel(string mountPath = "pki")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/tidy-cancel", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdatePkiTidyCancelAsync(string mountPath = "pki", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/tidy-cancel", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdatePkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateRabbitmqConfigConnection(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string mountPath = "rabbitmq")
        {
            // verify the required parameter 'rabbitmqConfigConnectionRequest' is set
            if (rabbitmqConfigConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigConnectionRequest' when calling Secrets->UpdateRabbitmqConfigConnection");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/connection", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateRabbitmqConfigConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateRabbitmqConfigConnectionAsync(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string mountPath = "rabbitmq", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'rabbitmqConfigConnectionRequest' is set
            if (rabbitmqConfigConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigConnectionRequest' when calling Secrets->UpdateRabbitmqConfigConnection");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/connection", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateRabbitmqConfigConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretDataPath(string path, KvDataRequest kvDataRequest, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDataPath");

            // verify the required parameter 'kvDataRequest' is set
            if (kvDataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDataRequest' when calling Secrets->UpdateSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretDataPathAsync(string path, KvDataRequest kvDataRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDataPath");

            // verify the required parameter 'kvDataRequest' is set
            if (kvDataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDataRequest' when calling Secrets->UpdateSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretDeletePath(string path, KvDeleteRequest kvDeleteRequest, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDeletePath");

            // verify the required parameter 'kvDeleteRequest' is set
            if (kvDeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDeleteRequest' when calling Secrets->UpdateSecretDeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/delete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretDeletePathAsync(string path, KvDeleteRequest kvDeleteRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDeletePath");

            // verify the required parameter 'kvDeleteRequest' is set
            if (kvDeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDeleteRequest' when calling Secrets->UpdateSecretDeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/delete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretDestroyPath(string path, KvDestroyRequest kvDestroyRequest, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDestroyPath");

            // verify the required parameter 'kvDestroyRequest' is set
            if (kvDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDestroyRequest' when calling Secrets->UpdateSecretDestroyPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/destroy/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDestroyPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretDestroyPathAsync(string path, KvDestroyRequest kvDestroyRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretDestroyPath");

            // verify the required parameter 'kvDestroyRequest' is set
            if (kvDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDestroyRequest' when calling Secrets->UpdateSecretDestroyPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/destroy/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretDestroyPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretMetadataPath(string path, KvMetadataRequest kvMetadataRequest, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretMetadataPath");

            // verify the required parameter 'kvMetadataRequest' is set
            if (kvMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvMetadataRequest' when calling Secrets->UpdateSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretMetadataPathAsync(string path, KvMetadataRequest kvMetadataRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretMetadataPath");

            // verify the required parameter 'kvMetadataRequest' is set
            if (kvMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvMetadataRequest' when calling Secrets->UpdateSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretPath(string path, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretPathAsync(string path, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSecretUndeletePath(string path, KvUndeleteRequest kvUndeleteRequest, string mountPath = "secret")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretUndeletePath");

            // verify the required parameter 'kvUndeleteRequest' is set
            if (kvUndeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvUndeleteRequest' when calling Secrets->UpdateSecretUndeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/undelete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretUndeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSecretUndeletePathAsync(string path, KvUndeleteRequest kvUndeleteRequest, string mountPath = "secret", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->UpdateSecretUndeletePath");

            // verify the required parameter 'kvUndeleteRequest' is set
            if (kvUndeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvUndeleteRequest' when calling Secrets->UpdateSecretUndeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/undelete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSecretUndeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshConfigCa(SshConfigCaRequest sshConfigCaRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'sshConfigCaRequest' is set
            if (sshConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigCaRequest' when calling Secrets->UpdateSshConfigCa");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigCaRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshConfigCaAsync(SshConfigCaRequest sshConfigCaRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshConfigCaRequest' is set
            if (sshConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigCaRequest' when calling Secrets->UpdateSshConfigCa");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigCaRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshConfigZeroaddress(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'sshConfigZeroaddressRequest' is set
            if (sshConfigZeroaddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigZeroaddressRequest' when calling Secrets->UpdateSshConfigZeroaddress");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshConfigZeroaddressAsync(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshConfigZeroaddressRequest' is set
            if (sshConfigZeroaddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigZeroaddressRequest' when calling Secrets->UpdateSshConfigZeroaddress");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshCredsRole(string role, SshCredsRequest sshCredsRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshCredsRole");

            // verify the required parameter 'sshCredsRequest' is set
            if (sshCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshCredsRequest' when calling Secrets->UpdateSshCredsRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshCredsRoleAsync(string role, SshCredsRequest sshCredsRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshCredsRole");

            // verify the required parameter 'sshCredsRequest' is set
            if (sshCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshCredsRequest' when calling Secrets->UpdateSshCredsRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshIssueRole(string role, SshIssueRequest sshIssueRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshIssueRole");

            // verify the required parameter 'sshIssueRequest' is set
            if (sshIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueRequest' when calling Secrets->UpdateSshIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshIssueRoleAsync(string role, SshIssueRequest sshIssueRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshIssueRole");

            // verify the required parameter 'sshIssueRequest' is set
            if (sshIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueRequest' when calling Secrets->UpdateSshIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshKeysKeyName(string keyName, SshKeysRequest sshKeysRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->UpdateSshKeysKeyName");

            // verify the required parameter 'sshKeysRequest' is set
            if (sshKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshKeysRequest' when calling Secrets->UpdateSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshKeysKeyNameAsync(string keyName, SshKeysRequest sshKeysRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->UpdateSshKeysKeyName");

            // verify the required parameter 'sshKeysRequest' is set
            if (sshKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshKeysRequest' when calling Secrets->UpdateSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshLookup(SshLookupRequest sshLookupRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'sshLookupRequest' is set
            if (sshLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshLookupRequest' when calling Secrets->UpdateSshLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshLookupAsync(SshLookupRequest sshLookupRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshLookupRequest' is set
            if (sshLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshLookupRequest' when calling Secrets->UpdateSshLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshRolesRole(string role, SshRolesRequest sshRolesRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshRolesRole");

            // verify the required parameter 'sshRolesRequest' is set
            if (sshRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshRolesRequest' when calling Secrets->UpdateSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshRolesRoleAsync(string role, SshRolesRequest sshRolesRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshRolesRole");

            // verify the required parameter 'sshRolesRequest' is set
            if (sshRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshRolesRequest' when calling Secrets->UpdateSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshSignRole(string role, SshSignRequest sshSignRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshSignRole");

            // verify the required parameter 'sshSignRequest' is set
            if (sshSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignRequest' when calling Secrets->UpdateSshSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshSignRoleAsync(string role, SshSignRequest sshSignRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->UpdateSshSignRole");

            // verify the required parameter 'sshSignRequest' is set
            if (sshSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignRequest' when calling Secrets->UpdateSshSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = sshSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSshVerify(SshVerifyRequest sshVerifyRequest, string mountPath = "ssh")
        {
            // verify the required parameter 'sshVerifyRequest' is set
            if (sshVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyRequest' when calling Secrets->UpdateSshVerify");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSshVerifyAsync(SshVerifyRequest sshVerifyRequest, string mountPath = "ssh", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshVerifyRequest' is set
            if (sshVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyRequest' when calling Secrets->UpdateSshVerify");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSshVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTotpCodeName(string name, TotpCodeRequest totpCodeRequest, string mountPath = "totp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpCodeName");

            // verify the required parameter 'totpCodeRequest' is set
            if (totpCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCodeRequest' when calling Secrets->UpdateTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTotpCodeNameAsync(string name, TotpCodeRequest totpCodeRequest, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpCodeName");

            // verify the required parameter 'totpCodeRequest' is set
            if (totpCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCodeRequest' when calling Secrets->UpdateTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTotpKeysName(string name, TotpKeysRequest totpKeysRequest, string mountPath = "totp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpKeysName");

            // verify the required parameter 'totpKeysRequest' is set
            if (totpKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpKeysRequest' when calling Secrets->UpdateTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTotpKeysNameAsync(string name, TotpKeysRequest totpKeysRequest, string mountPath = "totp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTotpKeysName");

            // verify the required parameter 'totpKeysRequest' is set
            if (totpKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpKeysRequest' when calling Secrets->UpdateTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitCacheConfig(TransitCacheConfigRequest transitCacheConfigRequest, string mountPath = "transit")
        {
            // verify the required parameter 'transitCacheConfigRequest' is set
            if (transitCacheConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCacheConfigRequest' when calling Secrets->UpdateTransitCacheConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitCacheConfigAsync(TransitCacheConfigRequest transitCacheConfigRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitCacheConfigRequest' is set
            if (transitCacheConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCacheConfigRequest' when calling Secrets->UpdateTransitCacheConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitDatakeyPlaintextName(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'transitDatakeyRequest' is set
            if (transitDatakeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDatakeyRequest' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/datakey/{plaintext}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitDatakeyPlaintextName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitDatakeyPlaintextNameAsync(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->UpdateTransitDatakeyPlaintextName");

            // verify the required parameter 'transitDatakeyRequest' is set
            if (transitDatakeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDatakeyRequest' when calling Secrets->UpdateTransitDatakeyPlaintextName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/datakey/{plaintext}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitDatakeyPlaintextName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitDecryptName(string name, TransitDecryptRequest transitDecryptRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDecryptName");

            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->UpdateTransitDecryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/decrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitDecryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitDecryptNameAsync(string name, TransitDecryptRequest transitDecryptRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitDecryptName");

            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->UpdateTransitDecryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/decrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitDecryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitEncryptName(string name, TransitEncryptRequest transitEncryptRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitEncryptName");

            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->UpdateTransitEncryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/encrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitEncryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitEncryptNameAsync(string name, TransitEncryptRequest transitEncryptRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitEncryptName");

            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->UpdateTransitEncryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/encrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitEncryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitHash(TransitHashRequest transitHashRequest, string mountPath = "transit")
        {
            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->UpdateTransitHash");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hash", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitHashAsync(TransitHashRequest transitHashRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->UpdateTransitHash");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hash", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitHashUrlalgorithm(string urlalgorithm, TransitHashRequest transitHashRequest, string mountPath = "transit")
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHashUrlalgorithm");

            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->UpdateTransitHashUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hash/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitHashUrlalgorithmAsync(string urlalgorithm, TransitHashRequest transitHashRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHashUrlalgorithm");

            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->UpdateTransitHashUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hash/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitHmacName(string name, TransitHmacRequest transitHmacRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacName");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->UpdateTransitHmacName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hmac/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHmacName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitHmacNameAsync(string name, TransitHmacRequest transitHmacRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacName");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->UpdateTransitHmacName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hmac/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHmacName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitHmacNameUrlalgorithm(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/hmac/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHmacNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->UpdateTransitHmacNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/hmac/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitHmacNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitKeysNameConfig(string name, TransitKeysConfigRequest transitKeysConfigRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameConfig");

            // verify the required parameter 'transitKeysConfigRequest' is set
            if (transitKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysConfigRequest' when calling Secrets->UpdateTransitKeysNameConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitKeysNameConfigAsync(string name, TransitKeysConfigRequest transitKeysConfigRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameConfig");

            // verify the required parameter 'transitKeysConfigRequest' is set
            if (transitKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysConfigRequest' when calling Secrets->UpdateTransitKeysNameConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitKeysNameImport(string name, TransitKeysImportRequest transitKeysImportRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImport");

            // verify the required parameter 'transitKeysImportRequest' is set
            if (transitKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportRequest' when calling Secrets->UpdateTransitKeysNameImport");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitKeysNameImportAsync(string name, TransitKeysImportRequest transitKeysImportRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImport");

            // verify the required parameter 'transitKeysImportRequest' is set
            if (transitKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportRequest' when calling Secrets->UpdateTransitKeysNameImport");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitKeysNameImportVersion(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImportVersion");

            // verify the required parameter 'transitKeysImportVersionRequest' is set
            if (transitKeysImportVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportVersionRequest' when calling Secrets->UpdateTransitKeysNameImportVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/import_version", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameImportVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitKeysNameImportVersionAsync(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameImportVersion");

            // verify the required parameter 'transitKeysImportVersionRequest' is set
            if (transitKeysImportVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportVersionRequest' when calling Secrets->UpdateTransitKeysNameImportVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/import_version", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameImportVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitKeysNameRotate(string name, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitKeysNameRotateAsync(string name, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitKeysNameTrim(string name, TransitKeysTrimRequest transitKeysTrimRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameTrim");

            // verify the required parameter 'transitKeysTrimRequest' is set
            if (transitKeysTrimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysTrimRequest' when calling Secrets->UpdateTransitKeysNameTrim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/keys/{name}/trim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameTrim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitKeysNameTrimAsync(string name, TransitKeysTrimRequest transitKeysTrimRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitKeysNameTrim");

            // verify the required parameter 'transitKeysTrimRequest' is set
            if (transitKeysTrimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysTrimRequest' when calling Secrets->UpdateTransitKeysNameTrim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/keys/{name}/trim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitKeysNameTrim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRandom(TransitRandomRequest transitRandomRequest, string mountPath = "transit")
        {
            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandom");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRandomAsync(TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandom");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRandomSource(string source, TransitRandomRequest transitRandomRequest, string mountPath = "transit")
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSource");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomSource");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRandomSourceAsync(string source, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSource");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomSource");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRandomSourceUrlbytes(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit")
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{source}/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRandomSourceUrlbytesAsync(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomSourceUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomSourceUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{source}/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRandomUrlbytes(string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit")
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/random/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRandomUrlbytesAsync(string urlbytes, TransitRandomRequest transitRandomRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->UpdateTransitRandomUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->UpdateTransitRandomUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/random/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRestore(TransitRestoreRequest transitRestoreRequest, string mountPath = "transit")
        {
            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->UpdateTransitRestore");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/restore", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRestore", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRestoreAsync(TransitRestoreRequest transitRestoreRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->UpdateTransitRestore");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/restore", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRestore", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRestoreName(string name, TransitRestoreRequest transitRestoreRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRestoreName");

            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->UpdateTransitRestoreName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/restore/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRestoreName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRestoreNameAsync(string name, TransitRestoreRequest transitRestoreRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRestoreName");

            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->UpdateTransitRestoreName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/restore/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRestoreName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitRewrapName(string name, TransitRewrapRequest transitRewrapRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRewrapName");

            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->UpdateTransitRewrapName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/rewrap/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRewrapName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitRewrapNameAsync(string name, TransitRewrapRequest transitRewrapRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitRewrapName");

            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->UpdateTransitRewrapName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/rewrap/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitRewrapName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitSignName(string name, TransitSignRequest transitSignRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignName");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->UpdateTransitSignName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitSignName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitSignNameAsync(string name, TransitSignRequest transitSignRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignName");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->UpdateTransitSignName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitSignName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitSignNameUrlalgorithm(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/sign/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitSignNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitSignNameUrlalgorithm");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->UpdateTransitSignNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/sign/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitSignNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitVerifyName(string name, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyName");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->UpdateTransitVerifyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitVerifyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitVerifyNameAsync(string name, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyName");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->UpdateTransitVerifyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitVerifyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mount_path}/verify/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitVerifyNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string mountPath = "transit", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->UpdateTransitVerifyNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mount_path}/verify/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTransitVerifyNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }

    }
}
