/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAdConfig(string adMountPath = default(string));
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAdLibraryName(string name, string adMountPath = default(string));
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAdRolesName(string name, string adMountPath = default(string));
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAlicloudConfig(string alicloudMountPath = default(string));
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAlicloudRoleName(string name, string alicloudMountPath = default(string));
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsRolesName(string name, string awsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAzureConfig(string azureMountPath = default(string));
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAzureRolesName(string name, string azureMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteConsulRolesName(string name, string consulMountPath = default(string));
        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteCubbyholePath(string path, string cubbyholeMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpRolesetName(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpStaticAccountName(string name, string gcpMountPath = default(string));
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsConfig(string gcpkmsMountPath = default(string));
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteKubernetesConfig(string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteKubernetesRolesName(string name, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapConfig(string ldapMountPath = default(string));
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapLibraryName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapRoleName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteLdapStaticRoleName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteMongodbatlasRolesName(string name, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteNomadConfigAccess(string nomadMountPath = default(string));
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteNomadConfigLease(string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteNomadRoleName(string name, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteOpenldapConfig(string openldapMountPath = default(string));
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteOpenldapLibraryName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteOpenldapRoleName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteOpenldapStaticRoleName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiJson(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiKeyKeyRef(string keyRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiRolesName(string name, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeletePkiRoot(string pkiMountPath = default(string));
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteRabbitmqRolesName(string name, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretDataPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretMetadataPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSecretPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshConfigCa(string sshMountPath = default(string));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshConfigZeroaddress(string sshMountPath = default(string));
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshKeysKeyName(string keyName, string sshMountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSshRolesRole(string role, string sshMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTerraformConfig(string terraformMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTerraformRoleName(string name, string terraformMountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTotpKeysName(string name, string totpMountPath = default(string));
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTransitKeysName(string name, string transitMountPath = default(string));
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdConfig(string adMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdCredsName(string name, string adMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdLibrary(string list, string adMountPath = default(string));
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdLibraryName(string name, string adMountPath = default(string));
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdLibraryNameStatus(string name, string adMountPath = default(string));
        /// <summary>
        /// List the name of each role currently stored.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdRoles(string list, string adMountPath = default(string));
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdRolesName(string name, string adMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAdRotateRoot(string adMountPath = default(string));
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAlicloudConfig(string alicloudMountPath = default(string));
        /// <summary>
        /// Generate an API key or STS credential using the given role&#39;s configuration.&#39;
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAlicloudCredsName(string name, string alicloudMountPath = default(string));
        /// <summary>
        /// List the existing roles in this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAlicloudRole(string list, string alicloudMountPath = default(string));
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAlicloudRoleName(string name, string alicloudMountPath = default(string));
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsConfigLease(string awsMountPath = default(string));
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsConfigRoot(string awsMountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsCreds(string awsMountPath = default(string));
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsRoles(string list, string awsMountPath = default(string));
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsRolesName(string name, string awsMountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAwsStsName(string name, string awsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAzureConfig(string azureMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAzureCredsRole(string role, string azureMountPath = default(string));
        /// <summary>
        /// List existing roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAzureRoles(string list, string azureMountPath = default(string));
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetAzureRolesName(string name, string azureMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetConsulConfigAccess(string consulMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetConsulCredsRole(string role, string consulMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetConsulRoles(string list, string consulMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetConsulRolesName(string name, string consulMountPath = default(string));
        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetCubbyholePath(string path, string cubbyholeMountPath = default(string), string list = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpConfig(string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpKeyRoleset(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpRolesetName(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpRolesetRolesetKey(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpRolesetRolesetToken(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpRolesets(string list, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpStaticAccountName(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpStaticAccountNameKey(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpStaticAccountNameToken(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpStaticAccounts(string list, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpTokenRoleset(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpkmsConfig(string gcpkmsMountPath = default(string));
        /// <summary>
        /// List named keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpkmsKeys(string list, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpkmsKeysConfigKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpkmsKeysKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetGcpkmsPubkeyKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetKubernetesConfig(string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetKubernetesRoles(string list, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetKubernetesRolesName(string name, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapConfig(string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapCredsName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapLibrary(string list, string ldapMountPath = default(string));
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapLibraryName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapLibraryNameStatus(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapRole(string list, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapRoleName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapStaticCredName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapStaticRole(string list, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetLdapStaticRoleName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// Configure the  credentials that are used to manage Database Users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetMongodbatlasConfig(string mongodbatlasMountPath = default(string));
        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetMongodbatlasCredsName(string name, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetMongodbatlasRoles(string list, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetMongodbatlasRolesName(string name, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetNomadConfigAccess(string nomadMountPath = default(string));
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetNomadConfigLease(string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetNomadCredsName(string name, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetNomadRole(string list, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetNomadRoleName(string name, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapConfig(string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapCredsName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapLibrary(string list, string openldapMountPath = default(string));
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapLibraryName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapLibraryNameStatus(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapRole(string list, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapRoleName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapStaticCredName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapStaticRole(string list, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetOpenldapStaticRoleName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCa(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCaChain(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCaPem(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCertCaChain(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCertSerial(string serial, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCertSerialRaw(string serial, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCertSerialRawPem(string serial, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCerts(string list, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCertsRevoked(string list, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiConfigAutoTidy(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiConfigCrl(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiConfigIssuers(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiConfigKeys(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiConfigUrls(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCrl(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCrlRotate(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiCrlRotateDelta(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiDelta(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiDeltaCrl(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiDeltaPem(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiDer(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiIssuerRefDerPem(string issuerRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiIssuers(string list, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiJson(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiKeyKeyRef(string keyRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiKeys(string list, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiOcspReq(string req, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiPem(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiRoles(string list, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiRolesName(string name, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetPkiTidyStatus(string pkiMountPath = default(string));
        /// <summary>
        /// Configure the lease parameters for generated credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetRabbitmqConfigLease(string rabbitmqMountPath = default(string));
        /// <summary>
        /// Request RabbitMQ credentials for a certain role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetRabbitmqCredsName(string name, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetRabbitmqRoles(string list, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetRabbitmqRolesName(string name, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Read the backend level settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSecretConfig(string secretMountPath = default(string));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSecretDataPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSecretMetadataPath(string path, string secretMountPath = default(string), string list = default(string));
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSecretPath(string path, string secretMountPath = default(string), string list = default(string));
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSecretSubkeysPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSshConfigCa(string sshMountPath = default(string));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSshConfigZeroaddress(string sshMountPath = default(string));
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSshPublicKey(string sshMountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSshRoles(string list, string sshMountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetSshRolesRole(string role, string sshMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTerraformConfig(string terraformMountPath = default(string));
        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTerraformCredsName(string name, string terraformMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTerraformRole(string list, string terraformMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTerraformRoleName(string name, string terraformMountPath = default(string));
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTotpCodeName(string name, string totpMountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTotpKeys(string list, string totpMountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTotpKeysName(string name, string totpMountPath = default(string));
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitBackupName(string name, string transitMountPath = default(string));
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitCacheConfig(string transitMountPath = default(string));
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitExportTypeName(string name, string type, string transitMountPath = default(string));
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitExportTypeNameVersion(string name, string type, string version, string transitMountPath = default(string));
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitKeys(string list, string transitMountPath = default(string));
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitKeysName(string name, string transitMountPath = default(string));
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> GetTransitWrappingKey(string transitMountPath = default(string));
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adConfigRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdConfig(AdConfigRequest adConfigRequest, string adMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryManageCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdLibraryManageNameCheckIn(string name, AdLibraryManageCheckInRequest adLibraryManageCheckInRequest, string adMountPath = default(string));
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdLibraryName(string name, AdLibraryRequest adLibraryRequest, string adMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdLibraryNameCheckIn(string name, AdLibraryCheckInRequest adLibraryCheckInRequest, string adMountPath = default(string));
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="adLibraryCheckOutRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdLibraryNameCheckOut(string name, AdLibraryCheckOutRequest adLibraryCheckOutRequest, string adMountPath = default(string));
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adRolesRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdRolesName(string name, AdRolesRequest adRolesRequest, string adMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdRotateRoleName(string name, string adMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAdRotateRoot(string adMountPath = default(string));
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudConfigRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAlicloudConfig(AlicloudConfigRequest alicloudConfigRequest, string alicloudMountPath = default(string));
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAlicloudRoleName(string name, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = default(string));
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigLeaseRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsConfigLease(AwsConfigLeaseRequest awsConfigLeaseRequest, string awsMountPath = default(string));
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsConfigRoot(AwsConfigRootRequest awsConfigRootRequest, string awsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsConfigRotateRoot(string awsMountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsCreds(AwsCredsRequest awsCredsRequest, string awsMountPath = default(string));
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsRolesRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsRolesName(string name, AwsRolesRequest awsRolesRequest, string awsMountPath = default(string));
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAwsStsName(string name, AwsStsRequest awsStsRequest, string awsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAzureConfig(AzureConfigRequest azureConfigRequest, string azureMountPath = default(string));
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRolesRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAzureRolesName(string name, AzureRolesRequest azureRolesRequest, string azureMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostAzureRotateRoot(string azureMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigAccessRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostConsulConfigAccess(ConsulConfigAccessRequest consulConfigAccessRequest, string consulMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostConsulRolesName(string name, ConsulRolesRequest consulRolesRequest, string consulMountPath = default(string));
        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostCubbyholePath(string path, string cubbyholeMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpConfig(GcpConfigRequest gcpConfigRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpConfigRotateRoot(string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpKeyRoleset(string roleset, GcpKeyRequest gcpKeyRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpRolesetName(string name, GcpRolesetRequest gcpRolesetRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpRolesetNameRotate(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpRolesetNameRotateKey(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpRolesetRolesetKey(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpRolesetRolesetToken(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpStaticAccountName(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpStaticAccountNameKey(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpStaticAccountNameRotateKey(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpStaticAccountNameToken(string name, string gcpMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpTokenRoleset(string roleset, string gcpMountPath = default(string));
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsConfig(GcpkmsConfigRequest gcpkmsConfigRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsDecryptKey(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsEncryptKey(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysConfigKey(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysDeregisterKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysKey(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysRegisterKey(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysRotateKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsKeysTrimKey(string key, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsReencryptKey(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsSignKey(string key, GcpkmsSignRequest gcpkmsSignRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostGcpkmsVerifyKey(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string gcpkmsMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesCredsRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostKubernetesCredsName(string name, KubernetesCredsRequest kubernetesCredsRequest, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesRolesRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostKubernetesRolesName(string name, KubernetesRolesRequest kubernetesRolesRequest, string kubernetesMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapConfig(LdapConfigRequest ldapConfigRequest, string ldapMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapLibraryManageNameCheckIn(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string ldapMountPath = default(string));
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapLibraryName(string name, LdapLibraryRequest ldapLibraryRequest, string ldapMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapLibraryNameCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = default(string));
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapLibraryNameCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapRoleName(string name, LdapRoleRequest ldapRoleRequest, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapRotateRoleName(string name, string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapRotateRoot(string ldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostLdapStaticRoleName(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string ldapMountPath = default(string));
        /// <summary>
        /// Configure the  credentials that are used to manage Database Users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasConfigRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostMongodbatlasConfig(MongodbatlasConfigRequest mongodbatlasConfigRequest, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostMongodbatlasCredsName(string name, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasRolesRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostMongodbatlasRolesName(string name, MongodbatlasRolesRequest mongodbatlasRolesRequest, string mongodbatlasMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostNomadConfigAccess(NomadConfigAccessRequest nomadConfigAccessRequest, string nomadMountPath = default(string));
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostNomadConfigLease(NomadConfigLeaseRequest nomadConfigLeaseRequest, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadRoleRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostNomadRoleName(string name, NomadRoleRequest nomadRoleRequest, string nomadMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapConfigRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapConfig(OpenldapConfigRequest openldapConfigRequest, string openldapMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryManageCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapLibraryManageNameCheckIn(string name, OpenldapLibraryManageCheckInRequest openldapLibraryManageCheckInRequest, string openldapMountPath = default(string));
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapLibraryName(string name, OpenldapLibraryRequest openldapLibraryRequest, string openldapMountPath = default(string));
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapLibraryNameCheckIn(string name, OpenldapLibraryCheckInRequest openldapLibraryCheckInRequest, string openldapMountPath = default(string));
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="openldapLibraryCheckOutRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapLibraryNameCheckOut(string name, OpenldapLibraryCheckOutRequest openldapLibraryCheckOutRequest, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapRoleName(string name, OpenldapRoleRequest openldapRoleRequest, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapRotateRoleName(string name, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapRotateRoot(string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapStaticRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostOpenldapStaticRoleName(string name, OpenldapStaticRoleRequest openldapStaticRoleRequest, string openldapMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiBundle(PkiBundleRequest pkiBundleRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiCert(PkiCertRequest pkiCertRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigAutoTidy(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCaRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigCa(PkiConfigCaRequest pkiConfigCaRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigCrl(PkiConfigCrlRequest pkiConfigCrlRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigIssuers(PkiConfigIssuersRequest pkiConfigIssuersRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigKeys(PkiConfigKeysRequest pkiConfigKeysRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiConfigUrls(PkiConfigUrlsRequest pkiConfigUrlsRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIntermediateCrossSign(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIntermediateGenerateExported(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIntermediateSetSigned(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiInternalExported(PkiInternalExportedRequest pkiInternalExportedRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssueRole(string role, PkiIssueRequest pkiIssueRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefIssueRole(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefRevoke(string issuerRef, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefSignRole(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuerRefDerPem(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuersGenerateIntermediateExported(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiIssuersGenerateRootExported(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiJson(PkiJsonRequest pkiJsonRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiKeyKeyRef(string keyRef, PkiKeyRequest pkiKeyRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiKeysImport(PkiKeysImportRequest pkiKeysImportRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiKms(PkiKmsRequest pkiKmsRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiOcsp(string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRevoke(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiRolesRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRolesName(string name, PkiRolesRequest pkiRolesRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRootGenerateExported(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRootReplace(PkiRootReplaceRequest pkiRootReplaceRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRootRotateExported(string exported, PkiRootRotateRequest pkiRootRotateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiSignRole(string role, PkiSignRequest pkiSignRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiSignVerbatimRole(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiTidy(PkiTidyRequest pkiTidyRequest, string pkiMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostPkiTidyCancel(string pkiMountPath = default(string));
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostRabbitmqConfigConnection(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Configure the lease parameters for generated credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostRabbitmqConfigLease(RabbitmqConfigLeaseRequest rabbitmqConfigLeaseRequest, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqRolesRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostRabbitmqRolesName(string name, RabbitmqRolesRequest rabbitmqRolesRequest, string rabbitmqMountPath = default(string));
        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvConfigRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretConfig(KvConfigRequest kvConfigRequest, string secretMountPath = default(string));
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretDataPath(string path, KvDataRequest kvDataRequest, string secretMountPath = default(string));
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretDeletePath(string path, KvDeleteRequest kvDeleteRequest, string secretMountPath = default(string));
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretDestroyPath(string path, KvDestroyRequest kvDestroyRequest, string secretMountPath = default(string));
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretMetadataPath(string path, KvMetadataRequest kvMetadataRequest, string secretMountPath = default(string));
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretPath(string path, string secretMountPath = default(string));
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSecretUndeletePath(string path, KvUndeleteRequest kvUndeleteRequest, string secretMountPath = default(string));
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshConfigCa(SshConfigCaRequest sshConfigCaRequest, string sshMountPath = default(string));
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshConfigZeroaddress(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string sshMountPath = default(string));
        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshCredsRole(string role, SshCredsRequest sshCredsRequest, string sshMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshIssueRole(string role, SshIssueRequest sshIssueRequest, string sshMountPath = default(string));
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshKeysKeyName(string keyName, SshKeysRequest sshKeysRequest, string sshMountPath = default(string));
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshLookup(SshLookupRequest sshLookupRequest, string sshMountPath = default(string));
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshRolesRole(string role, SshRolesRequest sshRolesRequest, string sshMountPath = default(string));
        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshSignRole(string role, SshSignRequest sshSignRequest, string sshMountPath = default(string));
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostSshVerify(SshVerifyRequest sshVerifyRequest, string sshMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformConfigRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTerraformConfig(TerraformConfigRequest terraformConfigRequest, string terraformMountPath = default(string));
        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTerraformCredsName(string name, string terraformMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformRoleRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTerraformRoleName(string name, TerraformRoleRequest terraformRoleRequest, string terraformMountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTerraformRotateRoleName(string name, string terraformMountPath = default(string));
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTotpCodeName(string name, TotpCodeRequest totpCodeRequest, string totpMountPath = default(string));
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTotpKeysName(string name, TotpKeysRequest totpKeysRequest, string totpMountPath = default(string));
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitCacheConfig(TransitCacheConfigRequest transitCacheConfigRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitDatakeyPlaintextName(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string transitMountPath = default(string));
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitDecryptName(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = default(string));
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitEncryptName(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitHash(TransitHashRequest transitHashRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitHashUrlalgorithm(string urlalgorithm, TransitHashRequest transitHashRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitHmacName(string name, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitHmacNameUrlalgorithm(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string));
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysName(string name, TransitKeysRequest transitKeysRequest, string transitMountPath = default(string));
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysNameConfig(string name, TransitKeysConfigRequest transitKeysConfigRequest, string transitMountPath = default(string));
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysNameImport(string name, TransitKeysImportRequest transitKeysImportRequest, string transitMountPath = default(string));
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysNameImportVersion(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string transitMountPath = default(string));
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysNameRotate(string name, string transitMountPath = default(string));
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitKeysNameTrim(string name, TransitKeysTrimRequest transitKeysTrimRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRandom(TransitRandomRequest transitRandomRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRandomSource(string source, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRandomSourceUrlbytes(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRandomUrlbytes(string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string));
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRestore(TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string));
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRestoreName(string name, TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string));
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitRewrapName(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitSignName(string name, TransitSignRequest transitSignRequest, string transitMountPath = default(string));
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitSignNameUrlalgorithm(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string transitMountPath = default(string));
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitVerifyName(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string));
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> PostTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAdConfigAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAdLibraryNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAdRolesNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAlicloudConfigAsync(string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAlicloudRoleNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsRolesNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAzureConfigAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAzureRolesNameAsync(string name, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteConsulRolesNameAsync(string name, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpRolesetNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsConfigAsync(string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteKubernetesConfigAsync(string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteKubernetesRolesNameAsync(string name, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapConfigAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapLibraryNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteMongodbatlasRolesNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteNomadConfigAccessAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteNomadConfigLeaseAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteNomadRoleNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteOpenldapConfigAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteOpenldapLibraryNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteOpenldapRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteOpenldapStaticRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiJsonAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiRolesNameAsync(string name, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeletePkiRootAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteRabbitmqRolesNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretDataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretMetadataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSecretPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshConfigCaAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshConfigZeroaddressAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSshRolesRoleAsync(string role, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTerraformConfigAsync(string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTerraformRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTotpKeysNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTransitKeysNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdConfigAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdCredsNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdLibraryAsync(string list, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdLibraryNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdLibraryNameStatusAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the name of each role currently stored.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdRolesAsync(string list, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdRolesNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAdRotateRootAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAlicloudConfigAsync(string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an API key or STS credential using the given role&#39;s configuration.&#39;
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAlicloudCredsNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the existing roles in this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAlicloudRoleAsync(string list, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAlicloudRoleNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsConfigLeaseAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsConfigRootAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsCredsAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsRolesAsync(string list, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsRolesNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAwsStsNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAzureConfigAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAzureCredsRoleAsync(string role, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List existing roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAzureRolesAsync(string list, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAzureRolesNameAsync(string name, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetConsulConfigAccessAsync(string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetConsulCredsRoleAsync(string role, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetConsulRolesAsync(string list, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetConsulRolesNameAsync(string name, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpConfigAsync(string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpKeyRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpRolesetNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpRolesetRolesetKeyAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpRolesetRolesetTokenAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpRolesetsAsync(string list, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpStaticAccountNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpStaticAccountNameKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpStaticAccountNameTokenAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpStaticAccountsAsync(string list, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpTokenRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpkmsConfigAsync(string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List named keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpkmsKeysAsync(string list, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpkmsKeysConfigKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpkmsKeysKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetGcpkmsPubkeyKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetKubernetesConfigAsync(string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetKubernetesRolesAsync(string list, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetKubernetesRolesNameAsync(string name, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapConfigAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapCredsNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapLibraryAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapLibraryNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapLibraryNameStatusAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapRoleAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapStaticCredNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapStaticRoleAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetLdapStaticRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the  credentials that are used to manage Database Users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetMongodbatlasConfigAsync(string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetMongodbatlasCredsNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetMongodbatlasRolesAsync(string list, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetMongodbatlasRolesNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetNomadConfigAccessAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetNomadConfigLeaseAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetNomadCredsNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetNomadRoleAsync(string list, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetNomadRoleNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapConfigAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapCredsNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapLibraryAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapLibraryNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapLibraryNameStatusAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapRoleAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapStaticCredNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapStaticRoleAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetOpenldapStaticRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCaChainAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCaPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertCaChainAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertSerialAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertSerialRawAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertSerialRawPemAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertsAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCertsRevokedAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiConfigAutoTidyAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiConfigCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiConfigIssuersAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiConfigKeysAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiConfigUrlsAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCrlRotateAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiCrlRotateDeltaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiDeltaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiDeltaCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiDeltaPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiDerAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiIssuerRefDerPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiIssuersAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiJsonAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiKeyKeyRefAsync(string keyRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiKeysAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiOcspReqAsync(string req, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiRolesAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiRolesNameAsync(string name, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetPkiTidyStatusAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetRabbitmqConfigLeaseAsync(string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request RabbitMQ credentials for a certain role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetRabbitmqCredsNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetRabbitmqRolesAsync(string list, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetRabbitmqRolesNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the backend level settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSecretConfigAsync(string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSecretDataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSecretMetadataPathAsync(string path, string secretMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSecretPathAsync(string path, string secretMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSecretSubkeysPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSshConfigCaAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSshConfigZeroaddressAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSshPublicKeyAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSshRolesAsync(string list, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetSshRolesRoleAsync(string role, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTerraformConfigAsync(string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTerraformCredsNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTerraformRoleAsync(string list, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTerraformRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTotpCodeNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTotpKeysAsync(string list, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTotpKeysNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitBackupNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitCacheConfigAsync(string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitExportTypeNameAsync(string name, string type, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitExportTypeNameVersionAsync(string name, string type, string version, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitKeysAsync(string list, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitKeysNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetTransitWrappingKeyAsync(string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the AD server to connect to, along with password options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adConfigRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdConfigAsync(AdConfigRequest adConfigRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryManageCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdLibraryManageNameCheckInAsync(string name, AdLibraryManageCheckInRequest adLibraryManageCheckInRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdLibraryNameAsync(string name, AdLibraryRequest adLibraryRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdLibraryNameCheckInAsync(string name, AdLibraryCheckInRequest adLibraryCheckInRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="adLibraryCheckOutRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdLibraryNameCheckOutAsync(string name, AdLibraryCheckOutRequest adLibraryCheckOutRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adRolesRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdRolesNameAsync(string name, AdRolesRequest adRolesRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdRotateRoleNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAdRotateRootAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudConfigRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAlicloudConfigAsync(AlicloudConfigRequest alicloudConfigRequest, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAlicloudRoleNameAsync(string name, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the default lease information for generated credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigLeaseRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsConfigLeaseAsync(AwsConfigLeaseRequest awsConfigLeaseRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the root credentials that are used to manage IAM.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsConfigRootAsync(AwsConfigRootRequest awsConfigRootRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsConfigRotateRootAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsCredsAsync(AwsCredsRequest awsCredsRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsRolesRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsRolesNameAsync(string name, AwsRolesRequest awsRolesRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate AWS credentials from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAwsStsNameAsync(string name, AwsStsRequest awsStsRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAzureConfigAsync(AzureConfigRequest azureConfigRequest, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRolesRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAzureRolesNameAsync(string name, AzureRolesRequest azureRolesRequest, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAzureRotateRootAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigAccessRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostConsulConfigAccessAsync(ConsulConfigAccessRequest consulConfigAccessRequest, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostConsulRolesNameAsync(string name, ConsulRolesRequest consulRolesRequest, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpConfigAsync(GcpConfigRequest gcpConfigRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpConfigRotateRootAsync(string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpKeyRolesetAsync(string roleset, GcpKeyRequest gcpKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpRolesetNameAsync(string name, GcpRolesetRequest gcpRolesetRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpRolesetNameRotateAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpRolesetNameRotateKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpRolesetRolesetKeyAsync(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpRolesetRolesetTokenAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpStaticAccountNameAsync(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpStaticAccountNameKeyAsync(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpStaticAccountNameRotateKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpStaticAccountNameTokenAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpTokenRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the GCP KMS secrets engine
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsConfigAsync(GcpkmsConfigRequest gcpkmsConfigRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsDecryptKeyAsync(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsEncryptKeyAsync(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysConfigKeyAsync(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deregister an existing key in Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysDeregisterKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysKeyAsync(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysRegisterKeyAsync(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysRotateKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsKeysTrimKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsReencryptKeyAsync(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsSignKeyAsync(string key, GcpkmsSignRequest gcpkmsSignRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostGcpkmsVerifyKeyAsync(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesCredsRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostKubernetesCredsNameAsync(string name, KubernetesCredsRequest kubernetesCredsRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesRolesRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostKubernetesRolesNameAsync(string name, KubernetesRolesRequest kubernetesRolesRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapLibraryManageNameCheckInAsync(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapLibraryNameAsync(string name, LdapLibraryRequest ldapLibraryRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapLibraryNameCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapLibraryNameCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapRoleNameAsync(string name, LdapRoleRequest ldapRoleRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapRotateRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapRotateRootAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostLdapStaticRoleNameAsync(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the  credentials that are used to manage Database Users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasConfigRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostMongodbatlasConfigAsync(MongodbatlasConfigRequest mongodbatlasConfigRequest, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostMongodbatlasCredsNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasRolesRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostMongodbatlasRolesNameAsync(string name, MongodbatlasRolesRequest mongodbatlasRolesRequest, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostNomadConfigAccessAsync(NomadConfigAccessRequest nomadConfigAccessRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated tokens
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostNomadConfigLeaseAsync(NomadConfigLeaseRequest nomadConfigLeaseRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadRoleRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostNomadRoleNameAsync(string name, NomadRoleRequest nomadRoleRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapConfigRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapConfigAsync(OpenldapConfigRequest openldapConfigRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryManageCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapLibraryManageNameCheckInAsync(string name, OpenldapLibraryManageCheckInRequest openldapLibraryManageCheckInRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapLibraryNameAsync(string name, OpenldapLibraryRequest openldapLibraryRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapLibraryNameCheckInAsync(string name, OpenldapLibraryCheckInRequest openldapLibraryCheckInRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="openldapLibraryCheckOutRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapLibraryNameCheckOutAsync(string name, OpenldapLibraryCheckOutRequest openldapLibraryCheckOutRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapRoleNameAsync(string name, OpenldapRoleRequest openldapRoleRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapRotateRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapRotateRootAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapStaticRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostOpenldapStaticRoleNameAsync(string name, OpenldapStaticRoleRequest openldapStaticRoleRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiBundleAsync(PkiBundleRequest pkiBundleRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiCertAsync(PkiCertRequest pkiCertRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigAutoTidyAsync(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCaRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigCaAsync(PkiConfigCaRequest pkiConfigCaRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigCrlAsync(PkiConfigCrlRequest pkiConfigCrlRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigIssuersAsync(PkiConfigIssuersRequest pkiConfigIssuersRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigKeysAsync(PkiConfigKeysRequest pkiConfigKeysRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiConfigUrlsAsync(PkiConfigUrlsRequest pkiConfigUrlsRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIntermediateCrossSignAsync(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIntermediateGenerateExportedAsync(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIntermediateSetSignedAsync(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiInternalExportedAsync(PkiInternalExportedRequest pkiInternalExportedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssueRoleAsync(string role, PkiIssueRequest pkiIssueRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefRevokeAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuerRefDerPemAsync(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuersGenerateIntermediateExportedAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiIssuersGenerateRootExportedAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiJsonAsync(PkiJsonRequest pkiJsonRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiKeyKeyRefAsync(string keyRef, PkiKeyRequest pkiKeyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiKeysImportAsync(PkiKeysImportRequest pkiKeysImportRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiKmsAsync(PkiKmsRequest pkiKmsRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiOcspAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiRolesRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRolesNameAsync(string name, PkiRolesRequest pkiRolesRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRootGenerateExportedAsync(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRootReplaceAsync(PkiRootReplaceRequest pkiRootReplaceRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRootRotateExportedAsync(string exported, PkiRootRotateRequest pkiRootRotateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiSignRoleAsync(string role, PkiSignRequest pkiSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiSignVerbatimRoleAsync(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiTidyAsync(PkiTidyRequest pkiTidyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostPkiTidyCancelAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostRabbitmqConfigConnectionAsync(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the lease parameters for generated credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostRabbitmqConfigLeaseAsync(RabbitmqConfigLeaseRequest rabbitmqConfigLeaseRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqRolesRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostRabbitmqRolesNameAsync(string name, RabbitmqRolesRequest rabbitmqRolesRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvConfigRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretConfigAsync(KvConfigRequest kvConfigRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretDataPathAsync(string path, KvDataRequest kvDataRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Marks one or more versions as deleted in the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretDeletePathAsync(string path, KvDeleteRequest kvDeleteRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Permanently removes one or more versions in the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretDestroyPathAsync(string path, KvDestroyRequest kvDestroyRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures settings for the KV store
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretMetadataPathAsync(string path, KvMetadataRequest kvMetadataRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Undeletes one or more versions from the KV store.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSecretUndeletePathAsync(string path, KvUndeleteRequest kvUndeleteRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Set the SSH private key used for signing certificates.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshConfigCaAsync(SshConfigCaRequest sshConfigCaRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign zero address as default CIDR block for select roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshConfigZeroaddressAsync(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshCredsRoleAsync(string role, SshCredsRequest sshCredsRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshIssueRoleAsync(string role, SshIssueRequest sshIssueRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a shared private key with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshKeysKeyNameAsync(string keyName, SshKeysRequest sshKeysRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshLookupAsync(SshLookupRequest sshLookupRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshRolesRoleAsync(string role, SshRolesRequest sshRolesRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshSignRoleAsync(string role, SshSignRequest sshSignRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostSshVerifyAsync(SshVerifyRequest sshVerifyRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformConfigRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTerraformConfigAsync(TerraformConfigRequest terraformConfigRequest, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTerraformCredsNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformRoleRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTerraformRoleNameAsync(string name, TerraformRoleRequest terraformRoleRequest, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTerraformRotateRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key .
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTotpCodeNameAsync(string name, TotpCodeRequest totpCodeRequest, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTotpKeysNameAsync(string name, TotpKeysRequest totpKeysRequest, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitCacheConfigAsync(TransitCacheConfigRequest transitCacheConfigRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitDatakeyPlaintextNameAsync(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitDecryptNameAsync(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitEncryptNameAsync(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitHashAsync(TransitHashRequest transitHashRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitHashUrlalgorithmAsync(string urlalgorithm, TransitHashRequest transitHashRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitHmacNameAsync(string name, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameAsync(string name, TransitKeysRequest transitKeysRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameConfigAsync(string name, TransitKeysConfigRequest transitKeysConfigRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameImportAsync(string name, TransitKeysImportRequest transitKeysImportRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameImportVersionAsync(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameRotateAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitKeysNameTrimAsync(string name, TransitKeysTrimRequest transitKeysTrimRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRandomAsync(TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRandomSourceAsync(string source, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRandomSourceUrlbytesAsync(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRandomUrlbytesAsync(string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRestoreAsync(TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRestoreNameAsync(string name, TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitRewrapNameAsync(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitSignNameAsync(string name, TransitSignRequest transitSignRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitVerifyNameAsync(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecrets : ISecretsSync, ISecretsAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Secrets : ISecrets
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Secrets
        /// </summary>
        public Secrets(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAdConfig(string adMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ad_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAdConfigAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ad_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAdLibraryName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAdLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ad_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAdLibraryNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAdLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ad_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAdRolesName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAdRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ad_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAdRolesNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAdRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ad_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAlicloudConfig(string alicloudMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAlicloudConfigAsync(string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAlicloudRoleName(string name, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAlicloudRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAlicloudRoleNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAlicloudRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsRolesName(string name, string awsMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsRolesNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAzureConfig(string azureMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAzureConfigAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAzureRolesName(string name, string azureMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAzureRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAzureRolesNameAsync(string name, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteAzureRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteConsulRolesName(string name, string consulMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteConsulRolesNameAsync(string name, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteCubbyholePath(string path, string cubbyholeMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{cubbyhole_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{cubbyhole_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpRolesetName(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpRolesetNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpStaticAccountName(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpStaticAccountNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsConfig(string gcpkmsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsConfigAsync(string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysDeregisterKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysDeregisterKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGcpkmsKeysTrimKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGcpkmsKeysTrimKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->DeleteGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteKubernetesConfig(string kubernetesMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteKubernetesConfigAsync(string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteKubernetesRolesName(string name, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteKubernetesRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteKubernetesRolesNameAsync(string name, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteKubernetesRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapConfig(string ldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapConfigAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapLibraryName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapLibraryNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapRoleName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteLdapStaticRoleName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteLdapStaticRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteMongodbatlasRolesName(string name, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteMongodbatlasRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteMongodbatlasRolesNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteMongodbatlasRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteNomadConfigAccess(string nomadMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteNomadConfigAccessAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteNomadConfigLease(string nomadMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteNomadConfigLeaseAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteNomadRoleName(string name, string nomadMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteNomadRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteNomadRoleNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteNomadRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteOpenldapConfig(string openldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{openldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteOpenldapConfigAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{openldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteOpenldapLibraryName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{openldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteOpenldapLibraryNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{openldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteOpenldapRoleName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{openldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteOpenldapRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{openldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteOpenldapStaticRoleName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteOpenldapStaticRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteOpenldapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiIssuerRefDerPem(string issuerRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiIssuerRefDerPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->DeletePkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiJson(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiJsonAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiKeyKeyRef(string keyRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiKeyKeyRefAsync(string keyRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->DeletePkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiRolesName(string name, string pkiMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeletePkiRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiRolesNameAsync(string name, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeletePkiRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeletePkiRoot(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeletePkiRootAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeletePkiRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteRabbitmqRolesName(string name, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteRabbitmqRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteRabbitmqRolesNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteRabbitmqRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretDataPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{secret_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretDataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{secret_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretMetadataPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{secret_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretMetadataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{secret_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSecretPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{secret_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSecretPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->DeleteSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{secret_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshConfigCa(string sshMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshConfigCaAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshConfigZeroaddress(string sshMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshConfigZeroaddressAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshKeysKeyName(string keyName, string sshMountPath = default(string))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshKeysKeyNameAsync(string keyName, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->DeleteSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSshRolesRole(string role, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSshRolesRoleAsync(string role, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->DeleteSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTerraformConfig(string terraformMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTerraformConfigAsync(string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTerraformRoleName(string name, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTerraformRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTerraformRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTerraformRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTotpKeysName(string name, string totpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTotpKeysNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTransitKeysName(string name, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTransitKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTransitKeysNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DeleteTransitKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdConfig(string adMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdConfigAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdCredsName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdCredsNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdLibrary(string list, string adMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAdLibrary");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdLibraryAsync(string list, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAdLibrary");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdLibraryName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdLibraryNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdLibraryNameStatus(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdLibraryNameStatus");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdLibraryNameStatusAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdLibraryNameStatus");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the name of each role currently stored. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdRoles(string list, string adMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAdRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the name of each role currently stored. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdRolesAsync(string list, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAdRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdRolesName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdRolesNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAdRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAdRotateRoot(string adMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ad_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAdRotateRootAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ad_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAdRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAlicloudConfig(string alicloudMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAlicloudConfigAsync(string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an API key or STS credential using the given role&#39;s configuration.&#39; 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAlicloudCredsName(string name, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAlicloudCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an API key or STS credential using the given role&#39;s configuration.&#39; 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAlicloudCredsNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAlicloudCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAlicloudRole(string list, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAlicloudRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAlicloudRoleAsync(string list, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAlicloudRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAlicloudRoleName(string name, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAlicloudRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAlicloudRoleNameAsync(string name, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAlicloudRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsConfigLease(string awsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsConfigLeaseAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsConfigRoot(string awsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsConfigRootAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsCreds(string awsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsCredsAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsRoles(string list, string awsMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAwsRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsRolesAsync(string list, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAwsRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsRolesName(string name, string awsMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsRolesNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAwsStsName(string name, string awsMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAwsStsNameAsync(string name, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAzureConfig(string azureMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAzureConfigAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAzureCredsRole(string role, string azureMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetAzureCredsRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAzureCredsRoleAsync(string role, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetAzureCredsRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List existing roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAzureRoles(string list, string azureMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAzureRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List existing roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAzureRolesAsync(string list, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetAzureRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetAzureRolesName(string name, string azureMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAzureRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAzureRolesNameAsync(string name, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetAzureRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetConsulConfigAccess(string consulMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetConsulConfigAccessAsync(string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetConsulCredsRole(string role, string consulMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetConsulCredsRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetConsulCredsRoleAsync(string role, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetConsulCredsRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetConsulRoles(string list, string consulMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetConsulRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetConsulRolesAsync(string list, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetConsulRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetConsulRolesName(string name, string consulMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetConsulRolesNameAsync(string name, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetCubbyholePath(string path, string cubbyholeMountPath = default(string), string list = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{cubbyhole_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{cubbyhole_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpConfig(string gcpMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpConfigAsync(string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpKeyRoleset(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpKeyRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpRolesetName(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpRolesetNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpRolesetRolesetKey(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpRolesetRolesetKeyAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpRolesetRolesetToken(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpRolesetRolesetTokenAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpRolesets(string list, string gcpMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpRolesets");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/rolesets", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpRolesetsAsync(string list, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpRolesets");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/rolesets", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpStaticAccountName(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpStaticAccountNameAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpStaticAccountNameKey(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpStaticAccountNameKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpStaticAccountNameToken(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpStaticAccountNameTokenAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpStaticAccounts(string list, string gcpMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpStaticAccounts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpStaticAccountsAsync(string list, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpStaticAccounts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpTokenRoleset(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpTokenRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GetGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpkmsConfig(string gcpkmsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpkmsConfigAsync(string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List named keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpkmsKeys(string list, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpkmsKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List named keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpkmsKeysAsync(string list, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetGcpkmsKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpkmsKeysConfigKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpkmsKeysConfigKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpkmsKeysKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpkmsKeysKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetGcpkmsPubkeyKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsPubkeyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/pubkey/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsPubkeyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetGcpkmsPubkeyKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GetGcpkmsPubkeyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/pubkey/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetGcpkmsPubkeyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetKubernetesConfig(string kubernetesMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetKubernetesConfigAsync(string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetKubernetesRoles(string list, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetKubernetesRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetKubernetesRolesAsync(string list, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetKubernetesRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetKubernetesRolesName(string name, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetKubernetesRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetKubernetesRolesNameAsync(string name, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetKubernetesRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapConfig(string ldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapConfigAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapCredsName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapCredsNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapLibrary(string list, string ldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapLibrary");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapLibraryAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapLibrary");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapLibraryName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapLibraryNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapLibraryNameStatus(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapLibraryNameStatus");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapLibraryNameStatusAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapLibraryNameStatus");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapRole(string list, string ldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapRoleAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapRoleName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapStaticCredName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapStaticCredName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-cred/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapStaticCredNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapStaticCredName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-cred/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapStaticRole(string list, string ldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapStaticRoleAsync(string list, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetLdapStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetLdapStaticRoleName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetLdapStaticRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the  credentials that are used to manage Database Users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetMongodbatlasConfig(string mongodbatlasMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the  credentials that are used to manage Database Users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetMongodbatlasConfigAsync(string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetMongodbatlasCredsName(string name, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetMongodbatlasCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetMongodbatlasCredsNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetMongodbatlasCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetMongodbatlasRoles(string list, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetMongodbatlasRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetMongodbatlasRolesAsync(string list, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetMongodbatlasRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetMongodbatlasRolesName(string name, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetMongodbatlasRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetMongodbatlasRolesNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetMongodbatlasRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetNomadConfigAccess(string nomadMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetNomadConfigAccessAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetNomadConfigLease(string nomadMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetNomadConfigLeaseAsync(string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetNomadCredsName(string name, string nomadMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetNomadCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetNomadCredsNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetNomadCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetNomadRole(string list, string nomadMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetNomadRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetNomadRoleAsync(string list, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetNomadRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetNomadRoleName(string name, string nomadMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetNomadRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetNomadRoleNameAsync(string name, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetNomadRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapConfig(string openldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapConfigAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapCredsName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapCredsNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapLibrary(string list, string openldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapLibrary");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapLibraryAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapLibrary");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibrary", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapLibraryName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapLibraryNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapLibraryNameStatus(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapLibraryNameStatus");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapLibraryNameStatusAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapLibraryNameStatus");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapLibraryNameStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapRole(string list, string openldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapRoleAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapRoleName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapStaticCredName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapStaticCredName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/static-cred/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapStaticCredNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapStaticCredName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/static-cred/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticCredName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapStaticRole(string list, string openldapMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/static-role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapStaticRoleAsync(string list, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetOpenldapStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/static-role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetOpenldapStaticRoleName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetOpenldapStaticRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetOpenldapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCa(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCaChain(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCaChainAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCaPem(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/ca/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCaPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/ca/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCertCaChain(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/cert/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertCaChainAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/cert/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCertSerial(string serial, string pkiMountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerial");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/cert/{serial}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerial", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertSerialAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerial");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/cert/{serial}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerial", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCertSerialRaw(string serial, string pkiMountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerialRaw");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/cert/{serial}/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerialRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertSerialRawAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerialRaw");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/cert/{serial}/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerialRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCertSerialRawPem(string serial, string pkiMountPath = default(string))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerialRawPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/cert/{serial}/raw/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerialRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertSerialRawPemAsync(string serial, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->GetPkiCertSerialRawPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/cert/{serial}/raw/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertSerialRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCerts(string list, string pkiMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiCerts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertsAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiCerts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCertsRevoked(string list, string pkiMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiCertsRevoked");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/certs/revoked", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertsRevoked", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCertsRevokedAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiCertsRevoked");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/certs/revoked", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCertsRevoked", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiConfigAutoTidy(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiConfigAutoTidyAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiConfigCrl(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiConfigCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiConfigIssuers(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiConfigIssuersAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiConfigKeys(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiConfigKeysAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiConfigUrls(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiConfigUrlsAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCrl(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCrlRotate(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/crl/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrlRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCrlRotateAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/crl/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrlRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiCrlRotateDelta(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/crl/rotate-delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrlRotateDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiCrlRotateDeltaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/crl/rotate-delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiCrlRotateDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiDelta(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}//delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiDeltaAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}//delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiDeltaCrl(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/delta-crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiDeltaCrlAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/delta-crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiDeltaPem(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}//delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiDeltaPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}//delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiDer(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}//der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiDerAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}//der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiIssuerRefCrlPemDerDeltaPem(string issuerRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->GetPkiIssuerRefCrlPemDerDeltaPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuerRefCrlPemDerDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiIssuerRefCrlPemDerDeltaPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->GetPkiIssuerRefCrlPemDerDeltaPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuerRefCrlPemDerDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiIssuerRefDerPem(string issuerRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->GetPkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiIssuerRefDerPemAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->GetPkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiIssuers(string list, string pkiMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiIssuers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiIssuersAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiIssuers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiJson(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiJsonAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiKeyKeyRef(string keyRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->GetPkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiKeyKeyRefAsync(string keyRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->GetPkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiKeys(string list, string pkiMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiKeysAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiOcspReq(string req, string pkiMountPath = default(string))
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->GetPkiOcspReq");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/ocsp/{req}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiOcspReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiOcspReqAsync(string req, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->GetPkiOcspReq");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/ocsp/{req}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiOcspReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiPem(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}//pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiPemAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}//pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiRoles(string list, string pkiMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiRolesAsync(string list, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetPkiRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiRolesName(string name, string pkiMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetPkiRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiRolesNameAsync(string name, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetPkiRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetPkiTidyStatus(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/tidy-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetPkiTidyStatusAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/tidy-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetPkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetRabbitmqConfigLease(string rabbitmqMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetRabbitmqConfigLeaseAsync(string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request RabbitMQ credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetRabbitmqCredsName(string name, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetRabbitmqCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request RabbitMQ credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetRabbitmqCredsNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetRabbitmqCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetRabbitmqRoles(string list, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetRabbitmqRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetRabbitmqRolesAsync(string list, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetRabbitmqRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetRabbitmqRolesName(string name, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetRabbitmqRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetRabbitmqRolesNameAsync(string name, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetRabbitmqRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the backend level settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSecretConfig(string secretMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{secret_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the backend level settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSecretConfigAsync(string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{secret_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSecretDataPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{secret_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSecretDataPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{secret_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSecretMetadataPath(string path, string secretMountPath = default(string), string list = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{secret_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSecretMetadataPathAsync(string path, string secretMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{secret_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSecretPath(string path, string secretMountPath = default(string), string list = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{secret_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSecretPathAsync(string path, string secretMountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{secret_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSecretSubkeysPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretSubkeysPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{secret_mount_path}/subkeys/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretSubkeysPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the structure of a secret entry from the Key-Value store with the values removed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSecretSubkeysPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->GetSecretSubkeysPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{secret_mount_path}/subkeys/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSecretSubkeysPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSshConfigCa(string sshMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSshConfigCaAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSshConfigZeroaddress(string sshMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSshConfigZeroaddressAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSshPublicKey(string sshMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/public_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSshPublicKeyAsync(string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/public_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSshRoles(string list, string sshMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetSshRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSshRolesAsync(string list, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetSshRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetSshRolesRole(string role, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetSshRolesRoleAsync(string role, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->GetSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTerraformConfig(string terraformMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTerraformConfigAsync(string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTerraformCredsName(string name, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTerraformCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTerraformCredsNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTerraformCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTerraformRole(string list, string terraformMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTerraformRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTerraformRoleAsync(string list, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTerraformRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTerraformRoleName(string name, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTerraformRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTerraformRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTerraformRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTotpCodeName(string name, string totpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTotpCodeNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTotpKeys(string list, string totpMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTotpKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTotpKeysAsync(string list, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTotpKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTotpKeysName(string name, string totpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTotpKeysNameAsync(string name, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitBackupName(string name, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitBackupName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/backup/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitBackupName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitBackupNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitBackupName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/backup/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitBackupName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitCacheConfig(string transitMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitCacheConfigAsync(string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitExportTypeName(string name, string type, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->GetTransitExportTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/export/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitExportTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitExportTypeNameAsync(string name, string type, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitExportTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->GetTransitExportTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/export/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitExportTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitExportTypeNameVersion(string name, string type, string version, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->GetTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->GetTransitExportTypeNameVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/export/{type}/{name}/{version}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitExportTypeNameVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitExportTypeNameVersionAsync(string name, string type, string version, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitExportTypeNameVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->GetTransitExportTypeNameVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->GetTransitExportTypeNameVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/export/{type}/{name}/{version}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitExportTypeNameVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitKeys(string list, string transitMountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTransitKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitKeysAsync(string list, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Secrets->GetTransitKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitKeysName(string name, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitKeysNameAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GetTransitKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> GetTransitWrappingKey(string transitMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/wrapping_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetTransitWrappingKeyAsync(string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/wrapping_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetTransitWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adConfigRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdConfig(AdConfigRequest adConfigRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'adConfigRequest' is set
            if (adConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adConfigRequest' when calling Secrets->PostAdConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.Data = adConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the AD server to connect to, along with password options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adConfigRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdConfigAsync(AdConfigRequest adConfigRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'adConfigRequest' is set
            if (adConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adConfigRequest' when calling Secrets->PostAdConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.Data = adConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryManageCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdLibraryManageNameCheckIn(string name, AdLibraryManageCheckInRequest adLibraryManageCheckInRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryManageNameCheckIn");

            // verify the required parameter 'adLibraryManageCheckInRequest' is set
            if (adLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryManageCheckInRequest' when calling Secrets->PostAdLibraryManageNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryManageCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryManageCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdLibraryManageNameCheckInAsync(string name, AdLibraryManageCheckInRequest adLibraryManageCheckInRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryManageNameCheckIn");

            // verify the required parameter 'adLibraryManageCheckInRequest' is set
            if (adLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryManageCheckInRequest' when calling Secrets->PostAdLibraryManageNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryManageCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdLibraryName(string name, AdLibraryRequest adLibraryRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryName");

            // verify the required parameter 'adLibraryRequest' is set
            if (adLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryRequest' when calling Secrets->PostAdLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdLibraryNameAsync(string name, AdLibraryRequest adLibraryRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryName");

            // verify the required parameter 'adLibraryRequest' is set
            if (adLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryRequest' when calling Secrets->PostAdLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdLibraryNameCheckIn(string name, AdLibraryCheckInRequest adLibraryCheckInRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryNameCheckIn");

            // verify the required parameter 'adLibraryCheckInRequest' is set
            if (adLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryCheckInRequest' when calling Secrets->PostAdLibraryNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="adLibraryCheckInRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdLibraryNameCheckInAsync(string name, AdLibraryCheckInRequest adLibraryCheckInRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryNameCheckIn");

            // verify the required parameter 'adLibraryCheckInRequest' is set
            if (adLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryCheckInRequest' when calling Secrets->PostAdLibraryNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="adLibraryCheckOutRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdLibraryNameCheckOut(string name, AdLibraryCheckOutRequest adLibraryCheckOutRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryNameCheckOut");

            // verify the required parameter 'adLibraryCheckOutRequest' is set
            if (adLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryCheckOutRequest' when calling Secrets->PostAdLibraryNameCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryCheckOutRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="adLibraryCheckOutRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdLibraryNameCheckOutAsync(string name, AdLibraryCheckOutRequest adLibraryCheckOutRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdLibraryNameCheckOut");

            // verify the required parameter 'adLibraryCheckOutRequest' is set
            if (adLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adLibraryCheckOutRequest' when calling Secrets->PostAdLibraryNameCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adLibraryCheckOutRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adRolesRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdRolesName(string name, AdRolesRequest adRolesRequest, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdRolesName");

            // verify the required parameter 'adRolesRequest' is set
            if (adRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adRolesRequest' when calling Secrets->PostAdRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage roles to build links between Vault and Active Directory service accounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="adRolesRequest"></param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdRolesNameAsync(string name, AdRolesRequest adRolesRequest, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdRolesName");

            // verify the required parameter 'adRolesRequest' is set
            if (adRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'adRolesRequest' when calling Secrets->PostAdRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = adRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdRotateRoleName(string name, string adMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdRotateRoleNameAsync(string name, string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAdRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAdRotateRoot(string adMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ad_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="adMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAdRotateRootAsync(string adMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (adMountPath != null)
            {
                requestOptions.PathParameters.Add("ad_mount_path", ClientUtils.ParameterToString(adMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ad_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAdRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudConfigRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAlicloudConfig(AlicloudConfigRequest alicloudConfigRequest, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'alicloudConfigRequest' is set
            if (alicloudConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudConfigRequest' when calling Secrets->PostAlicloudConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.Data = alicloudConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the access key and secret to use for RAM and STS calls. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudConfigRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAlicloudConfigAsync(AlicloudConfigRequest alicloudConfigRequest, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'alicloudConfigRequest' is set
            if (alicloudConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudConfigRequest' when calling Secrets->PostAlicloudConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.Data = alicloudConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAlicloudConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAlicloudRoleName(string name, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAlicloudRoleName");

            // verify the required parameter 'alicloudRoleRequest' is set
            if (alicloudRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudRoleRequest' when calling Secrets->PostAlicloudRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = alicloudRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAlicloudRoleNameAsync(string name, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAlicloudRoleName");

            // verify the required parameter 'alicloudRoleRequest' is set
            if (alicloudRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudRoleRequest' when calling Secrets->PostAlicloudRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = alicloudRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAlicloudRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigLeaseRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsConfigLease(AwsConfigLeaseRequest awsConfigLeaseRequest, string awsMountPath = default(string))
        {
            // verify the required parameter 'awsConfigLeaseRequest' is set
            if (awsConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigLeaseRequest' when calling Secrets->PostAwsConfigLease");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the default lease information for generated credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigLeaseRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsConfigLeaseAsync(AwsConfigLeaseRequest awsConfigLeaseRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigLeaseRequest' is set
            if (awsConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigLeaseRequest' when calling Secrets->PostAwsConfigLease");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsConfigRoot(AwsConfigRootRequest awsConfigRootRequest, string awsMountPath = default(string))
        {
            // verify the required parameter 'awsConfigRootRequest' is set
            if (awsConfigRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigRootRequest' when calling Secrets->PostAwsConfigRoot");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the root credentials that are used to manage IAM. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigRootRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsConfigRootAsync(AwsConfigRootRequest awsConfigRootRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigRootRequest' is set
            if (awsConfigRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigRootRequest' when calling Secrets->PostAwsConfigRoot");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsConfigRotateRoot(string awsMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsConfigRotateRootAsync(string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsCreds(AwsCredsRequest awsCredsRequest, string awsMountPath = default(string))
        {
            // verify the required parameter 'awsCredsRequest' is set
            if (awsCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsCredsRequest' when calling Secrets->PostAwsCreds");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/creds", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsCredsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsCredsAsync(AwsCredsRequest awsCredsRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsCredsRequest' is set
            if (awsCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsCredsRequest' when calling Secrets->PostAwsCreds");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/creds", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsCreds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsRolesRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsRolesName(string name, AwsRolesRequest awsRolesRequest, string awsMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAwsRolesName");

            // verify the required parameter 'awsRolesRequest' is set
            if (awsRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRolesRequest' when calling Secrets->PostAwsRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the policy</param>
        /// <param name="awsRolesRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsRolesNameAsync(string name, AwsRolesRequest awsRolesRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAwsRolesName");

            // verify the required parameter 'awsRolesRequest' is set
            if (awsRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRolesRequest' when calling Secrets->PostAwsRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAwsStsName(string name, AwsStsRequest awsStsRequest, string awsMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAwsStsName");

            // verify the required parameter 'awsStsRequest' is set
            if (awsStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsStsRequest' when calling Secrets->PostAwsStsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate AWS credentials from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAwsStsNameAsync(string name, AwsStsRequest awsStsRequest, string awsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAwsStsName");

            // verify the required parameter 'awsStsRequest' is set
            if (awsStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsStsRequest' when calling Secrets->PostAwsStsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = awsStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAwsStsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAzureConfig(AzureConfigRequest azureConfigRequest, string azureMountPath = default(string))
        {
            // verify the required parameter 'azureConfigRequest' is set
            if (azureConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigRequest' when calling Secrets->PostAzureConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAzureConfigAsync(AzureConfigRequest azureConfigRequest, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'azureConfigRequest' is set
            if (azureConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigRequest' when calling Secrets->PostAzureConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRolesRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAzureRolesName(string name, AzureRolesRequest azureRolesRequest, string azureMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAzureRolesName");

            // verify the required parameter 'azureRolesRequest' is set
            if (azureRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureRolesRequest' when calling Secrets->PostAzureRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = azureRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRolesRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAzureRolesNameAsync(string name, AzureRolesRequest azureRolesRequest, string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostAzureRolesName");

            // verify the required parameter 'azureRolesRequest' is set
            if (azureRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureRolesRequest' when calling Secrets->PostAzureRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = azureRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostAzureRotateRoot(string azureMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAzureRotateRootAsync(string azureMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAzureRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigAccessRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostConsulConfigAccess(ConsulConfigAccessRequest consulConfigAccessRequest, string consulMountPath = default(string))
        {
            // verify the required parameter 'consulConfigAccessRequest' is set
            if (consulConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulConfigAccessRequest' when calling Secrets->PostConsulConfigAccess");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.Data = consulConfigAccessRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{consul_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostConsulConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigAccessRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostConsulConfigAccessAsync(ConsulConfigAccessRequest consulConfigAccessRequest, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'consulConfigAccessRequest' is set
            if (consulConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulConfigAccessRequest' when calling Secrets->PostConsulConfigAccess");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.Data = consulConfigAccessRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{consul_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostConsulConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostConsulRolesName(string name, ConsulRolesRequest consulRolesRequest, string consulMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostConsulRolesName");

            // verify the required parameter 'consulRolesRequest' is set
            if (consulRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulRolesRequest' when calling Secrets->PostConsulRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = consulRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulRolesRequest"></param>
        /// <param name="consulMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;consul&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostConsulRolesNameAsync(string name, ConsulRolesRequest consulRolesRequest, string consulMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostConsulRolesName");

            // verify the required parameter 'consulRolesRequest' is set
            if (consulRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulRolesRequest' when calling Secrets->PostConsulRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (consulMountPath != null)
            {
                requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = consulRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostConsulRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostCubbyholePath(string path, string cubbyholeMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostCubbyholePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{cubbyhole_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="cubbyholeMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cubbyhole&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostCubbyholePathAsync(string path, string cubbyholeMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostCubbyholePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cubbyholeMountPath != null)
            {
                requestOptions.PathParameters.Add("cubbyhole_mount_path", ClientUtils.ParameterToString(cubbyholeMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{cubbyhole_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostCubbyholePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpConfig(GcpConfigRequest gcpConfigRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'gcpConfigRequest' is set
            if (gcpConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpConfigRequest' when calling Secrets->PostGcpConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpConfigAsync(GcpConfigRequest gcpConfigRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'gcpConfigRequest' is set
            if (gcpConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpConfigRequest' when calling Secrets->PostGcpConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpConfigRotateRoot(string gcpMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpConfigRotateRootAsync(string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpKeyRoleset(string roleset, GcpKeyRequest gcpKeyRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpKeyRoleset");

            // verify the required parameter 'gcpKeyRequest' is set
            if (gcpKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpKeyRequest' when calling Secrets->PostGcpKeyRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/key/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpKeyRolesetAsync(string roleset, GcpKeyRequest gcpKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpKeyRoleset");

            // verify the required parameter 'gcpKeyRequest' is set
            if (gcpKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpKeyRequest' when calling Secrets->PostGcpKeyRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/key/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpKeyRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpRolesetName(string name, GcpRolesetRequest gcpRolesetRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetName");

            // verify the required parameter 'gcpRolesetRequest' is set
            if (gcpRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetRequest' when calling Secrets->PostGcpRolesetName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpRolesetRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpRolesetNameAsync(string name, GcpRolesetRequest gcpRolesetRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetName");

            // verify the required parameter 'gcpRolesetRequest' is set
            if (gcpRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetRequest' when calling Secrets->PostGcpRolesetName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRolesetRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpRolesetNameRotate(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpRolesetNameRotateAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpRolesetNameRotateKey(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpRolesetNameRotateKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpRolesetNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpRolesetRolesetKey(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpRolesetRolesetKey");

            // verify the required parameter 'gcpRolesetKeyRequest' is set
            if (gcpRolesetKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetKeyRequest' when calling Secrets->PostGcpRolesetRolesetKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpRolesetKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpRolesetRolesetKeyAsync(string roleset, GcpRolesetKeyRequest gcpRolesetKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpRolesetRolesetKey");

            // verify the required parameter 'gcpRolesetKeyRequest' is set
            if (gcpRolesetKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRolesetKeyRequest' when calling Secrets->PostGcpRolesetRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter
            requestOptions.Data = gcpRolesetKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpRolesetRolesetToken(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpRolesetRolesetToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpRolesetRolesetTokenAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpRolesetRolesetToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpRolesetRolesetToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpStaticAccountName(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountName");

            // verify the required parameter 'gcpStaticAccountRequest' is set
            if (gcpStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountRequest' when calling Secrets->PostGcpStaticAccountName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpStaticAccountRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpStaticAccountNameAsync(string name, GcpStaticAccountRequest gcpStaticAccountRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountName");

            // verify the required parameter 'gcpStaticAccountRequest' is set
            if (gcpStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountRequest' when calling Secrets->PostGcpStaticAccountName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpStaticAccountNameKey(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameKey");

            // verify the required parameter 'gcpStaticAccountKeyRequest' is set
            if (gcpStaticAccountKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountKeyRequest' when calling Secrets->PostGcpStaticAccountNameKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpStaticAccountKeyRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpStaticAccountNameKeyAsync(string name, GcpStaticAccountKeyRequest gcpStaticAccountKeyRequest, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameKey");

            // verify the required parameter 'gcpStaticAccountKeyRequest' is set
            if (gcpStaticAccountKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpStaticAccountKeyRequest' when calling Secrets->PostGcpStaticAccountNameKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpStaticAccountKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpStaticAccountNameRotateKey(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpStaticAccountNameRotateKeyAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpStaticAccountNameToken(string name, string gcpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameToken");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpStaticAccountNameTokenAsync(string name, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostGcpStaticAccountNameToken");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpStaticAccountNameToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpTokenRoleset(string roleset, string gcpMountPath = default(string))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpTokenRoleset");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/token/{roleset}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpTokenRolesetAsync(string roleset, string gcpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->PostGcpTokenRoleset");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/token/{roleset}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpTokenRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsConfig(GcpkmsConfigRequest gcpkmsConfigRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'gcpkmsConfigRequest' is set
            if (gcpkmsConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsConfigRequest' when calling Secrets->PostGcpkmsConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the GCP KMS secrets engine 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsConfigAsync(GcpkmsConfigRequest gcpkmsConfigRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'gcpkmsConfigRequest' is set
            if (gcpkmsConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsConfigRequest' when calling Secrets->PostGcpkmsConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.Data = gcpkmsConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsDecryptKey(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsDecryptKey");

            // verify the required parameter 'gcpkmsDecryptRequest' is set
            if (gcpkmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsDecryptRequest' when calling Secrets->PostGcpkmsDecryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/decrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsDecryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsDecryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsDecryptKeyAsync(string key, GcpkmsDecryptRequest gcpkmsDecryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsDecryptKey");

            // verify the required parameter 'gcpkmsDecryptRequest' is set
            if (gcpkmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsDecryptRequest' when calling Secrets->PostGcpkmsDecryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/decrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsDecryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsEncryptKey(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsEncryptKey");

            // verify the required parameter 'gcpkmsEncryptRequest' is set
            if (gcpkmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsEncryptRequest' when calling Secrets->PostGcpkmsEncryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/encrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsEncryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsEncryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsEncryptKeyAsync(string key, GcpkmsEncryptRequest gcpkmsEncryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsEncryptKey");

            // verify the required parameter 'gcpkmsEncryptRequest' is set
            if (gcpkmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsEncryptRequest' when calling Secrets->PostGcpkmsEncryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/encrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsEncryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysConfigKey(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysConfigKey");

            // verify the required parameter 'gcpkmsKeysConfigRequest' is set
            if (gcpkmsKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysConfigRequest' when calling Secrets->PostGcpkmsKeysConfigKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysConfigRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysConfigKeyAsync(string key, GcpkmsKeysConfigRequest gcpkmsKeysConfigRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysConfigKey");

            // verify the required parameter 'gcpkmsKeysConfigRequest' is set
            if (gcpkmsKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysConfigRequest' when calling Secrets->PostGcpkmsKeysConfigKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysConfigKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysDeregisterKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysDeregisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deregister an existing key in Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysDeregisterKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysKey(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysKey");

            // verify the required parameter 'gcpkmsKeysRequest' is set
            if (gcpkmsKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRequest' when calling Secrets->PostGcpkmsKeysKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsKeysRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysKeyAsync(string key, GcpkmsKeysRequest gcpkmsKeysRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysKey");

            // verify the required parameter 'gcpkmsKeysRequest' is set
            if (gcpkmsKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRequest' when calling Secrets->PostGcpkmsKeysKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysRegisterKey(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysRegisterKey");

            // verify the required parameter 'gcpkmsKeysRegisterRequest' is set
            if (gcpkmsKeysRegisterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRegisterRequest' when calling Secrets->PostGcpkmsKeysRegisterKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/register/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsKeysRegisterRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysRegisterKeyAsync(string key, GcpkmsKeysRegisterRequest gcpkmsKeysRegisterRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysRegisterKey");

            // verify the required parameter 'gcpkmsKeysRegisterRequest' is set
            if (gcpkmsKeysRegisterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsKeysRegisterRequest' when calling Secrets->PostGcpkmsKeysRegisterKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsKeysRegisterRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/register/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysRotateKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/rotate/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysRotateKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/rotate/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsKeysTrimKey(string key, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete old crypto key versions from Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsKeysTrimKeyAsync(string key, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsKeysTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsKeysTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsReencryptKey(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsReencryptKey");

            // verify the required parameter 'gcpkmsReencryptRequest' is set
            if (gcpkmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsReencryptRequest' when calling Secrets->PostGcpkmsReencryptKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/reencrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsReencryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsReencryptRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsReencryptKeyAsync(string key, GcpkmsReencryptRequest gcpkmsReencryptRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsReencryptKey");

            // verify the required parameter 'gcpkmsReencryptRequest' is set
            if (gcpkmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsReencryptRequest' when calling Secrets->PostGcpkmsReencryptKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsReencryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/reencrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsReencryptKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsSignKey(string key, GcpkmsSignRequest gcpkmsSignRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsSignKey");

            // verify the required parameter 'gcpkmsSignRequest' is set
            if (gcpkmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsSignRequest' when calling Secrets->PostGcpkmsSignKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/sign/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsSignKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsSignRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsSignKeyAsync(string key, GcpkmsSignRequest gcpkmsSignRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsSignKey");

            // verify the required parameter 'gcpkmsSignRequest' is set
            if (gcpkmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsSignRequest' when calling Secrets->PostGcpkmsSignKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/sign/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsSignKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostGcpkmsVerifyKey(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string gcpkmsMountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsVerifyKey");

            // verify the required parameter 'gcpkmsVerifyRequest' is set
            if (gcpkmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsVerifyRequest' when calling Secrets->PostGcpkmsVerifyKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/verify/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsVerifyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsVerifyRequest"></param>
        /// <param name="gcpkmsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcpkms&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostGcpkmsVerifyKeyAsync(string key, GcpkmsVerifyRequest gcpkmsVerifyRequest, string gcpkmsMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->PostGcpkmsVerifyKey");

            // verify the required parameter 'gcpkmsVerifyRequest' is set
            if (gcpkmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpkmsVerifyRequest' when calling Secrets->PostGcpkmsVerifyKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpkmsMountPath != null)
            {
                requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = gcpkmsVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/verify/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostGcpkmsVerifyKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Secrets->PostKubernetesConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Secrets->PostKubernetesConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesCredsRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostKubernetesCredsName(string name, KubernetesCredsRequest kubernetesCredsRequest, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostKubernetesCredsName");

            // verify the required parameter 'kubernetesCredsRequest' is set
            if (kubernetesCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesCredsRequest' when calling Secrets->PostKubernetesCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesCredsRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostKubernetesCredsNameAsync(string name, KubernetesCredsRequest kubernetesCredsRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostKubernetesCredsName");

            // verify the required parameter 'kubernetesCredsRequest' is set
            if (kubernetesCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesCredsRequest' when calling Secrets->PostKubernetesCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesRolesRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostKubernetesRolesName(string name, KubernetesRolesRequest kubernetesRolesRequest, string kubernetesMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostKubernetesRolesName");

            // verify the required parameter 'kubernetesRolesRequest' is set
            if (kubernetesRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRolesRequest' when calling Secrets->PostKubernetesRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesRolesRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostKubernetesRolesNameAsync(string name, KubernetesRolesRequest kubernetesRolesRequest, string kubernetesMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostKubernetesRolesName");

            // verify the required parameter 'kubernetesRolesRequest' is set
            if (kubernetesRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRolesRequest' when calling Secrets->PostKubernetesRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostKubernetesRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapConfig(LdapConfigRequest ldapConfigRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Secrets->PostLdapConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Secrets->PostLdapConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapLibraryManageNameCheckIn(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryManageNameCheckIn");

            // verify the required parameter 'ldapLibraryManageCheckInRequest' is set
            if (ldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryManageCheckInRequest' when calling Secrets->PostLdapLibraryManageNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryManageCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapLibraryManageNameCheckInAsync(string name, LdapLibraryManageCheckInRequest ldapLibraryManageCheckInRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryManageNameCheckIn");

            // verify the required parameter 'ldapLibraryManageCheckInRequest' is set
            if (ldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryManageCheckInRequest' when calling Secrets->PostLdapLibraryManageNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapLibraryName(string name, LdapLibraryRequest ldapLibraryRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryName");

            // verify the required parameter 'ldapLibraryRequest' is set
            if (ldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryRequest' when calling Secrets->PostLdapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapLibraryNameAsync(string name, LdapLibraryRequest ldapLibraryRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryName");

            // verify the required parameter 'ldapLibraryRequest' is set
            if (ldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryRequest' when calling Secrets->PostLdapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapLibraryNameCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryNameCheckIn");

            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->PostLdapLibraryNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapLibraryNameCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryNameCheckIn");

            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->PostLdapLibraryNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapLibraryNameCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryNameCheckOut");

            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->PostLdapLibraryNameCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapLibraryNameCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapLibraryNameCheckOut");

            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->PostLdapLibraryNameCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapRoleName(string name, LdapRoleRequest ldapRoleRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapRoleName");

            // verify the required parameter 'ldapRoleRequest' is set
            if (ldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapRoleRequest' when calling Secrets->PostLdapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapRoleNameAsync(string name, LdapRoleRequest ldapRoleRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapRoleName");

            // verify the required parameter 'ldapRoleRequest' is set
            if (ldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapRoleRequest' when calling Secrets->PostLdapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapRotateRoleName(string name, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapRotateRoleNameAsync(string name, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapRotateRoot(string ldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapRotateRootAsync(string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostLdapStaticRoleName(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string ldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapStaticRoleName");

            // verify the required parameter 'ldapStaticRoleRequest' is set
            if (ldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapStaticRoleRequest' when calling Secrets->PostLdapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapStaticRoleRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostLdapStaticRoleNameAsync(string name, LdapStaticRoleRequest ldapStaticRoleRequest, string ldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostLdapStaticRoleName");

            // verify the required parameter 'ldapStaticRoleRequest' is set
            if (ldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapStaticRoleRequest' when calling Secrets->PostLdapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapStaticRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostLdapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the  credentials that are used to manage Database Users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasConfigRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostMongodbatlasConfig(MongodbatlasConfigRequest mongodbatlasConfigRequest, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'mongodbatlasConfigRequest' is set
            if (mongodbatlasConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongodbatlasConfigRequest' when calling Secrets->PostMongodbatlasConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.Data = mongodbatlasConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mongodbatlas_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the  credentials that are used to manage Database Users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasConfigRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostMongodbatlasConfigAsync(MongodbatlasConfigRequest mongodbatlasConfigRequest, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'mongodbatlasConfigRequest' is set
            if (mongodbatlasConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongodbatlasConfigRequest' when calling Secrets->PostMongodbatlasConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.Data = mongodbatlasConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mongodbatlas_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostMongodbatlasCredsName(string name, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostMongodbatlasCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate MongoDB Atlas Programmatic API from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostMongodbatlasCredsNameAsync(string name, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostMongodbatlasCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasRolesRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostMongodbatlasRolesName(string name, MongodbatlasRolesRequest mongodbatlasRolesRequest, string mongodbatlasMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostMongodbatlasRolesName");

            // verify the required parameter 'mongodbatlasRolesRequest' is set
            if (mongodbatlasRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongodbatlasRolesRequest' when calling Secrets->PostMongodbatlasRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = mongodbatlasRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasRolesRequest"></param>
        /// <param name="mongodbatlasMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;mongodbatlas&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostMongodbatlasRolesNameAsync(string name, MongodbatlasRolesRequest mongodbatlasRolesRequest, string mongodbatlasMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostMongodbatlasRolesName");

            // verify the required parameter 'mongodbatlasRolesRequest' is set
            if (mongodbatlasRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongodbatlasRolesRequest' when calling Secrets->PostMongodbatlasRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mongodbatlasMountPath != null)
            {
                requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = mongodbatlasRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostMongodbatlasRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostNomadConfigAccess(NomadConfigAccessRequest nomadConfigAccessRequest, string nomadMountPath = default(string))
        {
            // verify the required parameter 'nomadConfigAccessRequest' is set
            if (nomadConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigAccessRequest' when calling Secrets->PostNomadConfigAccess");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigAccessRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostNomadConfigAccessAsync(NomadConfigAccessRequest nomadConfigAccessRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nomadConfigAccessRequest' is set
            if (nomadConfigAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigAccessRequest' when calling Secrets->PostNomadConfigAccess");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigAccessRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadConfigAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostNomadConfigLease(NomadConfigLeaseRequest nomadConfigLeaseRequest, string nomadMountPath = default(string))
        {
            // verify the required parameter 'nomadConfigLeaseRequest' is set
            if (nomadConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigLeaseRequest' when calling Secrets->PostNomadConfigLease");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated tokens 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigLeaseRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostNomadConfigLeaseAsync(NomadConfigLeaseRequest nomadConfigLeaseRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nomadConfigLeaseRequest' is set
            if (nomadConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigLeaseRequest' when calling Secrets->PostNomadConfigLease");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadConfigLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadRoleRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostNomadRoleName(string name, NomadRoleRequest nomadRoleRequest, string nomadMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostNomadRoleName");

            // verify the required parameter 'nomadRoleRequest' is set
            if (nomadRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadRoleRequest' when calling Secrets->PostNomadRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadRoleRequest"></param>
        /// <param name="nomadMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;nomad&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostNomadRoleNameAsync(string name, NomadRoleRequest nomadRoleRequest, string nomadMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostNomadRoleName");

            // verify the required parameter 'nomadRoleRequest' is set
            if (nomadRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadRoleRequest' when calling Secrets->PostNomadRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (nomadMountPath != null)
            {
                requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter
            }
            requestOptions.Data = nomadRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostNomadRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapConfigRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapConfig(OpenldapConfigRequest openldapConfigRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'openldapConfigRequest' is set
            if (openldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapConfigRequest' when calling Secrets->PostOpenldapConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapConfigRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapConfigAsync(OpenldapConfigRequest openldapConfigRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'openldapConfigRequest' is set
            if (openldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapConfigRequest' when calling Secrets->PostOpenldapConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryManageCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapLibraryManageNameCheckIn(string name, OpenldapLibraryManageCheckInRequest openldapLibraryManageCheckInRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryManageNameCheckIn");

            // verify the required parameter 'openldapLibraryManageCheckInRequest' is set
            if (openldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryManageCheckInRequest' when calling Secrets->PostOpenldapLibraryManageNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryManageCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapLibraryManageNameCheckInAsync(string name, OpenldapLibraryManageCheckInRequest openldapLibraryManageCheckInRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryManageNameCheckIn");

            // verify the required parameter 'openldapLibraryManageCheckInRequest' is set
            if (openldapLibraryManageCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryManageCheckInRequest' when calling Secrets->PostOpenldapLibraryManageNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryManageCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryManageNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapLibraryName(string name, OpenldapLibraryRequest openldapLibraryRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryName");

            // verify the required parameter 'openldapLibraryRequest' is set
            if (openldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryRequest' when calling Secrets->PostOpenldapLibraryName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapLibraryNameAsync(string name, OpenldapLibraryRequest openldapLibraryRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryName");

            // verify the required parameter 'openldapLibraryRequest' is set
            if (openldapLibraryRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryRequest' when calling Secrets->PostOpenldapLibraryName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapLibraryNameCheckIn(string name, OpenldapLibraryCheckInRequest openldapLibraryCheckInRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryNameCheckIn");

            // verify the required parameter 'openldapLibraryCheckInRequest' is set
            if (openldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryCheckInRequest' when calling Secrets->PostOpenldapLibraryNameCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryCheckInRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="openldapLibraryCheckInRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapLibraryNameCheckInAsync(string name, OpenldapLibraryCheckInRequest openldapLibraryCheckInRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryNameCheckIn");

            // verify the required parameter 'openldapLibraryCheckInRequest' is set
            if (openldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryCheckInRequest' when calling Secrets->PostOpenldapLibraryNameCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryCheckInRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryNameCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="openldapLibraryCheckOutRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapLibraryNameCheckOut(string name, OpenldapLibraryCheckOutRequest openldapLibraryCheckOutRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryNameCheckOut");

            // verify the required parameter 'openldapLibraryCheckOutRequest' is set
            if (openldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryCheckOutRequest' when calling Secrets->PostOpenldapLibraryNameCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set</param>
        /// <param name="openldapLibraryCheckOutRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapLibraryNameCheckOutAsync(string name, OpenldapLibraryCheckOutRequest openldapLibraryCheckOutRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapLibraryNameCheckOut");

            // verify the required parameter 'openldapLibraryCheckOutRequest' is set
            if (openldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapLibraryCheckOutRequest' when calling Secrets->PostOpenldapLibraryNameCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapLibraryCheckOutRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapLibraryNameCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapRoleName(string name, OpenldapRoleRequest openldapRoleRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapRoleName");

            // verify the required parameter 'openldapRoleRequest' is set
            if (openldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapRoleRequest' when calling Secrets->PostOpenldapRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="openldapRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapRoleNameAsync(string name, OpenldapRoleRequest openldapRoleRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapRoleName");

            // verify the required parameter 'openldapRoleRequest' is set
            if (openldapRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapRoleRequest' when calling Secrets->PostOpenldapRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapRotateRoleName(string name, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapRotateRoleNameAsync(string name, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapRotateRoot(string openldapMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapRotateRootAsync(string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapStaticRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostOpenldapStaticRoleName(string name, OpenldapStaticRoleRequest openldapStaticRoleRequest, string openldapMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapStaticRoleName");

            // verify the required parameter 'openldapStaticRoleRequest' is set
            if (openldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapStaticRoleRequest' when calling Secrets->PostOpenldapStaticRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapStaticRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="openldapStaticRoleRequest"></param>
        /// <param name="openldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;openldap&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostOpenldapStaticRoleNameAsync(string name, OpenldapStaticRoleRequest openldapStaticRoleRequest, string openldapMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostOpenldapStaticRoleName");

            // verify the required parameter 'openldapStaticRoleRequest' is set
            if (openldapStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'openldapStaticRoleRequest' when calling Secrets->PostOpenldapStaticRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (openldapMountPath != null)
            {
                requestOptions.PathParameters.Add("openldap_mount_path", ClientUtils.ParameterToString(openldapMountPath)); // path parameter
            }
            requestOptions.Data = openldapStaticRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{openldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostOpenldapStaticRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiBundle(PkiBundleRequest pkiBundleRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiBundleRequest' is set
            if (pkiBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiBundleRequest' when calling Secrets->PostPkiBundle");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/bundle", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiBundleRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiBundleAsync(PkiBundleRequest pkiBundleRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiBundleRequest' is set
            if (pkiBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiBundleRequest' when calling Secrets->PostPkiBundle");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiBundleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/bundle", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiCert(PkiCertRequest pkiCertRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiCertRequest' is set
            if (pkiCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCertRequest' when calling Secrets->PostPkiCert");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCertRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiCertAsync(PkiCertRequest pkiCertRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiCertRequest' is set
            if (pkiCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCertRequest' when calling Secrets->PostPkiCert");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiCertRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigAutoTidy(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigAutoTidyRequest' is set
            if (pkiConfigAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigAutoTidyRequest' when calling Secrets->PostPkiConfigAutoTidy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigAutoTidyAsync(PkiConfigAutoTidyRequest pkiConfigAutoTidyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigAutoTidyRequest' is set
            if (pkiConfigAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigAutoTidyRequest' when calling Secrets->PostPkiConfigAutoTidy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigAutoTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCaRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigCa(PkiConfigCaRequest pkiConfigCaRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigCaRequest' is set
            if (pkiConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCaRequest' when calling Secrets->PostPkiConfigCa");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCaRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCaRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigCaAsync(PkiConfigCaRequest pkiConfigCaRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigCaRequest' is set
            if (pkiConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCaRequest' when calling Secrets->PostPkiConfigCa");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCaRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigCrl(PkiConfigCrlRequest pkiConfigCrlRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigCrlRequest' is set
            if (pkiConfigCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCrlRequest' when calling Secrets->PostPkiConfigCrl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigCrlRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigCrlAsync(PkiConfigCrlRequest pkiConfigCrlRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigCrlRequest' is set
            if (pkiConfigCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigCrlRequest' when calling Secrets->PostPkiConfigCrl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigCrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigIssuers(PkiConfigIssuersRequest pkiConfigIssuersRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigIssuersRequest' is set
            if (pkiConfigIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigIssuersRequest' when calling Secrets->PostPkiConfigIssuers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigIssuersRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigIssuersAsync(PkiConfigIssuersRequest pkiConfigIssuersRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigIssuersRequest' is set
            if (pkiConfigIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigIssuersRequest' when calling Secrets->PostPkiConfigIssuers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigIssuersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigKeys(PkiConfigKeysRequest pkiConfigKeysRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigKeysRequest' is set
            if (pkiConfigKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigKeysRequest' when calling Secrets->PostPkiConfigKeys");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigKeysRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigKeysAsync(PkiConfigKeysRequest pkiConfigKeysRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigKeysRequest' is set
            if (pkiConfigKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigKeysRequest' when calling Secrets->PostPkiConfigKeys");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiConfigUrls(PkiConfigUrlsRequest pkiConfigUrlsRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiConfigUrlsRequest' is set
            if (pkiConfigUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigUrlsRequest' when calling Secrets->PostPkiConfigUrls");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigUrlsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiConfigUrlsAsync(PkiConfigUrlsRequest pkiConfigUrlsRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiConfigUrlsRequest' is set
            if (pkiConfigUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigUrlsRequest' when calling Secrets->PostPkiConfigUrls");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiConfigUrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiConfigUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIntermediateCrossSign(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiIntermediateCrossSignRequest' is set
            if (pkiIntermediateCrossSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateCrossSignRequest' when calling Secrets->PostPkiIntermediateCrossSign");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/intermediate/cross-sign", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateCrossSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateCrossSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIntermediateCrossSignAsync(PkiIntermediateCrossSignRequest pkiIntermediateCrossSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiIntermediateCrossSignRequest' is set
            if (pkiIntermediateCrossSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateCrossSignRequest' when calling Secrets->PostPkiIntermediateCrossSign");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateCrossSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/intermediate/cross-sign", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateCrossSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIntermediateGenerateExported(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIntermediateGenerateExported");

            // verify the required parameter 'pkiIntermediateGenerateRequest' is set
            if (pkiIntermediateGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateGenerateRequest' when calling Secrets->PostPkiIntermediateGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/intermediate/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIntermediateGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIntermediateGenerateExportedAsync(string exported, PkiIntermediateGenerateRequest pkiIntermediateGenerateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIntermediateGenerateExported");

            // verify the required parameter 'pkiIntermediateGenerateRequest' is set
            if (pkiIntermediateGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateGenerateRequest' when calling Secrets->PostPkiIntermediateGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/intermediate/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIntermediateSetSigned(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiIntermediateSetSignedRequest' is set
            if (pkiIntermediateSetSignedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateSetSignedRequest' when calling Secrets->PostPkiIntermediateSetSigned");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/intermediate/set-signed", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateSetSigned", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIntermediateSetSignedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIntermediateSetSignedAsync(PkiIntermediateSetSignedRequest pkiIntermediateSetSignedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiIntermediateSetSignedRequest' is set
            if (pkiIntermediateSetSignedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIntermediateSetSignedRequest' when calling Secrets->PostPkiIntermediateSetSigned");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIntermediateSetSignedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/intermediate/set-signed", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIntermediateSetSigned", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiInternalExported(PkiInternalExportedRequest pkiInternalExportedRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiInternalExportedRequest' is set
            if (pkiInternalExportedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiInternalExportedRequest' when calling Secrets->PostPkiInternalExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiInternalExportedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/internal|exported", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiInternalExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiInternalExportedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiInternalExportedAsync(PkiInternalExportedRequest pkiInternalExportedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiInternalExportedRequest' is set
            if (pkiInternalExportedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiInternalExportedRequest' when calling Secrets->PostPkiInternalExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiInternalExportedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/internal|exported", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiInternalExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssueRole(string role, PkiIssueRequest pkiIssueRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssueRole");

            // verify the required parameter 'pkiIssueRequest' is set
            if (pkiIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssueRequest' when calling Secrets->PostPkiIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssueRoleAsync(string role, PkiIssueRequest pkiIssueRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssueRole");

            // verify the required parameter 'pkiIssueRequest' is set
            if (pkiIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssueRequest' when calling Secrets->PostPkiIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefIssueRole(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'pkiIssuerIssueRequest' is set
            if (pkiIssuerIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueRequest' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerIssueRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefIssueRoleAsync(string issuerRef, string role, PkiIssuerIssueRequest pkiIssuerIssueRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");

            // verify the required parameter 'pkiIssuerIssueRequest' is set
            if (pkiIssuerIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueRequest' when calling Secrets->PostPkiIssuerIssuerRefIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefRevoke(string issuerRef, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefRevokeAsync(string issuerRef, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignIntermediate");

            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->PostPkiIssuerIssuerRefSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignIntermediate");

            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->PostPkiIssuerIssuerRefSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefSignRole(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefSignRole");

            // verify the required parameter 'pkiIssuerSignRequest' is set
            if (pkiIssuerSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRequest' when calling Secrets->PostPkiIssuerIssuerRefSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignRoleAsync(string issuerRef, string role, PkiIssuerSignRequest pkiIssuerSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefSignRole");

            // verify the required parameter 'pkiIssuerSignRequest' is set
            if (pkiIssuerSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRequest' when calling Secrets->PostPkiIssuerIssuerRefSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignSelfIssued");

            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->PostPkiIssuerIssuerRefSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignSelfIssued");

            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->PostPkiIssuerIssuerRefSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatim");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatim");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerIssuerRefSignVerbatimRole(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerIssuerRefSignVerbatimRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");

            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PostPkiIssuerIssuerRefSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiIssuerSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerIssuerRefSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuerRefDerPem(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerRefDerPem");

            // verify the required parameter 'pkiDerPemRequest' is set
            if (pkiDerPemRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiDerPemRequest' when calling Secrets->PostPkiIssuerRefDerPem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiDerPemRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiDerPemRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuerRefDerPemAsync(string issuerRef, PkiDerPemRequest pkiDerPemRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PostPkiIssuerRefDerPem");

            // verify the required parameter 'pkiDerPemRequest' is set
            if (pkiDerPemRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiDerPemRequest' when calling Secrets->PostPkiIssuerRefDerPem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiDerPemRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/{issuer_ref}/der|/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuerRefDerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuersGenerateIntermediateExported(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIssuersGenerateIntermediateExported");

            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->PostPkiIssuersGenerateIntermediateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuers/generate/intermediate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuersGenerateIntermediateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuersGenerateIntermediateExportedAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIssuersGenerateIntermediateExported");

            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->PostPkiIssuersGenerateIntermediateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuers/generate/intermediate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuersGenerateIntermediateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiIssuersGenerateRootExported(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIssuersGenerateRootExported");

            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->PostPkiIssuersGenerateRootExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuers/generate/root/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuersGenerateRootExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiIssuersGenerateRootExportedAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiIssuersGenerateRootExported");

            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->PostPkiIssuersGenerateRootExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiIssuersGenerateRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuers/generate/root/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiIssuersGenerateRootExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiJson(PkiJsonRequest pkiJsonRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiJsonRequest' is set
            if (pkiJsonRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiJsonRequest' when calling Secrets->PostPkiJson");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}//json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiJsonRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiJsonAsync(PkiJsonRequest pkiJsonRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiJsonRequest' is set
            if (pkiJsonRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiJsonRequest' when calling Secrets->PostPkiJson");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiJsonRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}//json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiKeyKeyRef(string keyRef, PkiKeyRequest pkiKeyRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PostPkiKeyKeyRef");

            // verify the required parameter 'pkiKeyRequest' is set
            if (pkiKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeyRequest' when calling Secrets->PostPkiKeyKeyRef");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiKeyKeyRefAsync(string keyRef, PkiKeyRequest pkiKeyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PostPkiKeyKeyRef");

            // verify the required parameter 'pkiKeyRequest' is set
            if (pkiKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeyRequest' when calling Secrets->PostPkiKeyKeyRef");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKeyKeyRef", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiKeysImport(PkiKeysImportRequest pkiKeysImportRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiKeysImportRequest' is set
            if (pkiKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeysImportRequest' when calling Secrets->PostPkiKeysImport");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/keys/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKeysImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKeysImportRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiKeysImportAsync(PkiKeysImportRequest pkiKeysImportRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiKeysImportRequest' is set
            if (pkiKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKeysImportRequest' when calling Secrets->PostPkiKeysImport");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/keys/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKeysImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiKms(PkiKmsRequest pkiKmsRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiKmsRequest' is set
            if (pkiKmsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKmsRequest' when calling Secrets->PostPkiKms");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/kms", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKms", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiKmsRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiKmsAsync(PkiKmsRequest pkiKmsRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiKmsRequest' is set
            if (pkiKmsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiKmsRequest' when calling Secrets->PostPkiKms");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiKmsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/kms", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiKms", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiOcsp(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/ocsp", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiOcspAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/ocsp", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRevoke(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->PostPkiRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->PostPkiRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->PostPkiRevokeWithKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/revoke-with-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->PostPkiRevokeWithKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRevokeWithKeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/revoke-with-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiRolesRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRolesName(string name, PkiRolesRequest pkiRolesRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostPkiRolesName");

            // verify the required parameter 'pkiRolesRequest' is set
            if (pkiRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRolesRequest' when calling Secrets->PostPkiRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiRolesRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRolesNameAsync(string name, PkiRolesRequest pkiRolesRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostPkiRolesName");

            // verify the required parameter 'pkiRolesRequest' is set
            if (pkiRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRolesRequest' when calling Secrets->PostPkiRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRootGenerateExported(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiRootGenerateExported");

            // verify the required parameter 'pkiRootGenerateRequest' is set
            if (pkiRootGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootGenerateRequest' when calling Secrets->PostPkiRootGenerateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/root/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootGenerateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRootGenerateExportedAsync(string exported, PkiRootGenerateRequest pkiRootGenerateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiRootGenerateExported");

            // verify the required parameter 'pkiRootGenerateRequest' is set
            if (pkiRootGenerateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootGenerateRequest' when calling Secrets->PostPkiRootGenerateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootGenerateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/root/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootGenerateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRootReplace(PkiRootReplaceRequest pkiRootReplaceRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiRootReplaceRequest' is set
            if (pkiRootReplaceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootReplaceRequest' when calling Secrets->PostPkiRootReplace");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/root/replace", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootReplace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootReplaceRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRootReplaceAsync(PkiRootReplaceRequest pkiRootReplaceRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootReplaceRequest' is set
            if (pkiRootReplaceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootReplaceRequest' when calling Secrets->PostPkiRootReplace");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootReplaceRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/root/replace", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootReplace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRootRotateExported(string exported, PkiRootRotateRequest pkiRootRotateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiRootRotateExported");

            // verify the required parameter 'pkiRootRotateRequest' is set
            if (pkiRootRotateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootRotateRequest' when calling Secrets->PostPkiRootRotateExported");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/root/rotate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootRotateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiRootRotateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRootRotateExportedAsync(string exported, PkiRootRotateRequest pkiRootRotateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PostPkiRootRotateExported");

            // verify the required parameter 'pkiRootRotateRequest' is set
            if (pkiRootRotateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootRotateRequest' when calling Secrets->PostPkiRootRotateExported");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter
            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootRotateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/root/rotate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootRotateExported", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->PostPkiRootSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/root/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->PostPkiRootSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignIntermediateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/root/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->PostPkiRootSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/root/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->PostPkiRootSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiRootSignSelfIssuedRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/root/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiSignRole(string role, PkiSignRequest pkiSignRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiSignRole");

            // verify the required parameter 'pkiSignRequest' is set
            if (pkiSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignRequest' when calling Secrets->PostPkiSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiSignRoleAsync(string role, PkiSignRequest pkiSignRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiSignRole");

            // verify the required parameter 'pkiSignRequest' is set
            if (pkiSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignRequest' when calling Secrets->PostPkiSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PostPkiSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PostPkiSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiSignVerbatimRole(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiSignVerbatimRole");

            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PostPkiSignVerbatimRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiSignVerbatimRoleAsync(string role, PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostPkiSignVerbatimRole");

            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PostPkiSignVerbatimRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = pkiSignVerbatimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiSignVerbatimRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiTidy(PkiTidyRequest pkiTidyRequest, string pkiMountPath = default(string))
        {
            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->PostPkiTidy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiTidyAsync(PkiTidyRequest pkiTidyRequest, string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->PostPkiTidy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }
            requestOptions.Data = pkiTidyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostPkiTidyCancel(string pkiMountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/tidy-cancel", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;pki&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostPkiTidyCancelAsync(string pkiMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (pkiMountPath != null)
            {
                requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/tidy-cancel", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostPkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostRabbitmqConfigConnection(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'rabbitmqConfigConnectionRequest' is set
            if (rabbitmqConfigConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigConnectionRequest' when calling Secrets->PostRabbitmqConfigConnection");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/config/connection", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqConfigConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostRabbitmqConfigConnectionAsync(RabbitmqConfigConnectionRequest rabbitmqConfigConnectionRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'rabbitmqConfigConnectionRequest' is set
            if (rabbitmqConfigConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigConnectionRequest' when calling Secrets->PostRabbitmqConfigConnection");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigConnectionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/config/connection", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqConfigConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostRabbitmqConfigLease(RabbitmqConfigLeaseRequest rabbitmqConfigLeaseRequest, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'rabbitmqConfigLeaseRequest' is set
            if (rabbitmqConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigLeaseRequest' when calling Secrets->PostRabbitmqConfigLease");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the lease parameters for generated credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqConfigLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostRabbitmqConfigLeaseAsync(RabbitmqConfigLeaseRequest rabbitmqConfigLeaseRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'rabbitmqConfigLeaseRequest' is set
            if (rabbitmqConfigLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqConfigLeaseRequest' when calling Secrets->PostRabbitmqConfigLease");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqConfigLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqConfigLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqRolesRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostRabbitmqRolesName(string name, RabbitmqRolesRequest rabbitmqRolesRequest, string rabbitmqMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostRabbitmqRolesName");

            // verify the required parameter 'rabbitmqRolesRequest' is set
            if (rabbitmqRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqRolesRequest' when calling Secrets->PostRabbitmqRolesName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqRolesRequest"></param>
        /// <param name="rabbitmqMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;rabbitmq&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostRabbitmqRolesNameAsync(string name, RabbitmqRolesRequest rabbitmqRolesRequest, string rabbitmqMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostRabbitmqRolesName");

            // verify the required parameter 'rabbitmqRolesRequest' is set
            if (rabbitmqRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitmqRolesRequest' when calling Secrets->PostRabbitmqRolesName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (rabbitmqMountPath != null)
            {
                requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter
            }
            requestOptions.Data = rabbitmqRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostRabbitmqRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvConfigRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretConfig(KvConfigRequest kvConfigRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'kvConfigRequest' is set
            if (kvConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvConfigRequest' when calling Secrets->PostSecretConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvConfigRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretConfigAsync(KvConfigRequest kvConfigRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kvConfigRequest' is set
            if (kvConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvConfigRequest' when calling Secrets->PostSecretConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretDataPath(string path, KvDataRequest kvDataRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDataPath");

            // verify the required parameter 'kvDataRequest' is set
            if (kvDataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDataRequest' when calling Secrets->PostSecretDataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Write, Patch, Read, and Delete data in the Key-Value Store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretDataPathAsync(string path, KvDataRequest kvDataRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDataPath");

            // verify the required parameter 'kvDataRequest' is set
            if (kvDataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDataRequest' when calling Secrets->PostSecretDataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretDeletePath(string path, KvDeleteRequest kvDeleteRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDeletePath");

            // verify the required parameter 'kvDeleteRequest' is set
            if (kvDeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDeleteRequest' when calling Secrets->PostSecretDeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/delete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Marks one or more versions as deleted in the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretDeletePathAsync(string path, KvDeleteRequest kvDeleteRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDeletePath");

            // verify the required parameter 'kvDeleteRequest' is set
            if (kvDeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDeleteRequest' when calling Secrets->PostSecretDeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/delete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretDestroyPath(string path, KvDestroyRequest kvDestroyRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDestroyPath");

            // verify the required parameter 'kvDestroyRequest' is set
            if (kvDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDestroyRequest' when calling Secrets->PostSecretDestroyPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/destroy/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDestroyPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Permanently removes one or more versions in the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvDestroyRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretDestroyPathAsync(string path, KvDestroyRequest kvDestroyRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretDestroyPath");

            // verify the required parameter 'kvDestroyRequest' is set
            if (kvDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvDestroyRequest' when calling Secrets->PostSecretDestroyPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/destroy/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretDestroyPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretMetadataPath(string path, KvMetadataRequest kvMetadataRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretMetadataPath");

            // verify the required parameter 'kvMetadataRequest' is set
            if (kvMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvMetadataRequest' when calling Secrets->PostSecretMetadataPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures settings for the KV store 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvMetadataRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretMetadataPathAsync(string path, KvMetadataRequest kvMetadataRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretMetadataPath");

            // verify the required parameter 'kvMetadataRequest' is set
            if (kvMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvMetadataRequest' when calling Secrets->PostSecretMetadataPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvMetadataRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretMetadataPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretPath(string path, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretPathAsync(string path, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSecretUndeletePath(string path, KvUndeleteRequest kvUndeleteRequest, string secretMountPath = default(string))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretUndeletePath");

            // verify the required parameter 'kvUndeleteRequest' is set
            if (kvUndeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvUndeleteRequest' when calling Secrets->PostSecretUndeletePath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{secret_mount_path}/undelete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretUndeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Undeletes one or more versions from the KV store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvUndeleteRequest"></param>
        /// <param name="secretMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;secret&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSecretUndeletePathAsync(string path, KvUndeleteRequest kvUndeleteRequest, string secretMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->PostSecretUndeletePath");

            // verify the required parameter 'kvUndeleteRequest' is set
            if (kvUndeleteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvUndeleteRequest' when calling Secrets->PostSecretUndeletePath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (secretMountPath != null)
            {
                requestOptions.PathParameters.Add("secret_mount_path", ClientUtils.ParameterToString(secretMountPath)); // path parameter
            }
            requestOptions.Data = kvUndeleteRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{secret_mount_path}/undelete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSecretUndeletePath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshConfigCa(SshConfigCaRequest sshConfigCaRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'sshConfigCaRequest' is set
            if (sshConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigCaRequest' when calling Secrets->PostSshConfigCa");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshConfigCaRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Set the SSH private key used for signing certificates. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigCaRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshConfigCaAsync(SshConfigCaRequest sshConfigCaRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshConfigCaRequest' is set
            if (sshConfigCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigCaRequest' when calling Secrets->PostSshConfigCa");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshConfigCaRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshConfigCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshConfigZeroaddress(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'sshConfigZeroaddressRequest' is set
            if (sshConfigZeroaddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigZeroaddressRequest' when calling Secrets->PostSshConfigZeroaddress");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign zero address as default CIDR block for select roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigZeroaddressRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshConfigZeroaddressAsync(SshConfigZeroaddressRequest sshConfigZeroaddressRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshConfigZeroaddressRequest' is set
            if (sshConfigZeroaddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigZeroaddressRequest' when calling Secrets->PostSshConfigZeroaddress");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshConfigZeroaddressRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshConfigZeroaddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshCredsRole(string role, SshCredsRequest sshCredsRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshCredsRole");

            // verify the required parameter 'sshCredsRequest' is set
            if (sshCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshCredsRequest' when calling Secrets->PostSshCredsRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshCredsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshCredsRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshCredsRoleAsync(string role, SshCredsRequest sshCredsRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshCredsRole");

            // verify the required parameter 'sshCredsRequest' is set
            if (sshCredsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshCredsRequest' when calling Secrets->PostSshCredsRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshCredsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshCredsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshIssueRole(string role, SshIssueRequest sshIssueRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshIssueRole");

            // verify the required parameter 'sshIssueRequest' is set
            if (sshIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueRequest' when calling Secrets->PostSshIssueRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshIssueRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshIssueRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshIssueRoleAsync(string role, SshIssueRequest sshIssueRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshIssueRole");

            // verify the required parameter 'sshIssueRequest' is set
            if (sshIssueRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueRequest' when calling Secrets->PostSshIssueRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshIssueRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshIssueRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshKeysKeyName(string keyName, SshKeysRequest sshKeysRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->PostSshKeysKeyName");

            // verify the required parameter 'sshKeysRequest' is set
            if (sshKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshKeysRequest' when calling Secrets->PostSshKeysKeyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/keys/{key_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a shared private key with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyName">[Required] Name of the key</param>
        /// <param name="sshKeysRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshKeysKeyNameAsync(string keyName, SshKeysRequest sshKeysRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'keyName' is set
            if (keyName == null)
                throw new VaultApiException(400, "Missing required parameter 'keyName' when calling Secrets->PostSshKeysKeyName");

            // verify the required parameter 'sshKeysRequest' is set
            if (sshKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshKeysRequest' when calling Secrets->PostSshKeysKeyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key_name", ClientUtils.ParameterToString(keyName)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/keys/{key_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshKeysKeyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshLookup(SshLookupRequest sshLookupRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'sshLookupRequest' is set
            if (sshLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshLookupRequest' when calling Secrets->PostSshLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshLookupRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshLookupAsync(SshLookupRequest sshLookupRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshLookupRequest' is set
            if (sshLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshLookupRequest' when calling Secrets->PostSshLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshRolesRole(string role, SshRolesRequest sshRolesRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshRolesRole");

            // verify the required parameter 'sshRolesRequest' is set
            if (sshRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshRolesRequest' when calling Secrets->PostSshRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#39;roles&#39; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshRolesRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshRolesRoleAsync(string role, SshRolesRequest sshRolesRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshRolesRole");

            // verify the required parameter 'sshRolesRequest' is set
            if (sshRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshRolesRequest' when calling Secrets->PostSshRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshSignRole(string role, SshSignRequest sshSignRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshSignRole");

            // verify the required parameter 'sshSignRequest' is set
            if (sshSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignRequest' when calling Secrets->PostSshSignRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshSignRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshSignRoleAsync(string role, SshSignRequest sshSignRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PostSshSignRole");

            // verify the required parameter 'sshSignRequest' is set
            if (sshSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignRequest' when calling Secrets->PostSshSignRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshSignRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostSshVerify(SshVerifyRequest sshVerifyRequest, string sshMountPath = default(string))
        {
            // verify the required parameter 'sshVerifyRequest' is set
            if (sshVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyRequest' when calling Secrets->PostSshVerify");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyRequest"></param>
        /// <param name="sshMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ssh&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostSshVerifyAsync(SshVerifyRequest sshVerifyRequest, string sshMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'sshVerifyRequest' is set
            if (sshVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyRequest' when calling Secrets->PostSshVerify");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (sshMountPath != null)
            {
                requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter
            }
            requestOptions.Data = sshVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostSshVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformConfigRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTerraformConfig(TerraformConfigRequest terraformConfigRequest, string terraformMountPath = default(string))
        {
            // verify the required parameter 'terraformConfigRequest' is set
            if (terraformConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformConfigRequest' when calling Secrets->PostTerraformConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.Data = terraformConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformConfigRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTerraformConfigAsync(TerraformConfigRequest terraformConfigRequest, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'terraformConfigRequest' is set
            if (terraformConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformConfigRequest' when calling Secrets->PostTerraformConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.Data = terraformConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTerraformCredsName(string name, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformCredsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a Terraform Cloud or Enterprise API token from a specific Vault role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTerraformCredsNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformCredsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformRoleRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTerraformRoleName(string name, TerraformRoleRequest terraformRoleRequest, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformRoleName");

            // verify the required parameter 'terraformRoleRequest' is set
            if (terraformRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformRoleRequest' when calling Secrets->PostTerraformRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.Data = terraformRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformRoleRequest"></param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTerraformRoleNameAsync(string name, TerraformRoleRequest terraformRoleRequest, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformRoleName");

            // verify the required parameter 'terraformRoleRequest' is set
            if (terraformRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformRoleRequest' when calling Secrets->PostTerraformRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }
            requestOptions.Data = terraformRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTerraformRotateRoleName(string name, string terraformMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformRotateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;terraform&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTerraformRotateRoleNameAsync(string name, string terraformMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTerraformRotateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (terraformMountPath != null)
            {
                requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTerraformRotateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTotpCodeName(string name, TotpCodeRequest totpCodeRequest, string totpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTotpCodeName");

            // verify the required parameter 'totpCodeRequest' is set
            if (totpCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCodeRequest' when calling Secrets->PostTotpCodeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{totp_mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request time-based one-time use password or validate a password for a certain key . 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpCodeRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTotpCodeNameAsync(string name, TotpCodeRequest totpCodeRequest, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTotpCodeName");

            // verify the required parameter 'totpCodeRequest' is set
            if (totpCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCodeRequest' when calling Secrets->PostTotpCodeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.Data = totpCodeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{totp_mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTotpCodeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTotpKeysName(string name, TotpKeysRequest totpKeysRequest, string totpMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTotpKeysName");

            // verify the required parameter 'totpKeysRequest' is set
            if (totpKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpKeysRequest' when calling Secrets->PostTotpKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpKeysRequest"></param>
        /// <param name="totpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;totp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTotpKeysNameAsync(string name, TotpKeysRequest totpKeysRequest, string totpMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTotpKeysName");

            // verify the required parameter 'totpKeysRequest' is set
            if (totpKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpKeysRequest' when calling Secrets->PostTotpKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (totpMountPath != null)
            {
                requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter
            }
            requestOptions.Data = totpKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTotpKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitCacheConfig(TransitCacheConfigRequest transitCacheConfigRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'transitCacheConfigRequest' is set
            if (transitCacheConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCacheConfigRequest' when calling Secrets->PostTransitCacheConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCacheConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitCacheConfigAsync(TransitCacheConfigRequest transitCacheConfigRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitCacheConfigRequest' is set
            if (transitCacheConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCacheConfigRequest' when calling Secrets->PostTransitCacheConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitCacheConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitCacheConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitDatakeyPlaintextName(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->PostTransitDatakeyPlaintextName");

            // verify the required parameter 'transitDatakeyRequest' is set
            if (transitDatakeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDatakeyRequest' when calling Secrets->PostTransitDatakeyPlaintextName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/datakey/{plaintext}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitDatakeyPlaintextName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitDatakeyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitDatakeyPlaintextNameAsync(string name, string plaintext, TransitDatakeyRequest transitDatakeyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitDatakeyPlaintextName");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->PostTransitDatakeyPlaintextName");

            // verify the required parameter 'transitDatakeyRequest' is set
            if (transitDatakeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDatakeyRequest' when calling Secrets->PostTransitDatakeyPlaintextName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitDatakeyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/datakey/{plaintext}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitDatakeyPlaintextName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitDecryptName(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitDecryptName");

            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->PostTransitDecryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/decrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitDecryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitDecryptNameAsync(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitDecryptName");

            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->PostTransitDecryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitDecryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/decrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitDecryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitEncryptName(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitEncryptName");

            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->PostTransitEncryptName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/encrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitEncryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitEncryptNameAsync(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitEncryptName");

            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->PostTransitEncryptName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitEncryptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/encrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitEncryptName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitHash(TransitHashRequest transitHashRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->PostTransitHash");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hash", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitHashAsync(TransitHashRequest transitHashRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->PostTransitHash");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hash", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitHashUrlalgorithm(string urlalgorithm, TransitHashRequest transitHashRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitHashUrlalgorithm");

            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->PostTransitHashUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hash/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitHashUrlalgorithmAsync(string urlalgorithm, TransitHashRequest transitHashRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitHashUrlalgorithm");

            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->PostTransitHashUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hash/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitHmacName(string name, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitHmacName");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->PostTransitHmacName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hmac/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHmacName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitHmacNameAsync(string name, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitHmacName");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->PostTransitHmacName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hmac/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHmacName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitHmacNameUrlalgorithm(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitHmacNameUrlalgorithm");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->PostTransitHmacNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hmac/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHmacNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitHmacRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitHmacNameUrlalgorithmAsync(string name, string urlalgorithm, TransitHmacRequest transitHmacRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitHmacNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitHmacNameUrlalgorithm");

            // verify the required parameter 'transitHmacRequest' is set
            if (transitHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHmacRequest' when calling Secrets->PostTransitHmacNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitHmacRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hmac/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitHmacNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysName(string name, TransitKeysRequest transitKeysRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysName");

            // verify the required parameter 'transitKeysRequest' is set
            if (transitKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysRequest' when calling Secrets->PostTransitKeysName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameAsync(string name, TransitKeysRequest transitKeysRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysName");

            // verify the required parameter 'transitKeysRequest' is set
            if (transitKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysRequest' when calling Secrets->PostTransitKeysName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysNameConfig(string name, TransitKeysConfigRequest transitKeysConfigRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameConfig");

            // verify the required parameter 'transitKeysConfigRequest' is set
            if (transitKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysConfigRequest' when calling Secrets->PostTransitKeysNameConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysConfigRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameConfigAsync(string name, TransitKeysConfigRequest transitKeysConfigRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameConfig");

            // verify the required parameter 'transitKeysConfigRequest' is set
            if (transitKeysConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysConfigRequest' when calling Secrets->PostTransitKeysNameConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysNameImport(string name, TransitKeysImportRequest transitKeysImportRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameImport");

            // verify the required parameter 'transitKeysImportRequest' is set
            if (transitKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportRequest' when calling Secrets->PostTransitKeysNameImport");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameImportAsync(string name, TransitKeysImportRequest transitKeysImportRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameImport");

            // verify the required parameter 'transitKeysImportRequest' is set
            if (transitKeysImportRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportRequest' when calling Secrets->PostTransitKeysNameImport");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysImportRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameImport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysNameImportVersion(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameImportVersion");

            // verify the required parameter 'transitKeysImportVersionRequest' is set
            if (transitKeysImportVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportVersionRequest' when calling Secrets->PostTransitKeysNameImportVersion");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/import_version", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameImportVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the key</param>
        /// <param name="transitKeysImportVersionRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameImportVersionAsync(string name, TransitKeysImportVersionRequest transitKeysImportVersionRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameImportVersion");

            // verify the required parameter 'transitKeysImportVersionRequest' is set
            if (transitKeysImportVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysImportVersionRequest' when calling Secrets->PostTransitKeysNameImportVersion");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysImportVersionRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/import_version", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameImportVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysNameRotate(string name, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameRotate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameRotateAsync(string name, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameRotate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitKeysNameTrim(string name, TransitKeysTrimRequest transitKeysTrimRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameTrim");

            // verify the required parameter 'transitKeysTrimRequest' is set
            if (transitKeysTrimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysTrimRequest' when calling Secrets->PostTransitKeysNameTrim");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/trim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameTrim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitKeysTrimRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitKeysNameTrimAsync(string name, TransitKeysTrimRequest transitKeysTrimRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitKeysNameTrim");

            // verify the required parameter 'transitKeysTrimRequest' is set
            if (transitKeysTrimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitKeysTrimRequest' when calling Secrets->PostTransitKeysNameTrim");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitKeysTrimRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/trim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitKeysNameTrim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRandom(TransitRandomRequest transitRandomRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandom");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRandomAsync(TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandom");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRandomSource(string source, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->PostTransitRandomSource");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomSource");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRandomSourceAsync(string source, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->PostTransitRandomSource");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomSource");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRandomSourceUrlbytes(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->PostTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->PostTransitRandomSourceUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomSourceUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{source}/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRandomSourceUrlbytesAsync(string source, string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->PostTransitRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->PostTransitRandomSourceUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomSourceUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{source}/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRandomUrlbytes(string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->PostTransitRandomUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitRandomRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRandomUrlbytesAsync(string urlbytes, TransitRandomRequest transitRandomRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->PostTransitRandomUrlbytes");

            // verify the required parameter 'transitRandomRequest' is set
            if (transitRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRandomRequest' when calling Secrets->PostTransitRandomUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = transitRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRestore(TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->PostTransitRestore");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/restore", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRestore", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRestoreAsync(TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->PostTransitRestore");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/restore", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRestore", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRestoreName(string name, TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitRestoreName");

            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->PostTransitRestoreName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/restore/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRestoreName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitRestoreRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRestoreNameAsync(string name, TransitRestoreRequest transitRestoreRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitRestoreName");

            // verify the required parameter 'transitRestoreRequest' is set
            if (transitRestoreRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreRequest' when calling Secrets->PostTransitRestoreName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRestoreRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/restore/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRestoreName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitRewrapName(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitRewrapName");

            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->PostTransitRewrapName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/rewrap/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRewrapName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitRewrapNameAsync(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitRewrapName");

            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->PostTransitRewrapName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitRewrapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/rewrap/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitRewrapName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitSignName(string name, TransitSignRequest transitSignRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitSignName");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->PostTransitSignName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/sign/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitSignName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitSignNameAsync(string name, TransitSignRequest transitSignRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitSignName");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->PostTransitSignName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/sign/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitSignName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitSignNameUrlalgorithm(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitSignNameUrlalgorithm");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->PostTransitSignNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/sign/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitSignNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitSignRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitSignNameUrlalgorithmAsync(string name, string urlalgorithm, TransitSignRequest transitSignRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitSignNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitSignNameUrlalgorithm");

            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->PostTransitSignNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitSignRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/sign/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitSignNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitVerifyName(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitVerifyName");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->PostTransitVerifyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/verify/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitVerifyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitVerifyNameAsync(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitVerifyName");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->PostTransitVerifyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/verify/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitVerifyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> PostTransitVerifyNameUrlalgorithm(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->PostTransitVerifyNameUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/verify/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitVerifyNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="transitMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;transit&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostTransitVerifyNameUrlalgorithmAsync(string name, string urlalgorithm, TransitVerifyRequest transitVerifyRequest, string transitMountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PostTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->PostTransitVerifyNameUrlalgorithm");

            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->PostTransitVerifyNameUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (transitMountPath != null)
            {
                requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = transitVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/verify/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostTransitVerifyNameUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }

    }
}
