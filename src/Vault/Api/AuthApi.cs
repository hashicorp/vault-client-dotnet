// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
//
// Code generated with OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthSync : IApiAccessor
    {
        #region Synchronous Operations

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudDeleteAuthRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudListAuthRoles(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Authenticates an RAM entity with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudLogin(AliCloudLoginRequest aliCloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudReadAuthRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteAuthRoleRequest"></param>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudWriteAuthRole(string role, AliCloudWriteAuthRoleRequest aliCloudWriteAuthRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeletePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeletePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteRole(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDeleteTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDestroySecretId(string roleName, AppRoleDestroySecretIdRequest appRoleDestroySecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleDestroySecretIdByAccessor(string roleName, AppRoleDestroySecretIdByAccessorRequest appRoleDestroySecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleListRolesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleListRolesResponse> AppRoleListRoles(string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleListSecretIdsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleListSecretIdsResponse> AppRoleListSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLoginRequest"></param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleLogin(AppRoleLoginRequest appRoleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleLookUpSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleLookUpSecretIdResponse> AppRoleLookUpSecretId(string roleName, AppRoleLookUpSecretIdRequest appRoleLookUpSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleLookUpSecretIdByAccessorResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleLookUpSecretIdByAccessorResponse> AppRoleLookUpSecretIdByAccessor(string roleName, AppRoleLookUpSecretIdByAccessorRequest appRoleLookUpSecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadBindSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadBindSecretIdResponse> AppRoleReadBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadBoundCidrListResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadBoundCidrListResponse> AppRoleReadBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadLocalSecretIdsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadLocalSecretIdsResponse> AppRoleReadLocalSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadPeriodResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadPeriodResponse> AppRoleReadPeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadPoliciesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadPoliciesResponse> AppRoleReadPolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadRoleResponse> AppRoleReadRole(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadRoleIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadRoleIdResponse> AppRoleReadRoleId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdBoundCidrsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadSecretIdBoundCidrsResponse> AppRoleReadSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdNumUsesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadSecretIdNumUsesResponse> AppRoleReadSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadSecretIdTtlResponse> AppRoleReadSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenBoundCidrsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadTokenBoundCidrsResponse> AppRoleReadTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenMaxTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadTokenMaxTtlResponse> AppRoleReadTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenNumUsesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadTokenNumUsesResponse> AppRoleReadTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleReadTokenTtlResponse> AppRoleReadTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleTidySecretId(string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBindSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteBindSecretId(string roleName, AppRoleWriteBindSecretIdRequest appRoleWriteBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBoundCidrListRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteBoundCidrList(string roleName, AppRoleWriteBoundCidrListRequest appRoleWriteBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteCustomSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleWriteCustomSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleWriteCustomSecretIdResponse> AppRoleWriteCustomSecretId(string roleName, AppRoleWriteCustomSecretIdRequest appRoleWriteCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePeriodRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWritePeriod(string roleName, AppRoleWritePeriodRequest appRoleWritePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePoliciesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWritePolicies(string roleName, AppRoleWritePoliciesRequest appRoleWritePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteRole(string roleName, AppRoleWriteRoleRequest appRoleWriteRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteRoleId(string roleName, AppRoleWriteRoleIdRequest appRoleWriteRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleWriteSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AppRoleWriteSecretIdResponse> AppRoleWriteSecretId(string roleName, AppRoleWriteSecretIdRequest appRoleWriteSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteSecretIdBoundCidrs(string roleName, AppRoleWriteSecretIdBoundCidrsRequest appRoleWriteSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteSecretIdNumUses(string roleName, AppRoleWriteSecretIdNumUsesRequest appRoleWriteSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteSecretIdTtl(string roleName, AppRoleWriteSecretIdTtlRequest appRoleWriteSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteTokenBoundCidrs(string roleName, AppRoleWriteTokenBoundCidrsRequest appRoleWriteTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenMaxTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteTokenMaxTtl(string roleName, AppRoleWriteTokenMaxTtlRequest appRoleWriteTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteTokenNumUses(string roleName, AppRoleWriteTokenNumUsesRequest appRoleWriteTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AppRoleWriteTokenTtl(string roleName, AppRoleWriteTokenTtlRequest appRoleWriteTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureCertificateRequest"></param>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureCertificate(string certName, AwsConfigureCertificateRequest awsConfigureCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureClientRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureClient(AwsConfigureClientRequest awsConfigureClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityAccessListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureIdentityAccessListTidyOperation(AwsConfigureIdentityAccessListTidyOperationRequest awsConfigureIdentityAccessListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityIntegrationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureIdentityIntegration(AwsConfigureIdentityIntegrationRequest awsConfigureIdentityIntegrationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityWhitelistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureIdentityWhitelistTidyOperation(AwsConfigureIdentityWhitelistTidyOperationRequest awsConfigureIdentityWhitelistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagBlacklistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureRoleTagBlacklistTidyOperation(AwsConfigureRoleTagBlacklistTidyOperationRequest awsConfigureRoleTagBlacklistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagDenyListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureRoleTagDenyListTidyOperation(AwsConfigureRoleTagDenyListTidyOperationRequest awsConfigureRoleTagDenyListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteAuthRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteCertificateConfiguration(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteClientConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteIdentityAccessList(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteIdentityAccessListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteIdentityWhitelist(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteIdentityWhitelistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteRoleTagBlacklistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteRoleTagDenyListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteStsRole(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListAuthRoles(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListCertificateConfigurations(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListIdentityAccessList(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListRoleTagBlacklists(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListRoleTagDenyLists(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListStsRoleRelationships(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsLogin(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadAuthRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadCertificateConfiguration(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadClientConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadIdentityAccessList(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadIdentityAccessListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadIdentityIntegrationConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadIdentityWhitelist(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadIdentityWhitelistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRoleTagBlacklistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRoleTagDenyListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadStsRole(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsRotateRootCredentials(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccessListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsTidyIdentityAccessList(AwsTidyIdentityAccessListRequest awsTidyIdentityAccessListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsTidyRoleTagBlacklist(AwsTidyRoleTagBlacklistRequest awsTidyRoleTagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagDenyListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsTidyRoleTagDenyList(AwsTidyRoleTagDenyListRequest awsTidyRoleTagDenyListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteAuthRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteAuthRole(string role, AwsWriteAuthRoleRequest awsWriteAuthRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleTagRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteRoleTag(string role, AwsWriteRoleTagRequest awsWriteRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStsRoleRequest"></param>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteStsRole(string accountId, AwsWriteStsRoleRequest awsWriteStsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureAuthRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureConfigureAuth(AzureConfigureAuthRequest azureConfigureAuthRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureDeleteAuthConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureDeleteAuthRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureListAuthRoles(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureLogin(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureReadAuthConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureReadAuthRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureRotateRootCredentials(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureWriteAuthRole(string name, AzureWriteAuthRoleRequest azureWriteAuthRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigureRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CentrifyConfigure(CentrifyConfigureRequest centrifyConfigureRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CentrifyLogin(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CentrifyReadConfiguration(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigureRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertConfigure(CertConfigureRequest certConfigureRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertDeleteCertificate(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertDeleteCrl(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertListCertificates(string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertListCrls(string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertLogin(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertReadCertificate(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertReadConfiguration(string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertReadCrl(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCertificateRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertWriteCertificate(string name, CertWriteCertificateRequest certWriteCertificateRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCrlRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CertWriteCrl(string name, CertWriteCrlRequest certWriteCrlRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryConfigureRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryConfigure(CloudFoundryConfigureRequest cloudFoundryConfigureRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryDeleteConfiguration(string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryDeleteRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryListRoles(string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryLoginRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryLogin(CloudFoundryLoginRequest cloudFoundryLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryReadConfiguration(string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryReadRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryWriteRoleRequest"></param>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CloudFoundryWriteRole(string role, CloudFoundryWriteRoleRequest cloudFoundryWriteRoleRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigureRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubConfigure(GithubConfigureRequest githubConfigureRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubDeleteTeamMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubDeleteUserMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubListTeams(string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubListUsers(string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubLogin(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubReadConfiguration(string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubReadTeamMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubReadUserMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteTeamMappingRequest"></param>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubWriteTeamMapping(string key, GithubWriteTeamMappingRequest githubWriteTeamMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteUserMappingRequest"></param>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GithubWriteUserMapping(string key, GithubWriteUserMappingRequest githubWriteUserMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureAuthRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudConfigureAuth(GoogleCloudConfigureAuthRequest googleCloudConfigureAuthRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudDeleteRole(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Add or remove labels for an existing &#x27;gce&#x27; role
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditLabelsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudEditLabelsForRole(string name, GoogleCloudEditLabelsForRoleRequest googleCloudEditLabelsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditServiceAccountsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudEditServiceAccountsForRole(string name, GoogleCloudEditServiceAccountsForRoleRequest googleCloudEditServiceAccountsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudListRoles(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudLoginRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudLogin(GoogleCloudLoginRequest googleCloudLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadAuthConfiguration(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadRole(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudWriteRole(string name, GoogleCloudWriteRoleRequest googleCloudWriteRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigureRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtConfigure(JwtConfigureRequest jwtConfigureRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtDeleteRole(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtListRoles(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtLogin(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtOidcCallback(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackWithParametersRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtOidcCallbackWithParameters(JwtOidcCallbackWithParametersRequest jwtOidcCallbackWithParametersRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcRequestAuthorizationUrlRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtOidcRequestAuthorizationUrl(JwtOidcRequestAuthorizationUrlRequest jwtOidcRequestAuthorizationUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtReadConfiguration(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtReadRole(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> JwtWriteRole(string name, JwtWriteRoleRequest jwtWriteRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosConfigure(KerberosConfigureRequest kerberosConfigureRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureLdapRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosConfigureLdap(KerberosConfigureLdapRequest kerberosConfigureLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosDeleteGroup(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosListGroups(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosLogin(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosReadConfiguration(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosReadGroup(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosReadLdapConfiguration(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KerberosWriteGroup(string name, KerberosWriteGroupRequest kerberosWriteGroupRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureAuthRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesConfigureAuth(KubernetesConfigureAuthRequest kubernetesConfigureAuthRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesDeleteAuthRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesListAuthRoles(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesReadAuthConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesReadAuthRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesWriteAuthRole(string name, KubernetesWriteAuthRoleRequest kubernetesWriteAuthRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureAuthRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapConfigureAuth(LdapConfigureAuthRequest ldapConfigureAuthRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapDeleteGroup(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapDeleteUser(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapListGroups(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapListUsers(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLogin(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadAuthConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadGroup(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadUser(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapWriteGroup(string name, LdapWriteGroupRequest ldapWriteGroupRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteUserRequest"></param>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapWriteUser(string name, LdapWriteUserRequest ldapWriteUserRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigureRequest"></param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciConfigure(OciConfigureRequest ociConfigureRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciDeleteConfiguration(string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciDeleteRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciListRoles(string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociLoginRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciLogin(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciReadConfiguration(string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciReadRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociWriteRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OciWriteRole(string role, OciWriteRoleRequest ociWriteRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigureRequest"></param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaConfigure(OktaConfigureRequest oktaConfigureRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaDeleteGroup(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaDeleteUser(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaListGroups(string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaListUsers(string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaLogin(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaReadConfiguration(string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaReadGroup(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaReadUser(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaVerify(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteGroupRequest"></param>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaWriteGroup(string name, OktaWriteGroupRequest oktaWriteGroupRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteUserRequest"></param>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> OktaWriteUser(string name, OktaWriteUserRequest oktaWriteUserRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigureRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusConfigure(RadiusConfigureRequest radiusConfigureRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusDeleteUser(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusListUsers(string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusLogin(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginWithUsernameRequest"></param>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusLoginWithUsername(string urlusername, RadiusLoginWithUsernameRequest radiusLoginWithUsernameRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusReadConfiguration(string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusReadUser(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusWriteUserRequest"></param>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RadiusWriteUser(string name, RadiusWriteUserRequest radiusWriteUserRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);

        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenCreate(TokenCreateRequest tokenCreateRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateAgainstRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenCreateAgainstRole(string roleName, TokenCreateAgainstRoleRequest tokenCreateAgainstRoleRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenDeleteRole(string roleName, TimeSpan? wrapTTL = null);

        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#x27;sudo&#x27; capability in addition to &#x27;list&#x27;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenListAccessors(TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint lists configured roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenListRoles(TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenLookUp(TokenLookUpRequest tokenLookUpRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenLookUpAccessor(TokenLookUpAccessorRequest tokenLookUpAccessorRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenLookUpSelf(TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenReadRole(string roleName, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRenew(TokenRenewRequest tokenRenewRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRevoke(TokenRevokeRequest tokenRevokeRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenRevokeSelf(TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenTidy(TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TokenWriteRole(string roleName, TokenWriteRoleRequest tokenWriteRoleRequest, TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassDeleteUser(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassListUsers(string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassLogin(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassReadUser(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Reset user&#x27;s password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassResetPasswordRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassResetPassword(string username, UserpassResetPasswordRequest userpassResetPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassUpdatePoliciesRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassUpdatePolicies(string username, UserpassUpdatePoliciesRequest userpassUpdatePoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassWriteUserRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> UserpassWriteUser(string username, UserpassWriteUserRequest userpassWriteUserRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);

        #endregion Synchronous Operations
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthAsync : IApiAccessor
    {
        #region Asynchronous Operations

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudDeleteAuthRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudListAuthRolesAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Authenticates an RAM entity with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudLoginAsync(AliCloudLoginRequest aliCloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudReadAuthRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteAuthRoleRequest"></param>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudWriteAuthRoleAsync(string role, AliCloudWriteAuthRoleRequest aliCloudWriteAuthRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeletePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeletePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteRoleAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDeleteTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDestroySecretIdAsync(string roleName, AppRoleDestroySecretIdRequest appRoleDestroySecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleDestroySecretIdByAccessorAsync(string roleName, AppRoleDestroySecretIdByAccessorRequest appRoleDestroySecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleListRolesResponse)</returns>
        Task<VaultResponse<AppRoleListRolesResponse>> AppRoleListRolesAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleListSecretIdsResponse)</returns>
        Task<VaultResponse<AppRoleListSecretIdsResponse>> AppRoleListSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLoginRequest"></param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleLoginAsync(AppRoleLoginRequest appRoleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleLookUpSecretIdResponse)</returns>
        Task<VaultResponse<AppRoleLookUpSecretIdResponse>> AppRoleLookUpSecretIdAsync(string roleName, AppRoleLookUpSecretIdRequest appRoleLookUpSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleLookUpSecretIdByAccessorResponse)</returns>
        Task<VaultResponse<AppRoleLookUpSecretIdByAccessorResponse>> AppRoleLookUpSecretIdByAccessorAsync(string roleName, AppRoleLookUpSecretIdByAccessorRequest appRoleLookUpSecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadBindSecretIdResponse)</returns>
        Task<VaultResponse<AppRoleReadBindSecretIdResponse>> AppRoleReadBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadBoundCidrListResponse)</returns>
        Task<VaultResponse<AppRoleReadBoundCidrListResponse>> AppRoleReadBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadLocalSecretIdsResponse)</returns>
        Task<VaultResponse<AppRoleReadLocalSecretIdsResponse>> AppRoleReadLocalSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadPeriodResponse)</returns>
        Task<VaultResponse<AppRoleReadPeriodResponse>> AppRoleReadPeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadPoliciesResponse)</returns>
        Task<VaultResponse<AppRoleReadPoliciesResponse>> AppRoleReadPoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadRoleResponse)</returns>
        Task<VaultResponse<AppRoleReadRoleResponse>> AppRoleReadRoleAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadRoleIdResponse)</returns>
        Task<VaultResponse<AppRoleReadRoleIdResponse>> AppRoleReadRoleIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdBoundCidrsResponse)</returns>
        Task<VaultResponse<AppRoleReadSecretIdBoundCidrsResponse>> AppRoleReadSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdNumUsesResponse)</returns>
        Task<VaultResponse<AppRoleReadSecretIdNumUsesResponse>> AppRoleReadSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdTtlResponse)</returns>
        Task<VaultResponse<AppRoleReadSecretIdTtlResponse>> AppRoleReadSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenBoundCidrsResponse)</returns>
        Task<VaultResponse<AppRoleReadTokenBoundCidrsResponse>> AppRoleReadTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenMaxTtlResponse)</returns>
        Task<VaultResponse<AppRoleReadTokenMaxTtlResponse>> AppRoleReadTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenNumUsesResponse)</returns>
        Task<VaultResponse<AppRoleReadTokenNumUsesResponse>> AppRoleReadTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenTtlResponse)</returns>
        Task<VaultResponse<AppRoleReadTokenTtlResponse>> AppRoleReadTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleTidySecretIdAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBindSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteBindSecretIdAsync(string roleName, AppRoleWriteBindSecretIdRequest appRoleWriteBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBoundCidrListRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteBoundCidrListAsync(string roleName, AppRoleWriteBoundCidrListRequest appRoleWriteBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteCustomSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleWriteCustomSecretIdResponse)</returns>
        Task<VaultResponse<AppRoleWriteCustomSecretIdResponse>> AppRoleWriteCustomSecretIdAsync(string roleName, AppRoleWriteCustomSecretIdRequest appRoleWriteCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePeriodRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWritePeriodAsync(string roleName, AppRoleWritePeriodRequest appRoleWritePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePoliciesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWritePoliciesAsync(string roleName, AppRoleWritePoliciesRequest appRoleWritePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteRoleAsync(string roleName, AppRoleWriteRoleRequest appRoleWriteRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteRoleIdAsync(string roleName, AppRoleWriteRoleIdRequest appRoleWriteRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleWriteSecretIdResponse)</returns>
        Task<VaultResponse<AppRoleWriteSecretIdResponse>> AppRoleWriteSecretIdAsync(string roleName, AppRoleWriteSecretIdRequest appRoleWriteSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteSecretIdBoundCidrsAsync(string roleName, AppRoleWriteSecretIdBoundCidrsRequest appRoleWriteSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteSecretIdNumUsesAsync(string roleName, AppRoleWriteSecretIdNumUsesRequest appRoleWriteSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteSecretIdTtlAsync(string roleName, AppRoleWriteSecretIdTtlRequest appRoleWriteSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteTokenBoundCidrsAsync(string roleName, AppRoleWriteTokenBoundCidrsRequest appRoleWriteTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenMaxTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteTokenMaxTtlAsync(string roleName, AppRoleWriteTokenMaxTtlRequest appRoleWriteTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteTokenNumUsesAsync(string roleName, AppRoleWriteTokenNumUsesRequest appRoleWriteTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AppRoleWriteTokenTtlAsync(string roleName, AppRoleWriteTokenTtlRequest appRoleWriteTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureCertificateRequest"></param>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureCertificateAsync(string certName, AwsConfigureCertificateRequest awsConfigureCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureClientRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureClientAsync(AwsConfigureClientRequest awsConfigureClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityAccessListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureIdentityAccessListTidyOperationAsync(AwsConfigureIdentityAccessListTidyOperationRequest awsConfigureIdentityAccessListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityIntegrationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureIdentityIntegrationAsync(AwsConfigureIdentityIntegrationRequest awsConfigureIdentityIntegrationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityWhitelistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureIdentityWhitelistTidyOperationAsync(AwsConfigureIdentityWhitelistTidyOperationRequest awsConfigureIdentityWhitelistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagBlacklistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureRoleTagBlacklistTidyOperationAsync(AwsConfigureRoleTagBlacklistTidyOperationRequest awsConfigureRoleTagBlacklistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagDenyListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureRoleTagDenyListTidyOperationAsync(AwsConfigureRoleTagDenyListTidyOperationRequest awsConfigureRoleTagDenyListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteAuthRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteCertificateConfigurationAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteClientConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteIdentityAccessListAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteIdentityAccessListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteIdentityWhitelistAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteIdentityWhitelistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteRoleTagBlacklistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteRoleTagDenyListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteStsRoleAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListAuthRolesAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListCertificateConfigurationsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListIdentityAccessListAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListRoleTagBlacklistsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListRoleTagDenyListsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListStsRoleRelationshipsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsLoginAsync(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadAuthRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadCertificateConfigurationAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadClientConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadIdentityAccessListAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadIdentityAccessListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadIdentityIntegrationConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadIdentityWhitelistAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadIdentityWhitelistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRoleTagBlacklistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRoleTagDenyListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadStsRoleAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsRotateRootCredentialsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccessListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsTidyIdentityAccessListAsync(AwsTidyIdentityAccessListRequest awsTidyIdentityAccessListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsTidyRoleTagBlacklistAsync(AwsTidyRoleTagBlacklistRequest awsTidyRoleTagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagDenyListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsTidyRoleTagDenyListAsync(AwsTidyRoleTagDenyListRequest awsTidyRoleTagDenyListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteAuthRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteAuthRoleAsync(string role, AwsWriteAuthRoleRequest awsWriteAuthRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleTagRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteRoleTagAsync(string role, AwsWriteRoleTagRequest awsWriteRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStsRoleRequest"></param>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteStsRoleAsync(string accountId, AwsWriteStsRoleRequest awsWriteStsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureAuthRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureConfigureAuthAsync(AzureConfigureAuthRequest azureConfigureAuthRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureDeleteAuthConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureDeleteAuthRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureListAuthRolesAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureLoginAsync(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureReadAuthConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureReadAuthRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureRotateRootCredentialsAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureWriteAuthRoleAsync(string name, AzureWriteAuthRoleRequest azureWriteAuthRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigureRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CentrifyConfigureAsync(CentrifyConfigureRequest centrifyConfigureRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CentrifyLoginAsync(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CentrifyReadConfigurationAsync(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigureRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertConfigureAsync(CertConfigureRequest certConfigureRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertDeleteCertificateAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertDeleteCrlAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertListCertificatesAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertListCrlsAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertLoginAsync(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertReadCertificateAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertReadConfigurationAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertReadCrlAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCertificateRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertWriteCertificateAsync(string name, CertWriteCertificateRequest certWriteCertificateRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCrlRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CertWriteCrlAsync(string name, CertWriteCrlRequest certWriteCrlRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryConfigureRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryConfigureAsync(CloudFoundryConfigureRequest cloudFoundryConfigureRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryDeleteConfigurationAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryDeleteRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryListRolesAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryLoginRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryLoginAsync(CloudFoundryLoginRequest cloudFoundryLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryReadConfigurationAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryReadRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryWriteRoleRequest"></param>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CloudFoundryWriteRoleAsync(string role, CloudFoundryWriteRoleRequest cloudFoundryWriteRoleRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigureRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubConfigureAsync(GithubConfigureRequest githubConfigureRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubDeleteTeamMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubDeleteUserMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubListTeamsAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubListUsersAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubLoginAsync(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubReadConfigurationAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubReadTeamMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubReadUserMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteTeamMappingRequest"></param>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubWriteTeamMappingAsync(string key, GithubWriteTeamMappingRequest githubWriteTeamMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteUserMappingRequest"></param>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GithubWriteUserMappingAsync(string key, GithubWriteUserMappingRequest githubWriteUserMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureAuthRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudConfigureAuthAsync(GoogleCloudConfigureAuthRequest googleCloudConfigureAuthRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudDeleteRoleAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add or remove labels for an existing &#x27;gce&#x27; role
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditLabelsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudEditLabelsForRoleAsync(string name, GoogleCloudEditLabelsForRoleRequest googleCloudEditLabelsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditServiceAccountsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudEditServiceAccountsForRoleAsync(string name, GoogleCloudEditServiceAccountsForRoleRequest googleCloudEditServiceAccountsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudListRolesAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudLoginRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudLoginAsync(GoogleCloudLoginRequest googleCloudLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadAuthConfigurationAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadRoleAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudWriteRoleAsync(string name, GoogleCloudWriteRoleRequest googleCloudWriteRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigureRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtConfigureAsync(JwtConfigureRequest jwtConfigureRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtDeleteRoleAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtListRolesAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtLoginAsync(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtOidcCallbackAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackWithParametersRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtOidcCallbackWithParametersAsync(JwtOidcCallbackWithParametersRequest jwtOidcCallbackWithParametersRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcRequestAuthorizationUrlRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtOidcRequestAuthorizationUrlAsync(JwtOidcRequestAuthorizationUrlRequest jwtOidcRequestAuthorizationUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtReadConfigurationAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtReadRoleAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> JwtWriteRoleAsync(string name, JwtWriteRoleRequest jwtWriteRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosConfigureAsync(KerberosConfigureRequest kerberosConfigureRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureLdapRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosConfigureLdapAsync(KerberosConfigureLdapRequest kerberosConfigureLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosDeleteGroupAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosListGroupsAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosLoginAsync(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosReadConfigurationAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosReadGroupAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosReadLdapConfigurationAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KerberosWriteGroupAsync(string name, KerberosWriteGroupRequest kerberosWriteGroupRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureAuthRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesConfigureAuthAsync(KubernetesConfigureAuthRequest kubernetesConfigureAuthRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesDeleteAuthRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesListAuthRolesAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesReadAuthConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesReadAuthRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesWriteAuthRoleAsync(string name, KubernetesWriteAuthRoleRequest kubernetesWriteAuthRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureAuthRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapConfigureAuthAsync(LdapConfigureAuthRequest ldapConfigureAuthRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapDeleteGroupAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapDeleteUserAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapListGroupsAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapListUsersAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLoginAsync(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadAuthConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadGroupAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadUserAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapWriteGroupAsync(string name, LdapWriteGroupRequest ldapWriteGroupRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteUserRequest"></param>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapWriteUserAsync(string name, LdapWriteUserRequest ldapWriteUserRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigureRequest"></param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciConfigureAsync(OciConfigureRequest ociConfigureRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciDeleteConfigurationAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciDeleteRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciListRolesAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociLoginRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciLoginAsync(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciReadConfigurationAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciReadRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociWriteRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OciWriteRoleAsync(string role, OciWriteRoleRequest ociWriteRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigureRequest"></param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaConfigureAsync(OktaConfigureRequest oktaConfigureRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaDeleteGroupAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaDeleteUserAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaListGroupsAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaListUsersAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaLoginAsync(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaReadConfigurationAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaReadGroupAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaReadUserAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaVerifyAsync(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteGroupRequest"></param>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaWriteGroupAsync(string name, OktaWriteGroupRequest oktaWriteGroupRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteUserRequest"></param>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> OktaWriteUserAsync(string name, OktaWriteUserRequest oktaWriteUserRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigureRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusConfigureAsync(RadiusConfigureRequest radiusConfigureRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusDeleteUserAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusListUsersAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusLoginAsync(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginWithUsernameRequest"></param>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusLoginWithUsernameAsync(string urlusername, RadiusLoginWithUsernameRequest radiusLoginWithUsernameRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusReadConfigurationAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusReadUserAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusWriteUserRequest"></param>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RadiusWriteUserAsync(string name, RadiusWriteUserRequest radiusWriteUserRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenCreateAsync(TokenCreateRequest tokenCreateRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateAgainstRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenCreateAgainstRoleAsync(string roleName, TokenCreateAgainstRoleRequest tokenCreateAgainstRoleRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenDeleteRoleAsync(string roleName, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#x27;sudo&#x27; capability in addition to &#x27;list&#x27;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenListAccessorsAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint lists configured roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenListRolesAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenLookUpAsync(TokenLookUpRequest tokenLookUpRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenLookUpAccessorAsync(TokenLookUpAccessorRequest tokenLookUpAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenLookUpSelfAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenReadRoleAsync(string roleName, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRenewAsync(TokenRenewRequest tokenRenewRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenRevokeSelfAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenTidyAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TokenWriteRoleAsync(string roleName, TokenWriteRoleRequest tokenWriteRoleRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassDeleteUserAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassListUsersAsync(string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassLoginAsync(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassReadUserAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Reset user&#x27;s password.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassResetPasswordRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassResetPasswordAsync(string username, UserpassResetPasswordRequest userpassResetPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassUpdatePoliciesRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassUpdatePoliciesAsync(string username, UserpassUpdatePoliciesRequest userpassUpdatePoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassWriteUserRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UserpassWriteUserAsync(string username, UserpassWriteUserRequest userpassWriteUserRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        #endregion Asynchronous Operations
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuth : IAuthSync, IAuthAsync { }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Auth : IAuth
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Auth
        /// </summary>
        public Auth(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");

            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = VaultConfiguration.DefaultExceptionFactory;
        }


        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }


        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public VaultConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudDeleteAuthRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudDeleteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudDeleteAuthRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudDeleteAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudListAuthRoles(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{alicloud_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudListAuthRolesAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{alicloud_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Authenticates an RAM entity with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudLogin(AliCloudLoginRequest aliCloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'aliCloudLoginRequest' is set
            if (aliCloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudLoginRequest' when calling Auth->AliCloudLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter





            requestOptions.Data = aliCloudLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{alicloud_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates an RAM entity with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudLoginAsync(AliCloudLoginRequest aliCloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'aliCloudLoginRequest' is set
            if (aliCloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudLoginRequest' when calling Auth->AliCloudLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.Data = aliCloudLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{alicloud_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudReadAuthRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudReadAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudReadAuthRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudReadAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteAuthRoleRequest"></param>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudWriteAuthRole(string role, AliCloudWriteAuthRoleRequest aliCloudWriteAuthRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudWriteAuthRole");


            // verify the required parameter 'aliCloudWriteAuthRoleRequest' is set
            if (aliCloudWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudWriteAuthRoleRequest' when calling Auth->AliCloudWriteAuthRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter





            requestOptions.Data = aliCloudWriteAuthRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteAuthRoleRequest"></param>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudWriteAuthRoleAsync(string role, AliCloudWriteAuthRoleRequest aliCloudWriteAuthRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AliCloudWriteAuthRole");


            // verify the required parameter 'aliCloudWriteAuthRoleRequest' is set
            if (aliCloudWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudWriteAuthRoleRequest' when calling Auth->AliCloudWriteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.Data = aliCloudWriteAuthRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteBindSecretId");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteBoundCidrList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeletePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeletePeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeletePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeletePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeletePeriod");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeletePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeletePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeletePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeletePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeletePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeletePolicies");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeletePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteRole(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteRoleAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdBoundCidrs");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdNumUses");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteSecretIdTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenBoundCidrs");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenMaxTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenNumUses");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDeleteTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDeleteTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDeleteTokenTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDeleteTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDestroySecretId(string roleName, AppRoleDestroySecretIdRequest appRoleDestroySecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDestroySecretId");


            // verify the required parameter 'appRoleDestroySecretIdRequest' is set
            if (appRoleDestroySecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleDestroySecretIdRequest' when calling Auth->AppRoleDestroySecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleDestroySecretIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDestroySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDestroySecretIdAsync(string roleName, AppRoleDestroySecretIdRequest appRoleDestroySecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDestroySecretId");


            // verify the required parameter 'appRoleDestroySecretIdRequest' is set
            if (appRoleDestroySecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleDestroySecretIdRequest' when calling Auth->AppRoleDestroySecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleDestroySecretIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDestroySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleDestroySecretIdByAccessor(string roleName, AppRoleDestroySecretIdByAccessorRequest appRoleDestroySecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDestroySecretIdByAccessor");


            // verify the required parameter 'appRoleDestroySecretIdByAccessorRequest' is set
            if (appRoleDestroySecretIdByAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleDestroySecretIdByAccessorRequest' when calling Auth->AppRoleDestroySecretIdByAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleDestroySecretIdByAccessorRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDestroySecretIdByAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleDestroySecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleDestroySecretIdByAccessorAsync(string roleName, AppRoleDestroySecretIdByAccessorRequest appRoleDestroySecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleDestroySecretIdByAccessor");


            // verify the required parameter 'appRoleDestroySecretIdByAccessorRequest' is set
            if (appRoleDestroySecretIdByAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleDestroySecretIdByAccessorRequest' when calling Auth->AppRoleDestroySecretIdByAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleDestroySecretIdByAccessorRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleDestroySecretIdByAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleListRolesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleListRolesResponse> AppRoleListRoles(string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<AppRoleListRolesResponse>("/auth/{approle_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleListRolesResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleListRolesResponse)</returns>
        public async Task<VaultResponse<AppRoleListRolesResponse>> AppRoleListRolesAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleListRolesResponse>("/auth/{approle_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleListRolesResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleListSecretIdsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleListSecretIdsResponse> AppRoleListSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleListSecretIds");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<AppRoleListSecretIdsResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleListSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleListSecretIdsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleListSecretIdsResponse)</returns>
        public async Task<VaultResponse<AppRoleListSecretIdsResponse>> AppRoleListSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleListSecretIds");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleListSecretIdsResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleListSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleListSecretIdsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLoginRequest"></param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleLogin(AppRoleLoginRequest appRoleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'appRoleLoginRequest' is set
            if (appRoleLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLoginRequest' when calling Auth->AppRoleLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLoginRequest"></param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleLoginAsync(AppRoleLoginRequest appRoleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'appRoleLoginRequest' is set
            if (appRoleLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLoginRequest' when calling Auth->AppRoleLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleLookUpSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleLookUpSecretIdResponse> AppRoleLookUpSecretId(string roleName, AppRoleLookUpSecretIdRequest appRoleLookUpSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleLookUpSecretId");


            // verify the required parameter 'appRoleLookUpSecretIdRequest' is set
            if (appRoleLookUpSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLookUpSecretIdRequest' when calling Auth->AppRoleLookUpSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleLookUpSecretIdRequest;


            // make the HTTP request
            var response = this.Client.Post<AppRoleLookUpSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLookUpSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleLookUpSecretIdResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleLookUpSecretIdResponse)</returns>
        public async Task<VaultResponse<AppRoleLookUpSecretIdResponse>> AppRoleLookUpSecretIdAsync(string roleName, AppRoleLookUpSecretIdRequest appRoleLookUpSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleLookUpSecretId");


            // verify the required parameter 'appRoleLookUpSecretIdRequest' is set
            if (appRoleLookUpSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLookUpSecretIdRequest' when calling Auth->AppRoleLookUpSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleLookUpSecretIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<AppRoleLookUpSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLookUpSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleLookUpSecretIdResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleLookUpSecretIdByAccessorResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleLookUpSecretIdByAccessorResponse> AppRoleLookUpSecretIdByAccessor(string roleName, AppRoleLookUpSecretIdByAccessorRequest appRoleLookUpSecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleLookUpSecretIdByAccessor");


            // verify the required parameter 'appRoleLookUpSecretIdByAccessorRequest' is set
            if (appRoleLookUpSecretIdByAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLookUpSecretIdByAccessorRequest' when calling Auth->AppRoleLookUpSecretIdByAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleLookUpSecretIdByAccessorRequest;


            // make the HTTP request
            var response = this.Client.Post<AppRoleLookUpSecretIdByAccessorResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLookUpSecretIdByAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleLookUpSecretIdByAccessorResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleLookUpSecretIdByAccessorRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleLookUpSecretIdByAccessorResponse)</returns>
        public async Task<VaultResponse<AppRoleLookUpSecretIdByAccessorResponse>> AppRoleLookUpSecretIdByAccessorAsync(string roleName, AppRoleLookUpSecretIdByAccessorRequest appRoleLookUpSecretIdByAccessorRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleLookUpSecretIdByAccessor");


            // verify the required parameter 'appRoleLookUpSecretIdByAccessorRequest' is set
            if (appRoleLookUpSecretIdByAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleLookUpSecretIdByAccessorRequest' when calling Auth->AppRoleLookUpSecretIdByAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleLookUpSecretIdByAccessorRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<AppRoleLookUpSecretIdByAccessorResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleLookUpSecretIdByAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleLookUpSecretIdByAccessorResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadBindSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadBindSecretIdResponse> AppRoleReadBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadBindSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadBindSecretIdResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadBindSecretIdResponse)</returns>
        public async Task<VaultResponse<AppRoleReadBindSecretIdResponse>> AppRoleReadBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadBindSecretId");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadBindSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadBindSecretIdResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadBoundCidrListResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadBoundCidrListResponse> AppRoleReadBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadBoundCidrListResponse>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadBoundCidrListResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadBoundCidrListResponse)</returns>
        public async Task<VaultResponse<AppRoleReadBoundCidrListResponse>> AppRoleReadBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadBoundCidrList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadBoundCidrListResponse>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadBoundCidrListResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadLocalSecretIdsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadLocalSecretIdsResponse> AppRoleReadLocalSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadLocalSecretIds");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadLocalSecretIdsResponse>("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadLocalSecretIdsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadLocalSecretIdsResponse)</returns>
        public async Task<VaultResponse<AppRoleReadLocalSecretIdsResponse>> AppRoleReadLocalSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadLocalSecretIds");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadLocalSecretIdsResponse>("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadLocalSecretIdsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadPeriodResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadPeriodResponse> AppRoleReadPeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadPeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadPeriodResponse>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadPeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadPeriodResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadPeriodResponse)</returns>
        public async Task<VaultResponse<AppRoleReadPeriodResponse>> AppRoleReadPeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadPeriod");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadPeriodResponse>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadPeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadPeriodResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadPoliciesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadPoliciesResponse> AppRoleReadPolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadPolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadPoliciesResponse>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadPolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadPoliciesResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadPoliciesResponse)</returns>
        public async Task<VaultResponse<AppRoleReadPoliciesResponse>> AppRoleReadPoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadPolicies");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadPoliciesResponse>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadPolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadPoliciesResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadRoleResponse> AppRoleReadRole(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadRoleResponse>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadRoleResponse)</returns>
        public async Task<VaultResponse<AppRoleReadRoleResponse>> AppRoleReadRoleAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadRoleResponse>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadRoleIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadRoleIdResponse> AppRoleReadRoleId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadRoleId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadRoleIdResponse>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadRoleIdResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadRoleIdResponse)</returns>
        public async Task<VaultResponse<AppRoleReadRoleIdResponse>> AppRoleReadRoleIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadRoleId");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadRoleIdResponse>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadRoleIdResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdBoundCidrsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadSecretIdBoundCidrsResponse> AppRoleReadSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadSecretIdBoundCidrsResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdBoundCidrsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdBoundCidrsResponse)</returns>
        public async Task<VaultResponse<AppRoleReadSecretIdBoundCidrsResponse>> AppRoleReadSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdBoundCidrs");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadSecretIdBoundCidrsResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdBoundCidrsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdNumUsesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadSecretIdNumUsesResponse> AppRoleReadSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadSecretIdNumUsesResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdNumUsesResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdNumUsesResponse)</returns>
        public async Task<VaultResponse<AppRoleReadSecretIdNumUsesResponse>> AppRoleReadSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdNumUses");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadSecretIdNumUsesResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdNumUsesResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadSecretIdTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadSecretIdTtlResponse> AppRoleReadSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadSecretIdTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdTtlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadSecretIdTtlResponse)</returns>
        public async Task<VaultResponse<AppRoleReadSecretIdTtlResponse>> AppRoleReadSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadSecretIdTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadSecretIdTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadSecretIdTtlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenBoundCidrsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadTokenBoundCidrsResponse> AppRoleReadTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadTokenBoundCidrsResponse>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenBoundCidrsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenBoundCidrsResponse)</returns>
        public async Task<VaultResponse<AppRoleReadTokenBoundCidrsResponse>> AppRoleReadTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenBoundCidrs");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadTokenBoundCidrsResponse>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenBoundCidrsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenMaxTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadTokenMaxTtlResponse> AppRoleReadTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadTokenMaxTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenMaxTtlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenMaxTtlResponse)</returns>
        public async Task<VaultResponse<AppRoleReadTokenMaxTtlResponse>> AppRoleReadTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenMaxTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadTokenMaxTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenMaxTtlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenNumUsesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadTokenNumUsesResponse> AppRoleReadTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadTokenNumUsesResponse>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenNumUsesResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenNumUsesResponse)</returns>
        public async Task<VaultResponse<AppRoleReadTokenNumUsesResponse>> AppRoleReadTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenNumUses");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadTokenNumUsesResponse>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenNumUsesResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleReadTokenTtlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleReadTokenTtlResponse> AppRoleReadTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AppRoleReadTokenTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenTtlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleReadTokenTtlResponse)</returns>
        public async Task<VaultResponse<AppRoleReadTokenTtlResponse>> AppRoleReadTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleReadTokenTtl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AppRoleReadTokenTtlResponse>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleReadTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleReadTokenTtlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleTidySecretId(string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/tidy/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleTidySecretIdAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/tidy/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBindSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteBindSecretId(string roleName, AppRoleWriteBindSecretIdRequest appRoleWriteBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteBindSecretId");


            // verify the required parameter 'appRoleWriteBindSecretIdRequest' is set
            if (appRoleWriteBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteBindSecretIdRequest' when calling Auth->AppRoleWriteBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteBindSecretIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBindSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteBindSecretIdAsync(string roleName, AppRoleWriteBindSecretIdRequest appRoleWriteBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteBindSecretId");


            // verify the required parameter 'appRoleWriteBindSecretIdRequest' is set
            if (appRoleWriteBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteBindSecretIdRequest' when calling Auth->AppRoleWriteBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteBindSecretIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBoundCidrListRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteBoundCidrList(string roleName, AppRoleWriteBoundCidrListRequest appRoleWriteBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteBoundCidrList");


            // verify the required parameter 'appRoleWriteBoundCidrListRequest' is set
            if (appRoleWriteBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteBoundCidrListRequest' when calling Auth->AppRoleWriteBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteBoundCidrListRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteBoundCidrListRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteBoundCidrListAsync(string roleName, AppRoleWriteBoundCidrListRequest appRoleWriteBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteBoundCidrList");


            // verify the required parameter 'appRoleWriteBoundCidrListRequest' is set
            if (appRoleWriteBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteBoundCidrListRequest' when calling Auth->AppRoleWriteBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteBoundCidrListRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteCustomSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleWriteCustomSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleWriteCustomSecretIdResponse> AppRoleWriteCustomSecretId(string roleName, AppRoleWriteCustomSecretIdRequest appRoleWriteCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteCustomSecretId");


            // verify the required parameter 'appRoleWriteCustomSecretIdRequest' is set
            if (appRoleWriteCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteCustomSecretIdRequest' when calling Auth->AppRoleWriteCustomSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteCustomSecretIdRequest;


            // make the HTTP request
            var response = this.Client.Post<AppRoleWriteCustomSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleWriteCustomSecretIdResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteCustomSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleWriteCustomSecretIdResponse)</returns>
        public async Task<VaultResponse<AppRoleWriteCustomSecretIdResponse>> AppRoleWriteCustomSecretIdAsync(string roleName, AppRoleWriteCustomSecretIdRequest appRoleWriteCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteCustomSecretId");


            // verify the required parameter 'appRoleWriteCustomSecretIdRequest' is set
            if (appRoleWriteCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteCustomSecretIdRequest' when calling Auth->AppRoleWriteCustomSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteCustomSecretIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<AppRoleWriteCustomSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleWriteCustomSecretIdResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePeriodRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWritePeriod(string roleName, AppRoleWritePeriodRequest appRoleWritePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWritePeriod");


            // verify the required parameter 'appRoleWritePeriodRequest' is set
            if (appRoleWritePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWritePeriodRequest' when calling Auth->AppRoleWritePeriod");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWritePeriodRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWritePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePeriodRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWritePeriodAsync(string roleName, AppRoleWritePeriodRequest appRoleWritePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWritePeriod");


            // verify the required parameter 'appRoleWritePeriodRequest' is set
            if (appRoleWritePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWritePeriodRequest' when calling Auth->AppRoleWritePeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWritePeriodRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWritePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePoliciesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWritePolicies(string roleName, AppRoleWritePoliciesRequest appRoleWritePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWritePolicies");


            // verify the required parameter 'appRoleWritePoliciesRequest' is set
            if (appRoleWritePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWritePoliciesRequest' when calling Auth->AppRoleWritePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWritePoliciesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWritePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWritePoliciesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWritePoliciesAsync(string roleName, AppRoleWritePoliciesRequest appRoleWritePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWritePolicies");


            // verify the required parameter 'appRoleWritePoliciesRequest' is set
            if (appRoleWritePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWritePoliciesRequest' when calling Auth->AppRoleWritePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWritePoliciesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWritePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteRole(string roleName, AppRoleWriteRoleRequest appRoleWriteRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteRole");


            // verify the required parameter 'appRoleWriteRoleRequest' is set
            if (appRoleWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteRoleRequest' when calling Auth->AppRoleWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteRoleAsync(string roleName, AppRoleWriteRoleRequest appRoleWriteRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteRole");


            // verify the required parameter 'appRoleWriteRoleRequest' is set
            if (appRoleWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteRoleRequest' when calling Auth->AppRoleWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteRoleId(string roleName, AppRoleWriteRoleIdRequest appRoleWriteRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteRoleId");


            // verify the required parameter 'appRoleWriteRoleIdRequest' is set
            if (appRoleWriteRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteRoleIdRequest' when calling Auth->AppRoleWriteRoleId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteRoleIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteRoleIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteRoleIdAsync(string roleName, AppRoleWriteRoleIdRequest appRoleWriteRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteRoleId");


            // verify the required parameter 'appRoleWriteRoleIdRequest' is set
            if (appRoleWriteRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteRoleIdRequest' when calling Auth->AppRoleWriteRoleId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteRoleIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AppRoleWriteSecretIdResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AppRoleWriteSecretIdResponse> AppRoleWriteSecretId(string roleName, AppRoleWriteSecretIdRequest appRoleWriteSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretId");


            // verify the required parameter 'appRoleWriteSecretIdRequest' is set
            if (appRoleWriteSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdRequest' when calling Auth->AppRoleWriteSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteSecretIdRequest;


            // make the HTTP request
            var response = this.Client.Post<AppRoleWriteSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleWriteSecretIdResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AppRoleWriteSecretIdResponse)</returns>
        public async Task<VaultResponse<AppRoleWriteSecretIdResponse>> AppRoleWriteSecretIdAsync(string roleName, AppRoleWriteSecretIdRequest appRoleWriteSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretId");


            // verify the required parameter 'appRoleWriteSecretIdRequest' is set
            if (appRoleWriteSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdRequest' when calling Auth->AppRoleWriteSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteSecretIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<AppRoleWriteSecretIdResponse>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AppRoleWriteSecretIdResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteSecretIdBoundCidrs(string roleName, AppRoleWriteSecretIdBoundCidrsRequest appRoleWriteSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdBoundCidrs");


            // verify the required parameter 'appRoleWriteSecretIdBoundCidrsRequest' is set
            if (appRoleWriteSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdBoundCidrsRequest' when calling Auth->AppRoleWriteSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteSecretIdBoundCidrsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteSecretIdBoundCidrsAsync(string roleName, AppRoleWriteSecretIdBoundCidrsRequest appRoleWriteSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdBoundCidrs");


            // verify the required parameter 'appRoleWriteSecretIdBoundCidrsRequest' is set
            if (appRoleWriteSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdBoundCidrsRequest' when calling Auth->AppRoleWriteSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteSecretIdBoundCidrsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteSecretIdNumUses(string roleName, AppRoleWriteSecretIdNumUsesRequest appRoleWriteSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdNumUses");


            // verify the required parameter 'appRoleWriteSecretIdNumUsesRequest' is set
            if (appRoleWriteSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdNumUsesRequest' when calling Auth->AppRoleWriteSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteSecretIdNumUsesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteSecretIdNumUsesAsync(string roleName, AppRoleWriteSecretIdNumUsesRequest appRoleWriteSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdNumUses");


            // verify the required parameter 'appRoleWriteSecretIdNumUsesRequest' is set
            if (appRoleWriteSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdNumUsesRequest' when calling Auth->AppRoleWriteSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteSecretIdNumUsesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteSecretIdTtl(string roleName, AppRoleWriteSecretIdTtlRequest appRoleWriteSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdTtl");


            // verify the required parameter 'appRoleWriteSecretIdTtlRequest' is set
            if (appRoleWriteSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdTtlRequest' when calling Auth->AppRoleWriteSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteSecretIdTtlRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteSecretIdTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteSecretIdTtlAsync(string roleName, AppRoleWriteSecretIdTtlRequest appRoleWriteSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteSecretIdTtl");


            // verify the required parameter 'appRoleWriteSecretIdTtlRequest' is set
            if (appRoleWriteSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteSecretIdTtlRequest' when calling Auth->AppRoleWriteSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteSecretIdTtlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteTokenBoundCidrs(string roleName, AppRoleWriteTokenBoundCidrsRequest appRoleWriteTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenBoundCidrs");


            // verify the required parameter 'appRoleWriteTokenBoundCidrsRequest' is set
            if (appRoleWriteTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenBoundCidrsRequest' when calling Auth->AppRoleWriteTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteTokenBoundCidrsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenBoundCidrsRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteTokenBoundCidrsAsync(string roleName, AppRoleWriteTokenBoundCidrsRequest appRoleWriteTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenBoundCidrs");


            // verify the required parameter 'appRoleWriteTokenBoundCidrsRequest' is set
            if (appRoleWriteTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenBoundCidrsRequest' when calling Auth->AppRoleWriteTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteTokenBoundCidrsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenMaxTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteTokenMaxTtl(string roleName, AppRoleWriteTokenMaxTtlRequest appRoleWriteTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenMaxTtl");


            // verify the required parameter 'appRoleWriteTokenMaxTtlRequest' is set
            if (appRoleWriteTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenMaxTtlRequest' when calling Auth->AppRoleWriteTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteTokenMaxTtlRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenMaxTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteTokenMaxTtlAsync(string roleName, AppRoleWriteTokenMaxTtlRequest appRoleWriteTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenMaxTtl");


            // verify the required parameter 'appRoleWriteTokenMaxTtlRequest' is set
            if (appRoleWriteTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenMaxTtlRequest' when calling Auth->AppRoleWriteTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteTokenMaxTtlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteTokenNumUses(string roleName, AppRoleWriteTokenNumUsesRequest appRoleWriteTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenNumUses");


            // verify the required parameter 'appRoleWriteTokenNumUsesRequest' is set
            if (appRoleWriteTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenNumUsesRequest' when calling Auth->AppRoleWriteTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteTokenNumUsesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenNumUsesRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteTokenNumUsesAsync(string roleName, AppRoleWriteTokenNumUsesRequest appRoleWriteTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenNumUses");


            // verify the required parameter 'appRoleWriteTokenNumUsesRequest' is set
            if (appRoleWriteTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenNumUsesRequest' when calling Auth->AppRoleWriteTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteTokenNumUsesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AppRoleWriteTokenTtl(string roleName, AppRoleWriteTokenTtlRequest appRoleWriteTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenTtl");


            // verify the required parameter 'appRoleWriteTokenTtlRequest' is set
            if (appRoleWriteTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenTtlRequest' when calling Auth->AppRoleWriteTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter





            requestOptions.Data = appRoleWriteTokenTtlRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="appRoleWriteTokenTtlRequest"></param>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AppRoleWriteTokenTtlAsync(string roleName, AppRoleWriteTokenTtlRequest appRoleWriteTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->AppRoleWriteTokenTtl");


            // verify the required parameter 'appRoleWriteTokenTtlRequest' is set
            if (appRoleWriteTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'appRoleWriteTokenTtlRequest' when calling Auth->AppRoleWriteTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter


            requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter



            requestOptions.Data = appRoleWriteTokenTtlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AppRoleWriteTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureCertificateRequest"></param>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureCertificate(string certName, AwsConfigureCertificateRequest awsConfigureCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsConfigureCertificate");


            // verify the required parameter 'awsConfigureCertificateRequest' is set
            if (awsConfigureCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureCertificateRequest' when calling Auth->AwsConfigureCertificate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureCertificateRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureCertificateRequest"></param>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureCertificateAsync(string certName, AwsConfigureCertificateRequest awsConfigureCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsConfigureCertificate");


            // verify the required parameter 'awsConfigureCertificateRequest' is set
            if (awsConfigureCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureCertificateRequest' when calling Auth->AwsConfigureCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureCertificateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureClientRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureClient(AwsConfigureClientRequest awsConfigureClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureClientRequest' is set
            if (awsConfigureClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureClientRequest' when calling Auth->AwsConfigureClient");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureClientRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureClientRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureClientAsync(AwsConfigureClientRequest awsConfigureClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureClientRequest' is set
            if (awsConfigureClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureClientRequest' when calling Auth->AwsConfigureClient");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureClientRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityAccessListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureIdentityAccessListTidyOperation(AwsConfigureIdentityAccessListTidyOperationRequest awsConfigureIdentityAccessListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureIdentityAccessListTidyOperationRequest' is set
            if (awsConfigureIdentityAccessListTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityAccessListTidyOperationRequest' when calling Auth->AwsConfigureIdentityAccessListTidyOperation");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureIdentityAccessListTidyOperationRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityAccessListTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityAccessListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureIdentityAccessListTidyOperationAsync(AwsConfigureIdentityAccessListTidyOperationRequest awsConfigureIdentityAccessListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureIdentityAccessListTidyOperationRequest' is set
            if (awsConfigureIdentityAccessListTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityAccessListTidyOperationRequest' when calling Auth->AwsConfigureIdentityAccessListTidyOperation");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureIdentityAccessListTidyOperationRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityAccessListTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityIntegrationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureIdentityIntegration(AwsConfigureIdentityIntegrationRequest awsConfigureIdentityIntegrationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureIdentityIntegrationRequest' is set
            if (awsConfigureIdentityIntegrationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityIntegrationRequest' when calling Auth->AwsConfigureIdentityIntegration");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureIdentityIntegrationRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityIntegration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityIntegrationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureIdentityIntegrationAsync(AwsConfigureIdentityIntegrationRequest awsConfigureIdentityIntegrationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureIdentityIntegrationRequest' is set
            if (awsConfigureIdentityIntegrationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityIntegrationRequest' when calling Auth->AwsConfigureIdentityIntegration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureIdentityIntegrationRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityIntegration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityWhitelistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureIdentityWhitelistTidyOperation(AwsConfigureIdentityWhitelistTidyOperationRequest awsConfigureIdentityWhitelistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureIdentityWhitelistTidyOperationRequest' is set
            if (awsConfigureIdentityWhitelistTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityWhitelistTidyOperationRequest' when calling Auth->AwsConfigureIdentityWhitelistTidyOperation");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureIdentityWhitelistTidyOperationRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityWhitelistTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureIdentityWhitelistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureIdentityWhitelistTidyOperationAsync(AwsConfigureIdentityWhitelistTidyOperationRequest awsConfigureIdentityWhitelistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureIdentityWhitelistTidyOperationRequest' is set
            if (awsConfigureIdentityWhitelistTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureIdentityWhitelistTidyOperationRequest' when calling Auth->AwsConfigureIdentityWhitelistTidyOperation");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureIdentityWhitelistTidyOperationRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureIdentityWhitelistTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagBlacklistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureRoleTagBlacklistTidyOperation(AwsConfigureRoleTagBlacklistTidyOperationRequest awsConfigureRoleTagBlacklistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureRoleTagBlacklistTidyOperationRequest' is set
            if (awsConfigureRoleTagBlacklistTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRoleTagBlacklistTidyOperationRequest' when calling Auth->AwsConfigureRoleTagBlacklistTidyOperation");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureRoleTagBlacklistTidyOperationRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRoleTagBlacklistTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagBlacklistTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureRoleTagBlacklistTidyOperationAsync(AwsConfigureRoleTagBlacklistTidyOperationRequest awsConfigureRoleTagBlacklistTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureRoleTagBlacklistTidyOperationRequest' is set
            if (awsConfigureRoleTagBlacklistTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRoleTagBlacklistTidyOperationRequest' when calling Auth->AwsConfigureRoleTagBlacklistTidyOperation");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureRoleTagBlacklistTidyOperationRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRoleTagBlacklistTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagDenyListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureRoleTagDenyListTidyOperation(AwsConfigureRoleTagDenyListTidyOperationRequest awsConfigureRoleTagDenyListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureRoleTagDenyListTidyOperationRequest' is set
            if (awsConfigureRoleTagDenyListTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRoleTagDenyListTidyOperationRequest' when calling Auth->AwsConfigureRoleTagDenyListTidyOperation");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureRoleTagDenyListTidyOperationRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRoleTagDenyListTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRoleTagDenyListTidyOperationRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureRoleTagDenyListTidyOperationAsync(AwsConfigureRoleTagDenyListTidyOperationRequest awsConfigureRoleTagDenyListTidyOperationRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureRoleTagDenyListTidyOperationRequest' is set
            if (awsConfigureRoleTagDenyListTidyOperationRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRoleTagDenyListTidyOperationRequest' when calling Auth->AwsConfigureRoleTagDenyListTidyOperation");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureRoleTagDenyListTidyOperationRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRoleTagDenyListTidyOperation", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteAuthRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsDeleteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteAuthRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsDeleteAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteCertificateConfiguration(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsDeleteCertificateConfiguration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteCertificateConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteCertificateConfigurationAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsDeleteCertificateConfiguration");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteCertificateConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteClientConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteClientConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteClientConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteClientConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteIdentityAccessList(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsDeleteIdentityAccessList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteIdentityAccessListAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsDeleteIdentityAccessList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteIdentityAccessListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityAccessListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteIdentityAccessListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityAccessListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteIdentityWhitelist(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsDeleteIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteIdentityWhitelistAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsDeleteIdentityWhitelist");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteIdentityWhitelistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityWhitelistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteIdentityWhitelistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteIdentityWhitelistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsDeleteRoleTagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsDeleteRoleTagBlacklist");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteRoleTagBlacklistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagBlacklistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteRoleTagBlacklistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagBlacklistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsDeleteRoleTagDenyList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsDeleteRoleTagDenyList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteRoleTagDenyListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagDenyListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteRoleTagDenyListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRoleTagDenyListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteStsRole(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsDeleteStsRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteStsRoleAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsDeleteStsRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListAuthRoles(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListAuthRolesAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListCertificateConfigurations(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/certificates/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListCertificateConfigurations", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListCertificateConfigurationsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/certificates/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListCertificateConfigurations", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListIdentityAccessList(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-accesslist/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListIdentityAccessListAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-accesslist/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-whitelist/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-whitelist/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListRoleTagBlacklists(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-blacklist/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoleTagBlacklists", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListRoleTagBlacklistsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoleTagBlacklists", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListRoleTagDenyLists(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-denylist/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoleTagDenyLists", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListRoleTagDenyListsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoleTagDenyLists", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListStsRoleRelationships(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/sts/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListStsRoleRelationships", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListStsRoleRelationshipsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/sts/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListStsRoleRelationships", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsLogin(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsLoginRequest' is set
            if (awsLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsLoginRequest' when calling Auth->AwsLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsLoginAsync(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsLoginRequest' is set
            if (awsLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsLoginRequest' when calling Auth->AwsLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadAuthRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsReadAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadAuthRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsReadAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadCertificateConfiguration(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsReadCertificateConfiguration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadCertificateConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadCertificateConfigurationAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->AwsReadCertificateConfiguration");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadCertificateConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadClientConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadClientConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadClientConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadClientConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadIdentityAccessList(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsReadIdentityAccessList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadIdentityAccessListAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsReadIdentityAccessList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadIdentityAccessListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityAccessListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadIdentityAccessListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityAccessListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadIdentityIntegrationConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityIntegrationConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadIdentityIntegrationConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityIntegrationConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadIdentityWhitelist(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsReadIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadIdentityWhitelistAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->AwsReadIdentityWhitelist");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadIdentityWhitelistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityWhitelistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadIdentityWhitelistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadIdentityWhitelistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsReadRoleTagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsReadRoleTagBlacklist");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRoleTagBlacklistTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagBlacklistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRoleTagBlacklistTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagBlacklistTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsReadRoleTagDenyList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsReadRoleTagDenyList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRoleTagDenyListTidySettings(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagDenyListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRoleTagDenyListTidySettingsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRoleTagDenyListTidySettings", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadStsRole(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsReadStsRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadStsRoleAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsReadStsRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsRotateRootCredentials(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsRotateRootCredentialsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccessListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsTidyIdentityAccessList(AwsTidyIdentityAccessListRequest awsTidyIdentityAccessListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsTidyIdentityAccessListRequest' is set
            if (awsTidyIdentityAccessListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccessListRequest' when calling Auth->AwsTidyIdentityAccessList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsTidyIdentityAccessListRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccessListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsTidyIdentityAccessListAsync(AwsTidyIdentityAccessListRequest awsTidyIdentityAccessListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsTidyIdentityAccessListRequest' is set
            if (awsTidyIdentityAccessListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccessListRequest' when calling Auth->AwsTidyIdentityAccessList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsTidyIdentityAccessListRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyIdentityAccessList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->AwsTidyIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsTidyIdentityWhitelistRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->AwsTidyIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsTidyIdentityWhitelistRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsTidyRoleTagBlacklist(AwsTidyRoleTagBlacklistRequest awsTidyRoleTagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsTidyRoleTagBlacklistRequest' is set
            if (awsTidyRoleTagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoleTagBlacklistRequest' when calling Auth->AwsTidyRoleTagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsTidyRoleTagBlacklistRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsTidyRoleTagBlacklistAsync(AwsTidyRoleTagBlacklistRequest awsTidyRoleTagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsTidyRoleTagBlacklistRequest' is set
            if (awsTidyRoleTagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoleTagBlacklistRequest' when calling Auth->AwsTidyRoleTagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsTidyRoleTagBlacklistRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagDenyListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsTidyRoleTagDenyList(AwsTidyRoleTagDenyListRequest awsTidyRoleTagDenyListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsTidyRoleTagDenyListRequest' is set
            if (awsTidyRoleTagDenyListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoleTagDenyListRequest' when calling Auth->AwsTidyRoleTagDenyList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsTidyRoleTagDenyListRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoleTagDenyListRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsTidyRoleTagDenyListAsync(AwsTidyRoleTagDenyListRequest awsTidyRoleTagDenyListRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsTidyRoleTagDenyListRequest' is set
            if (awsTidyRoleTagDenyListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoleTagDenyListRequest' when calling Auth->AwsTidyRoleTagDenyList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsTidyRoleTagDenyListRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsTidyRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteAuthRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteAuthRole(string role, AwsWriteAuthRoleRequest awsWriteAuthRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsWriteAuthRole");


            // verify the required parameter 'awsWriteAuthRoleRequest' is set
            if (awsWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteAuthRoleRequest' when calling Auth->AwsWriteAuthRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsWriteAuthRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteAuthRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteAuthRoleAsync(string role, AwsWriteAuthRoleRequest awsWriteAuthRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsWriteAuthRole");


            // verify the required parameter 'awsWriteAuthRoleRequest' is set
            if (awsWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteAuthRoleRequest' when calling Auth->AwsWriteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsWriteAuthRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleTagRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteRoleTag(string role, AwsWriteRoleTagRequest awsWriteRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsWriteRoleTag");


            // verify the required parameter 'awsWriteRoleTagRequest' is set
            if (awsWriteRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteRoleTagRequest' when calling Auth->AwsWriteRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsWriteRoleTagRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/role/{role}/tag", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleTagRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteRoleTagAsync(string role, AwsWriteRoleTagRequest awsWriteRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->AwsWriteRoleTag");


            // verify the required parameter 'awsWriteRoleTagRequest' is set
            if (awsWriteRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteRoleTagRequest' when calling Auth->AwsWriteRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsWriteRoleTagRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/role/{role}/tag", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteRoleTagBlacklist(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsWriteRoleTagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteRoleTagBlacklistAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsWriteRoleTagBlacklist");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteRoleTagDenyList(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsWriteRoleTagDenyList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteRoleTagDenyListAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->AwsWriteRoleTagDenyList");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRoleTagDenyList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStsRoleRequest"></param>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteStsRole(string accountId, AwsWriteStsRoleRequest awsWriteStsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsWriteStsRole");


            // verify the required parameter 'awsWriteStsRoleRequest' is set
            if (awsWriteStsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteStsRoleRequest' when calling Auth->AwsWriteStsRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsWriteStsRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStsRoleRequest"></param>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteStsRoleAsync(string accountId, AwsWriteStsRoleRequest awsWriteStsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->AwsWriteStsRole");


            // verify the required parameter 'awsWriteStsRoleRequest' is set
            if (awsWriteStsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteStsRoleRequest' when calling Auth->AwsWriteStsRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsWriteStsRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteStsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureAuthRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureConfigureAuth(AzureConfigureAuthRequest azureConfigureAuthRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'azureConfigureAuthRequest' is set
            if (azureConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigureAuthRequest' when calling Auth->AzureConfigureAuth");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter





            requestOptions.Data = azureConfigureAuthRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureAuthRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureConfigureAuthAsync(AzureConfigureAuthRequest azureConfigureAuthRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'azureConfigureAuthRequest' is set
            if (azureConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigureAuthRequest' when calling Auth->AzureConfigureAuth");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.Data = azureConfigureAuthRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureDeleteAuthConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureDeleteAuthConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureDeleteAuthRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureDeleteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureDeleteAuthRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureDeleteAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureListAuthRoles(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureListAuthRolesAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureLogin(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'azureLoginRequest' is set
            if (azureLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureLoginRequest' when calling Auth->AzureLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter





            requestOptions.Data = azureLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureLoginAsync(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'azureLoginRequest' is set
            if (azureLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureLoginRequest' when calling Auth->AzureLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.Data = azureLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureReadAuthConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureReadAuthConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureReadAuthRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureReadAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureReadAuthRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureReadAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureRotateRootCredentials(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureRotateRootCredentialsAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureWriteAuthRole(string name, AzureWriteAuthRoleRequest azureWriteAuthRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureWriteAuthRole");


            // verify the required parameter 'azureWriteAuthRoleRequest' is set
            if (azureWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureWriteAuthRoleRequest' when calling Auth->AzureWriteAuthRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter





            requestOptions.Data = azureWriteAuthRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureWriteAuthRoleAsync(string name, AzureWriteAuthRoleRequest azureWriteAuthRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->AzureWriteAuthRole");


            // verify the required parameter 'azureWriteAuthRoleRequest' is set
            if (azureWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureWriteAuthRoleRequest' when calling Auth->AzureWriteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.Data = azureWriteAuthRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigureRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CentrifyConfigure(CentrifyConfigureRequest centrifyConfigureRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'centrifyConfigureRequest' is set
            if (centrifyConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyConfigureRequest' when calling Auth->CentrifyConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter





            requestOptions.Data = centrifyConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{centrify_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigureRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CentrifyConfigureAsync(CentrifyConfigureRequest centrifyConfigureRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'centrifyConfigureRequest' is set
            if (centrifyConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyConfigureRequest' when calling Auth->CentrifyConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter



            requestOptions.Data = centrifyConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{centrify_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CentrifyLogin(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'centrifyLoginRequest' is set
            if (centrifyLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyLoginRequest' when calling Auth->CentrifyLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter





            requestOptions.Data = centrifyLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{centrify_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CentrifyLoginAsync(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'centrifyLoginRequest' is set
            if (centrifyLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyLoginRequest' when calling Auth->CentrifyLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter



            requestOptions.Data = centrifyLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{centrify_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CentrifyReadConfiguration(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{centrify_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CentrifyReadConfigurationAsync(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{centrify_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CentrifyReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigureRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertConfigure(CertConfigureRequest certConfigureRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'certConfigureRequest' is set
            if (certConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certConfigureRequest' when calling Auth->CertConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter





            requestOptions.Data = certConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigureRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertConfigureAsync(CertConfigureRequest certConfigureRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'certConfigureRequest' is set
            if (certConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certConfigureRequest' when calling Auth->CertConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.Data = certConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertDeleteCertificate(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertDeleteCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertDeleteCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertDeleteCertificateAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertDeleteCertificate");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertDeleteCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertDeleteCrl(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertDeleteCrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertDeleteCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertDeleteCrlAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertDeleteCrl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertDeleteCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertListCertificates(string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/certs/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertListCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertListCertificatesAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/certs/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertListCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertListCrls(string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/crls/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertListCrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertListCrlsAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/crls/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertListCrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertLogin(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'certLoginRequest' is set
            if (certLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certLoginRequest' when calling Auth->CertLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter





            requestOptions.Data = certLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertLoginAsync(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'certLoginRequest' is set
            if (certLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certLoginRequest' when calling Auth->CertLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.Data = certLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertReadCertificate(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertReadCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertReadCertificateAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertReadCertificate");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertReadConfiguration(string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertReadConfigurationAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertReadCrl(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertReadCrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertReadCrlAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertReadCrl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertReadCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCertificateRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertWriteCertificate(string name, CertWriteCertificateRequest certWriteCertificateRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertWriteCertificate");


            // verify the required parameter 'certWriteCertificateRequest' is set
            if (certWriteCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certWriteCertificateRequest' when calling Auth->CertWriteCertificate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter





            requestOptions.Data = certWriteCertificateRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertWriteCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCertificateRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertWriteCertificateAsync(string name, CertWriteCertificateRequest certWriteCertificateRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertWriteCertificate");


            // verify the required parameter 'certWriteCertificateRequest' is set
            if (certWriteCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certWriteCertificateRequest' when calling Auth->CertWriteCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.Data = certWriteCertificateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertWriteCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCrlRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CertWriteCrl(string name, CertWriteCrlRequest certWriteCrlRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertWriteCrl");


            // verify the required parameter 'certWriteCrlRequest' is set
            if (certWriteCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certWriteCrlRequest' when calling Auth->CertWriteCrl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter





            requestOptions.Data = certWriteCrlRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertWriteCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certWriteCrlRequest"></param>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CertWriteCrlAsync(string name, CertWriteCrlRequest certWriteCrlRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->CertWriteCrl");


            // verify the required parameter 'certWriteCrlRequest' is set
            if (certWriteCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certWriteCrlRequest' when calling Auth->CertWriteCrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter



            requestOptions.Data = certWriteCrlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CertWriteCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryConfigureRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryConfigure(CloudFoundryConfigureRequest cloudFoundryConfigureRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'cloudFoundryConfigureRequest' is set
            if (cloudFoundryConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryConfigureRequest' when calling Auth->CloudFoundryConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter





            requestOptions.Data = cloudFoundryConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryConfigureRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryConfigureAsync(CloudFoundryConfigureRequest cloudFoundryConfigureRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'cloudFoundryConfigureRequest' is set
            if (cloudFoundryConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryConfigureRequest' when calling Auth->CloudFoundryConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            requestOptions.Data = cloudFoundryConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryDeleteConfiguration(string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryDeleteConfigurationAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryDeleteRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryDeleteRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryListRoles(string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/roles/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryListRolesAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/roles/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryLoginRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryLogin(CloudFoundryLoginRequest cloudFoundryLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'cloudFoundryLoginRequest' is set
            if (cloudFoundryLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryLoginRequest' when calling Auth->CloudFoundryLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter





            requestOptions.Data = cloudFoundryLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryLoginRequest"></param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryLoginAsync(CloudFoundryLoginRequest cloudFoundryLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'cloudFoundryLoginRequest' is set
            if (cloudFoundryLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryLoginRequest' when calling Auth->CloudFoundryLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            requestOptions.Data = cloudFoundryLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryReadConfiguration(string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryReadConfigurationAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryReadRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryReadRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryWriteRoleRequest"></param>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CloudFoundryWriteRole(string role, CloudFoundryWriteRoleRequest cloudFoundryWriteRoleRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryWriteRole");


            // verify the required parameter 'cloudFoundryWriteRoleRequest' is set
            if (cloudFoundryWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryWriteRoleRequest' when calling Auth->CloudFoundryWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter





            requestOptions.Data = cloudFoundryWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cloudFoundryWriteRoleRequest"></param>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CloudFoundryWriteRoleAsync(string role, CloudFoundryWriteRoleRequest cloudFoundryWriteRoleRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->CloudFoundryWriteRole");


            // verify the required parameter 'cloudFoundryWriteRoleRequest' is set
            if (cloudFoundryWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cloudFoundryWriteRoleRequest' when calling Auth->CloudFoundryWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter



            requestOptions.Data = cloudFoundryWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CloudFoundryWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigureRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubConfigure(GithubConfigureRequest githubConfigureRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'githubConfigureRequest' is set
            if (githubConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubConfigureRequest' when calling Auth->GithubConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter





            requestOptions.Data = githubConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigureRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubConfigureAsync(GithubConfigureRequest githubConfigureRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'githubConfigureRequest' is set
            if (githubConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubConfigureRequest' when calling Auth->GithubConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.Data = githubConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubDeleteTeamMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubDeleteTeamMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubDeleteTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubDeleteTeamMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubDeleteTeamMapping");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubDeleteTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubDeleteUserMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubDeleteUserMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubDeleteUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubDeleteUserMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubDeleteUserMapping");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubDeleteUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubListTeams(string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/teams/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubListTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubListTeamsAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/teams/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubListTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubListUsers(string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/users/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubListUsersAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/users/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubLogin(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'githubLoginRequest' is set
            if (githubLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubLoginRequest' when calling Auth->GithubLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter





            requestOptions.Data = githubLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubLoginAsync(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'githubLoginRequest' is set
            if (githubLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubLoginRequest' when calling Auth->GithubLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.Data = githubLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubReadConfiguration(string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubReadConfigurationAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubReadTeamMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubReadTeamMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubReadTeamMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubReadTeamMapping");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubReadUserMapping(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubReadUserMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubReadUserMappingAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubReadUserMapping");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubReadUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteTeamMappingRequest"></param>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubWriteTeamMapping(string key, GithubWriteTeamMappingRequest githubWriteTeamMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubWriteTeamMapping");


            // verify the required parameter 'githubWriteTeamMappingRequest' is set
            if (githubWriteTeamMappingRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubWriteTeamMappingRequest' when calling Auth->GithubWriteTeamMapping");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter





            requestOptions.Data = githubWriteTeamMappingRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubWriteTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteTeamMappingRequest"></param>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubWriteTeamMappingAsync(string key, GithubWriteTeamMappingRequest githubWriteTeamMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubWriteTeamMapping");


            // verify the required parameter 'githubWriteTeamMappingRequest' is set
            if (githubWriteTeamMappingRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubWriteTeamMappingRequest' when calling Auth->GithubWriteTeamMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.Data = githubWriteTeamMappingRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubWriteTeamMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteUserMappingRequest"></param>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GithubWriteUserMapping(string key, GithubWriteUserMappingRequest githubWriteUserMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubWriteUserMapping");


            // verify the required parameter 'githubWriteUserMappingRequest' is set
            if (githubWriteUserMappingRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubWriteUserMappingRequest' when calling Auth->GithubWriteUserMapping");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter





            requestOptions.Data = githubWriteUserMappingRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubWriteUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubWriteUserMappingRequest"></param>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GithubWriteUserMappingAsync(string key, GithubWriteUserMappingRequest githubWriteUserMappingRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GithubWriteUserMapping");


            // verify the required parameter 'githubWriteUserMappingRequest' is set
            if (githubWriteUserMappingRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubWriteUserMappingRequest' when calling Auth->GithubWriteUserMapping");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter



            requestOptions.Data = githubWriteUserMappingRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GithubWriteUserMapping", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureAuthRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudConfigureAuth(GoogleCloudConfigureAuthRequest googleCloudConfigureAuthRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'googleCloudConfigureAuthRequest' is set
            if (googleCloudConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudConfigureAuthRequest' when calling Auth->GoogleCloudConfigureAuth");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudConfigureAuthRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureAuthRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudConfigureAuthAsync(GoogleCloudConfigureAuthRequest googleCloudConfigureAuthRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'googleCloudConfigureAuthRequest' is set
            if (googleCloudConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudConfigureAuthRequest' when calling Auth->GoogleCloudConfigureAuth");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudConfigureAuthRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudDeleteRole(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudDeleteRoleAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Add or remove labels for an existing &#x27;gce&#x27; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditLabelsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudEditLabelsForRole(string name, GoogleCloudEditLabelsForRoleRequest googleCloudEditLabelsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudEditLabelsForRole");


            // verify the required parameter 'googleCloudEditLabelsForRoleRequest' is set
            if (googleCloudEditLabelsForRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudEditLabelsForRoleRequest' when calling Auth->GoogleCloudEditLabelsForRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudEditLabelsForRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}/labels", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudEditLabelsForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove labels for an existing &#x27;gce&#x27; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditLabelsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudEditLabelsForRoleAsync(string name, GoogleCloudEditLabelsForRoleRequest googleCloudEditLabelsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudEditLabelsForRole");


            // verify the required parameter 'googleCloudEditLabelsForRoleRequest' is set
            if (googleCloudEditLabelsForRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudEditLabelsForRoleRequest' when calling Auth->GoogleCloudEditLabelsForRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudEditLabelsForRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}/labels", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudEditLabelsForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditServiceAccountsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudEditServiceAccountsForRole(string name, GoogleCloudEditServiceAccountsForRoleRequest googleCloudEditServiceAccountsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudEditServiceAccountsForRole");


            // verify the required parameter 'googleCloudEditServiceAccountsForRoleRequest' is set
            if (googleCloudEditServiceAccountsForRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudEditServiceAccountsForRoleRequest' when calling Auth->GoogleCloudEditServiceAccountsForRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudEditServiceAccountsForRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}/service-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudEditServiceAccountsForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudEditServiceAccountsForRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudEditServiceAccountsForRoleAsync(string name, GoogleCloudEditServiceAccountsForRoleRequest googleCloudEditServiceAccountsForRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudEditServiceAccountsForRole");


            // verify the required parameter 'googleCloudEditServiceAccountsForRoleRequest' is set
            if (googleCloudEditServiceAccountsForRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudEditServiceAccountsForRoleRequest' when calling Auth->GoogleCloudEditServiceAccountsForRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudEditServiceAccountsForRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}/service-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudEditServiceAccountsForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudListRoles(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudListRolesAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudLoginRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudLogin(GoogleCloudLoginRequest googleCloudLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'googleCloudLoginRequest' is set
            if (googleCloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudLoginRequest' when calling Auth->GoogleCloudLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudLoginRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudLoginAsync(GoogleCloudLoginRequest googleCloudLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'googleCloudLoginRequest' is set
            if (googleCloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudLoginRequest' when calling Auth->GoogleCloudLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadAuthConfiguration(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadAuthConfigurationAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadRole(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadRoleAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudWriteRole(string name, GoogleCloudWriteRoleRequest googleCloudWriteRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudWriteRole");


            // verify the required parameter 'googleCloudWriteRoleRequest' is set
            if (googleCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteRoleRequest' when calling Auth->GoogleCloudWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudWriteRoleAsync(string name, GoogleCloudWriteRoleRequest googleCloudWriteRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GoogleCloudWriteRole");


            // verify the required parameter 'googleCloudWriteRoleRequest' is set
            if (googleCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteRoleRequest' when calling Auth->GoogleCloudWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigureRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtConfigure(JwtConfigureRequest jwtConfigureRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'jwtConfigureRequest' is set
            if (jwtConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtConfigureRequest' when calling Auth->JwtConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter





            requestOptions.Data = jwtConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigureRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtConfigureAsync(JwtConfigureRequest jwtConfigureRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'jwtConfigureRequest' is set
            if (jwtConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtConfigureRequest' when calling Auth->JwtConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.Data = jwtConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtDeleteRole(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtDeleteRoleAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtListRoles(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtListRolesAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtLogin(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'jwtLoginRequest' is set
            if (jwtLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtLoginRequest' when calling Auth->JwtLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter





            requestOptions.Data = jwtLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtLoginAsync(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'jwtLoginRequest' is set
            if (jwtLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtLoginRequest' when calling Auth->JwtLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.Data = jwtLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtOidcCallback(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtOidcCallbackAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackWithParametersRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtOidcCallbackWithParameters(JwtOidcCallbackWithParametersRequest jwtOidcCallbackWithParametersRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'jwtOidcCallbackWithParametersRequest' is set
            if (jwtOidcCallbackWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcCallbackWithParametersRequest' when calling Auth->JwtOidcCallbackWithParameters");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter





            requestOptions.Data = jwtOidcCallbackWithParametersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcCallbackWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackWithParametersRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtOidcCallbackWithParametersAsync(JwtOidcCallbackWithParametersRequest jwtOidcCallbackWithParametersRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'jwtOidcCallbackWithParametersRequest' is set
            if (jwtOidcCallbackWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcCallbackWithParametersRequest' when calling Auth->JwtOidcCallbackWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.Data = jwtOidcCallbackWithParametersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcCallbackWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcRequestAuthorizationUrlRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtOidcRequestAuthorizationUrl(JwtOidcRequestAuthorizationUrlRequest jwtOidcRequestAuthorizationUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'jwtOidcRequestAuthorizationUrlRequest' is set
            if (jwtOidcRequestAuthorizationUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcRequestAuthorizationUrlRequest' when calling Auth->JwtOidcRequestAuthorizationUrl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter





            requestOptions.Data = jwtOidcRequestAuthorizationUrlRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/oidc/auth_url", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcRequestAuthorizationUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcRequestAuthorizationUrlRequest"></param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtOidcRequestAuthorizationUrlAsync(JwtOidcRequestAuthorizationUrlRequest jwtOidcRequestAuthorizationUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'jwtOidcRequestAuthorizationUrlRequest' is set
            if (jwtOidcRequestAuthorizationUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcRequestAuthorizationUrlRequest' when calling Auth->JwtOidcRequestAuthorizationUrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.Data = jwtOidcRequestAuthorizationUrlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/oidc/auth_url", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtOidcRequestAuthorizationUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtReadConfiguration(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtReadConfigurationAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtReadRole(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtReadRoleAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> JwtWriteRole(string name, JwtWriteRoleRequest jwtWriteRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtWriteRole");


            // verify the required parameter 'jwtWriteRoleRequest' is set
            if (jwtWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtWriteRoleRequest' when calling Auth->JwtWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter





            requestOptions.Data = jwtWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> JwtWriteRoleAsync(string name, JwtWriteRoleRequest jwtWriteRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->JwtWriteRole");


            // verify the required parameter 'jwtWriteRoleRequest' is set
            if (jwtWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtWriteRoleRequest' when calling Auth->JwtWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter



            requestOptions.Data = jwtWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("JwtWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosConfigure(KerberosConfigureRequest kerberosConfigureRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kerberosConfigureRequest' is set
            if (kerberosConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigureRequest' when calling Auth->KerberosConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter





            requestOptions.Data = kerberosConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosConfigureAsync(KerberosConfigureRequest kerberosConfigureRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kerberosConfigureRequest' is set
            if (kerberosConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigureRequest' when calling Auth->KerberosConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.Data = kerberosConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureLdapRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosConfigureLdap(KerberosConfigureLdapRequest kerberosConfigureLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kerberosConfigureLdapRequest' is set
            if (kerberosConfigureLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigureLdapRequest' when calling Auth->KerberosConfigureLdap");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter





            requestOptions.Data = kerberosConfigureLdapRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosConfigureLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigureLdapRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosConfigureLdapAsync(KerberosConfigureLdapRequest kerberosConfigureLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kerberosConfigureLdapRequest' is set
            if (kerberosConfigureLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigureLdapRequest' when calling Auth->KerberosConfigureLdap");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.Data = kerberosConfigureLdapRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosConfigureLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosDeleteGroup(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosDeleteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosDeleteGroupAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosDeleteGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosListGroups(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/groups/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosListGroupsAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/groups/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosLogin(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kerberosLoginRequest' is set
            if (kerberosLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosLoginRequest' when calling Auth->KerberosLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter





            requestOptions.Data = kerberosLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosLoginAsync(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kerberosLoginRequest' is set
            if (kerberosLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosLoginRequest' when calling Auth->KerberosLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.Data = kerberosLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosReadConfiguration(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosReadConfigurationAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosReadGroup(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosReadGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosReadGroupAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosReadGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosReadLdapConfiguration(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadLdapConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosReadLdapConfigurationAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosReadLdapConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KerberosWriteGroup(string name, KerberosWriteGroupRequest kerberosWriteGroupRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosWriteGroup");


            // verify the required parameter 'kerberosWriteGroupRequest' is set
            if (kerberosWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosWriteGroupRequest' when calling Auth->KerberosWriteGroup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter





            requestOptions.Data = kerberosWriteGroupRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KerberosWriteGroupAsync(string name, KerberosWriteGroupRequest kerberosWriteGroupRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KerberosWriteGroup");


            // verify the required parameter 'kerberosWriteGroupRequest' is set
            if (kerberosWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosWriteGroupRequest' when calling Auth->KerberosWriteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter



            requestOptions.Data = kerberosWriteGroupRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KerberosWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureAuthRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesConfigureAuth(KubernetesConfigureAuthRequest kubernetesConfigureAuthRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kubernetesConfigureAuthRequest' is set
            if (kubernetesConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigureAuthRequest' when calling Auth->KubernetesConfigureAuth");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesConfigureAuthRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureAuthRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesConfigureAuthAsync(KubernetesConfigureAuthRequest kubernetesConfigureAuthRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kubernetesConfigureAuthRequest' is set
            if (kubernetesConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigureAuthRequest' when calling Auth->KubernetesConfigureAuth");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesConfigureAuthRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesDeleteAuthRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesDeleteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesDeleteAuthRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesDeleteAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesListAuthRoles(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesListAuthRolesAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesListAuthRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->KubernetesLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->KubernetesLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesReadAuthConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesReadAuthConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesReadAuthRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesReadAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesReadAuthRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesReadAuthRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesWriteAuthRole(string name, KubernetesWriteAuthRoleRequest kubernetesWriteAuthRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesWriteAuthRole");


            // verify the required parameter 'kubernetesWriteAuthRoleRequest' is set
            if (kubernetesWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesWriteAuthRoleRequest' when calling Auth->KubernetesWriteAuthRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesWriteAuthRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteAuthRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesWriteAuthRoleAsync(string name, KubernetesWriteAuthRoleRequest kubernetesWriteAuthRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->KubernetesWriteAuthRole");


            // verify the required parameter 'kubernetesWriteAuthRoleRequest' is set
            if (kubernetesWriteAuthRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesWriteAuthRoleRequest' when calling Auth->KubernetesWriteAuthRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesWriteAuthRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesWriteAuthRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureAuthRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapConfigureAuth(LdapConfigureAuthRequest ldapConfigureAuthRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'ldapConfigureAuthRequest' is set
            if (ldapConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigureAuthRequest' when calling Auth->LdapConfigureAuth");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapConfigureAuthRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureAuthRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapConfigureAuthAsync(LdapConfigureAuthRequest ldapConfigureAuthRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'ldapConfigureAuthRequest' is set
            if (ldapConfigureAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigureAuthRequest' when calling Auth->LdapConfigureAuth");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapConfigureAuthRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapConfigureAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapDeleteGroup(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapDeleteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapDeleteGroupAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapDeleteGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapDeleteUser(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapDeleteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapDeleteUserAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapDeleteUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapListGroups(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/groups/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapListGroupsAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/groups/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapListUsers(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/users/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapListUsersAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/users/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLogin(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->LdapLogin");


            // verify the required parameter 'ldapLoginRequest' is set
            if (ldapLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLoginRequest' when calling Auth->LdapLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLoginAsync(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->LdapLogin");


            // verify the required parameter 'ldapLoginRequest' is set
            if (ldapLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLoginRequest' when calling Auth->LdapLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadAuthConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadAuthConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadAuthConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadGroup(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapReadGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadGroupAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapReadGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadUser(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapReadUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadUserAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapReadUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapWriteGroup(string name, LdapWriteGroupRequest ldapWriteGroupRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapWriteGroup");


            // verify the required parameter 'ldapWriteGroupRequest' is set
            if (ldapWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteGroupRequest' when calling Auth->LdapWriteGroup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapWriteGroupRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteGroupRequest"></param>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapWriteGroupAsync(string name, LdapWriteGroupRequest ldapWriteGroupRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapWriteGroup");


            // verify the required parameter 'ldapWriteGroupRequest' is set
            if (ldapWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteGroupRequest' when calling Auth->LdapWriteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapWriteGroupRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteUserRequest"></param>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapWriteUser(string name, LdapWriteUserRequest ldapWriteUserRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapWriteUser");


            // verify the required parameter 'ldapWriteUserRequest' is set
            if (ldapWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteUserRequest' when calling Auth->LdapWriteUser");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapWriteUserRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteUserRequest"></param>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapWriteUserAsync(string name, LdapWriteUserRequest ldapWriteUserRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->LdapWriteUser");


            // verify the required parameter 'ldapWriteUserRequest' is set
            if (ldapWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteUserRequest' when calling Auth->LdapWriteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapWriteUserRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigureRequest"></param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciConfigure(OciConfigureRequest ociConfigureRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'ociConfigureRequest' is set
            if (ociConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociConfigureRequest' when calling Auth->OciConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter





            requestOptions.Data = ociConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigureRequest"></param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciConfigureAsync(OciConfigureRequest ociConfigureRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'ociConfigureRequest' is set
            if (ociConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociConfigureRequest' when calling Auth->OciConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            requestOptions.Data = ociConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciDeleteConfiguration(string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciDeleteConfigurationAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciDeleteRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciDeleteRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciListRoles(string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/role/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciListRolesAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/role/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociLoginRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciLogin(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciLogin");


            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->OciLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter





            requestOptions.Data = ociLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/login/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociLoginRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciLoginAsync(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciLogin");


            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->OciLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            requestOptions.Data = ociLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/login/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciReadConfiguration(string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciReadConfigurationAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciReadRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciReadRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociWriteRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OciWriteRole(string role, OciWriteRoleRequest ociWriteRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciWriteRole");


            // verify the required parameter 'ociWriteRoleRequest' is set
            if (ociWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociWriteRoleRequest' when calling Auth->OciWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter





            requestOptions.Data = ociWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociWriteRoleRequest"></param>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OciWriteRoleAsync(string role, OciWriteRoleRequest ociWriteRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->OciWriteRole");


            // verify the required parameter 'ociWriteRoleRequest' is set
            if (ociWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociWriteRoleRequest' when calling Auth->OciWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter



            requestOptions.Data = ociWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OciWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigureRequest"></param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaConfigure(OktaConfigureRequest oktaConfigureRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'oktaConfigureRequest' is set
            if (oktaConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaConfigureRequest' when calling Auth->OktaConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter





            requestOptions.Data = oktaConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigureRequest"></param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaConfigureAsync(OktaConfigureRequest oktaConfigureRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'oktaConfigureRequest' is set
            if (oktaConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaConfigureRequest' when calling Auth->OktaConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.Data = oktaConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaDeleteGroup(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaDeleteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaDeleteGroupAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaDeleteGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaDeleteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaDeleteUser(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaDeleteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaDeleteUserAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaDeleteUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaListGroups(string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/groups/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaListGroupsAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/groups/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaListGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaListUsers(string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/users/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaListUsersAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/users/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaLogin(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->OktaLogin");


            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->OktaLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter





            requestOptions.Data = oktaLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaLoginAsync(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->OktaLogin");


            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->OktaLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.Data = oktaLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaReadConfiguration(string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaReadConfigurationAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaReadGroup(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaReadGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaReadGroupAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaReadGroup");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaReadUser(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaReadUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaReadUserAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaReadUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaVerify(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->OktaVerify");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/verify/{nonce}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaVerifyAsync(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->OktaVerify");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/verify/{nonce}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteGroupRequest"></param>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaWriteGroup(string name, OktaWriteGroupRequest oktaWriteGroupRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaWriteGroup");


            // verify the required parameter 'oktaWriteGroupRequest' is set
            if (oktaWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaWriteGroupRequest' when calling Auth->OktaWriteGroup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter





            requestOptions.Data = oktaWriteGroupRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteGroupRequest"></param>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaWriteGroupAsync(string name, OktaWriteGroupRequest oktaWriteGroupRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaWriteGroup");


            // verify the required parameter 'oktaWriteGroupRequest' is set
            if (oktaWriteGroupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaWriteGroupRequest' when calling Auth->OktaWriteGroup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.Data = oktaWriteGroupRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaWriteGroup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteUserRequest"></param>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> OktaWriteUser(string name, OktaWriteUserRequest oktaWriteUserRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaWriteUser");


            // verify the required parameter 'oktaWriteUserRequest' is set
            if (oktaWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaWriteUserRequest' when calling Auth->OktaWriteUser");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter





            requestOptions.Data = oktaWriteUserRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaWriteUserRequest"></param>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> OktaWriteUserAsync(string name, OktaWriteUserRequest oktaWriteUserRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->OktaWriteUser");


            // verify the required parameter 'oktaWriteUserRequest' is set
            if (oktaWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaWriteUserRequest' when calling Auth->OktaWriteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter



            requestOptions.Data = oktaWriteUserRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("OktaWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigureRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusConfigure(RadiusConfigureRequest radiusConfigureRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'radiusConfigureRequest' is set
            if (radiusConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusConfigureRequest' when calling Auth->RadiusConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter





            requestOptions.Data = radiusConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigureRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusConfigureAsync(RadiusConfigureRequest radiusConfigureRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'radiusConfigureRequest' is set
            if (radiusConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusConfigureRequest' when calling Auth->RadiusConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.Data = radiusConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusDeleteUser(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusDeleteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusDeleteUserAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusDeleteUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusListUsers(string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/users/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusListUsersAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/users/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusLogin(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->RadiusLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter





            requestOptions.Data = radiusLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusLoginAsync(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->RadiusLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.Data = radiusLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginWithUsernameRequest"></param>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusLoginWithUsername(string urlusername, RadiusLoginWithUsernameRequest radiusLoginWithUsernameRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->RadiusLoginWithUsername");


            // verify the required parameter 'radiusLoginWithUsernameRequest' is set
            if (radiusLoginWithUsernameRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginWithUsernameRequest' when calling Auth->RadiusLoginWithUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter





            requestOptions.Data = radiusLoginWithUsernameRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/login/{urlusername}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusLoginWithUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginWithUsernameRequest"></param>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusLoginWithUsernameAsync(string urlusername, RadiusLoginWithUsernameRequest radiusLoginWithUsernameRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->RadiusLoginWithUsername");


            // verify the required parameter 'radiusLoginWithUsernameRequest' is set
            if (radiusLoginWithUsernameRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginWithUsernameRequest' when calling Auth->RadiusLoginWithUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.Data = radiusLoginWithUsernameRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/login/{urlusername}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusLoginWithUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusReadConfiguration(string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusReadConfigurationAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusReadUser(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusReadUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusReadUserAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusReadUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusWriteUserRequest"></param>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RadiusWriteUser(string name, RadiusWriteUserRequest radiusWriteUserRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusWriteUser");


            // verify the required parameter 'radiusWriteUserRequest' is set
            if (radiusWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusWriteUserRequest' when calling Auth->RadiusWriteUser");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter





            requestOptions.Data = radiusWriteUserRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusWriteUserRequest"></param>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RadiusWriteUserAsync(string name, RadiusWriteUserRequest radiusWriteUserRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->RadiusWriteUser");


            // verify the required parameter 'radiusWriteUserRequest' is set
            if (radiusWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusWriteUserRequest' when calling Auth->RadiusWriteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter



            requestOptions.Data = radiusWriteUserRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RadiusWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenCreate(TokenCreateRequest tokenCreateRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->TokenCreate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenCreateRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/create", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenCreateAsync(TokenCreateRequest tokenCreateRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->TokenCreate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenCreateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/create", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateAgainstRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenCreateAgainstRole(string roleName, TokenCreateAgainstRoleRequest tokenCreateAgainstRoleRequest, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenCreateAgainstRole");


            // verify the required parameter 'tokenCreateAgainstRoleRequest' is set
            if (tokenCreateAgainstRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateAgainstRoleRequest' when calling Auth->TokenCreateAgainstRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter





            requestOptions.Data = tokenCreateAgainstRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/create/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreateAgainstRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateAgainstRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenCreateAgainstRoleAsync(string roleName, TokenCreateAgainstRoleRequest tokenCreateAgainstRoleRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenCreateAgainstRole");


            // verify the required parameter 'tokenCreateAgainstRoleRequest' is set
            if (tokenCreateAgainstRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateAgainstRoleRequest' when calling Auth->TokenCreateAgainstRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter



            requestOptions.Data = tokenCreateAgainstRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/create/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreateAgainstRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->TokenCreateOrphan");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenCreateOrphanRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/create-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->TokenCreateOrphan");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenCreateOrphanRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/create-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenDeleteRole(string roleName, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/token/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenDeleteRoleAsync(string roleName, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/token/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#x27;sudo&#x27; capability in addition to &#x27;list&#x27;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenListAccessors(TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/token/accessors/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenListAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#x27;sudo&#x27; capability in addition to &#x27;list&#x27;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenListAccessorsAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/token/accessors/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenListAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint lists configured roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenListRoles(TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/token/roles/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint lists configured roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenListRolesAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/token/roles/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenLookUp(TokenLookUpRequest tokenLookUpRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenLookUpRequest' is set
            if (tokenLookUpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookUpRequest' when calling Auth->TokenLookUp");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenLookUpRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenLookUpAsync(TokenLookUpRequest tokenLookUpRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenLookUpRequest' is set
            if (tokenLookUpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookUpRequest' when calling Auth->TokenLookUp");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenLookUpRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenLookUpAccessor(TokenLookUpAccessorRequest tokenLookUpAccessorRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenLookUpAccessorRequest' is set
            if (tokenLookUpAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookUpAccessorRequest' when calling Auth->TokenLookUpAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenLookUpAccessorRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/lookup-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUpAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookUpAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenLookUpAccessorAsync(TokenLookUpAccessorRequest tokenLookUpAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenLookUpAccessorRequest' is set
            if (tokenLookUpAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookUpAccessorRequest' when calling Auth->TokenLookUpAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenLookUpAccessorRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/lookup-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUpAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenLookUpSelf(TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/token/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUpSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenLookUpSelfAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/token/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenLookUpSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenReadRole(string roleName, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/token/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenReadRoleAsync(string roleName, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/token/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRenew(TokenRenewRequest tokenRenewRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->TokenRenew");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRenewRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRenewAsync(TokenRenewRequest tokenRenewRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->TokenRenew");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRenewRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->TokenRenewAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRenewAccessorRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/renew-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->TokenRenewAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRenewAccessorRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/renew-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->TokenRenewSelf");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRenewSelfRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/renew-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->TokenRenewSelf");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRenewSelfRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/renew-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRevoke(TokenRevokeRequest tokenRevokeRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->TokenRevoke");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRevokeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->TokenRevoke");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRevokeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->TokenRevokeAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRevokeAccessorRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/revoke-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->TokenRevokeAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRevokeAccessorRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/revoke-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->TokenRevokeOrphan");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);





            requestOptions.Data = tokenRevokeOrphanRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/revoke-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->TokenRevokeOrphan");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            requestOptions.Data = tokenRevokeOrphanRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/revoke-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenRevokeSelf(TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/revoke-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenRevokeSelfAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/revoke-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenTidy(TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);






            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenTidyAsync(TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TokenWriteRole(string roleName, TokenWriteRoleRequest tokenWriteRoleRequest, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenWriteRole");


            // verify the required parameter 'tokenWriteRoleRequest' is set
            if (tokenWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenWriteRoleRequest' when calling Auth->TokenWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter





            requestOptions.Data = tokenWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/token/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenWriteRoleRequest"></param>
        /// <param name="roleName">Name of the role</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TokenWriteRoleAsync(string roleName, TokenWriteRoleRequest tokenWriteRoleRequest, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->TokenWriteRole");


            // verify the required parameter 'tokenWriteRoleRequest' is set
            if (tokenWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenWriteRoleRequest' when calling Auth->TokenWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter



            requestOptions.Data = tokenWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/token/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TokenWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassDeleteUser(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassDeleteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassDeleteUserAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassDeleteUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassDeleteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassListUsers(string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{userpass_mount_path}/users/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassListUsersAsync(string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{userpass_mount_path}/users/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassListUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassLogin(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassLogin");


            // verify the required parameter 'userpassLoginRequest' is set
            if (userpassLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassLoginRequest' when calling Auth->UserpassLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter





            requestOptions.Data = userpassLoginRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassLoginAsync(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassLogin");


            // verify the required parameter 'userpassLoginRequest' is set
            if (userpassLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassLoginRequest' when calling Auth->UserpassLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.Data = userpassLoginRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassReadUser(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassReadUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassReadUserAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassReadUser");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassReadUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Reset user&#x27;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassResetPasswordRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassResetPassword(string username, UserpassResetPasswordRequest userpassResetPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassResetPassword");


            // verify the required parameter 'userpassResetPasswordRequest' is set
            if (userpassResetPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassResetPasswordRequest' when calling Auth->UserpassResetPassword");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter





            requestOptions.Data = userpassResetPasswordRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}/password", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassResetPassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Reset user&#x27;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassResetPasswordRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassResetPasswordAsync(string username, UserpassResetPasswordRequest userpassResetPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassResetPassword");


            // verify the required parameter 'userpassResetPasswordRequest' is set
            if (userpassResetPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassResetPasswordRequest' when calling Auth->UserpassResetPassword");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.Data = userpassResetPasswordRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}/password", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassResetPassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassUpdatePoliciesRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassUpdatePolicies(string username, UserpassUpdatePoliciesRequest userpassUpdatePoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassUpdatePolicies");


            // verify the required parameter 'userpassUpdatePoliciesRequest' is set
            if (userpassUpdatePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUpdatePoliciesRequest' when calling Auth->UserpassUpdatePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter





            requestOptions.Data = userpassUpdatePoliciesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassUpdatePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassUpdatePoliciesRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassUpdatePoliciesAsync(string username, UserpassUpdatePoliciesRequest userpassUpdatePoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassUpdatePolicies");


            // verify the required parameter 'userpassUpdatePoliciesRequest' is set
            if (userpassUpdatePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUpdatePoliciesRequest' when calling Auth->UserpassUpdatePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.Data = userpassUpdatePoliciesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassUpdatePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassWriteUserRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> UserpassWriteUser(string username, UserpassWriteUserRequest userpassWriteUserRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassWriteUser");


            // verify the required parameter 'userpassWriteUserRequest' is set
            if (userpassWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassWriteUserRequest' when calling Auth->UserpassWriteUser");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                ""
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter





            requestOptions.Data = userpassWriteUserRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="userpassWriteUserRequest"></param>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UserpassWriteUserAsync(string username, UserpassWriteUserRequest userpassWriteUserRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UserpassWriteUser");


            // verify the required parameter 'userpassWriteUserRequest' is set
            if (userpassWriteUserRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassWriteUserRequest' when calling Auth->UserpassWriteUser");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                ""
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter


            requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter



            requestOptions.Data = userpassWriteUserRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UserpassWriteUser", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
    }
}
