// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
//
// Code generated with OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsSync : IApiAccessor
    {
        #region Synchronous Operations

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudConfigureRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudConfigure(AliCloudConfigureRequest aliCloudConfigureRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudDeleteConfiguration(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudDeleteRole(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate an API key or STS credential using the given role&#x27;s configuration.&#x27;
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudGenerateCredentials(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List the existing roles in this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudListRoles(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudReadConfiguration(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudReadRole(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteRoleRequest"></param>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AliCloudWriteRole(string name, AliCloudWriteRoleRequest aliCloudWriteRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureLeaseRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureLease(AwsConfigureLeaseRequest awsConfigureLeaseRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRootIamCredentialsRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsConfigureRootIamCredentials(AwsConfigureRootIamCredentialsRequest awsConfigureRootIamCredentialsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteRole(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsDeleteStaticRolesName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsGenerateCredentials(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsGenerateCredentialsWithParameters(string name, AwsGenerateCredentialsWithParametersRequest awsGenerateCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsGenerateStsCredentials(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateStsCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsGenerateStsCredentialsWithParameters(string name, AwsGenerateStsCredentialsWithParametersRequest awsGenerateStsCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsListRoles(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadLeaseConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRole(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsReadRootIamCredentialsConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsReadStaticCredsNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AwsReadStaticCredsNameResponse> AwsReadStaticCredsName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsReadStaticRolesNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AwsReadStaticRolesNameResponse> AwsReadStaticRolesName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsRotateRootIamCredentials(string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AwsWriteRole(string name, AwsWriteRoleRequest awsWriteRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStaticRolesNameRequest"></param>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsWriteStaticRolesNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<AwsWriteStaticRolesNameResponse> AwsWriteStaticRolesName(string name, AwsWriteStaticRolesNameRequest awsWriteStaticRolesNameRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureConfigure(AzureConfigureRequest azureConfigureRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureDeleteConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureDeleteRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List existing roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureListRoles(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureReadConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureReadRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureRequestServicePrincipalCredentials(string role, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureRotateRoot(string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> AzureWriteRole(string name, AzureWriteRoleRequest azureWriteRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigureAccessRequest"></param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulConfigureAccess(ConsulConfigureAccessRequest consulConfigureAccessRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulDeleteRole(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulGenerateCredentials(string role, string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulListRoles(string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulReadAccessConfiguration(string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulReadRole(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> ConsulWriteRole(string name, ConsulWriteRoleRequest consulWriteRoleRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CubbyholeDelete(string path, TimeSpan? wrapTTL = null);

        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CubbyholeRead(string path, string list = default(string), TimeSpan? wrapTTL = null);

        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> CubbyholeWrite(string path, TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseConfigureConnectionRequest"></param>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseConfigureConnection(string name, DatabaseConfigureConnectionRequest databaseConfigureConnectionRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseDeleteConnectionConfiguration(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseDeleteRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseDeleteStaticRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Request database credentials for a certain role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseGenerateCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configure connection details to a database plugin.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseListConnections(string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseListRoles(string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseListStaticRoles(string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseReadConnectionConfiguration(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseReadRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseReadStaticRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Request database credentials for a certain static role. These credentials are rotated periodically.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseReadStaticRoleCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Resets a database plugin.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseResetConnection(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseRotateRootCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseRotateStaticRoleCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseWriteRole(string name, DatabaseWriteRoleRequest databaseWriteRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DatabaseWriteStaticRole(string name, DatabaseWriteStaticRoleRequest databaseWriteStaticRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudConfigure(GoogleCloudConfigureRequest googleCloudConfigureRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudDeleteImpersonatedAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudDeleteRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudDeleteStaticAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the impersonated account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateImpersonatedAccountAccessToken(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateRolesetAccessToken(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateRolesetAccessTokenWithParameters(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateRolesetKey(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateRolesetKeyWithParametersRequest"></param>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateRolesetKeyWithParameters(string roleset, GoogleCloudGenerateRolesetKeyWithParametersRequest googleCloudGenerateRolesetKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateStaticAccountAccessToken(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateStaticAccountAccessTokenWithParameters(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateStaticAccountKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateStaticAccountKeyWithParametersRequest"></param>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudGenerateStaticAccountKeyWithParameters(string name, GoogleCloudGenerateStaticAccountKeyWithParametersRequest googleCloudGenerateStaticAccountKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureRequest"></param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsConfigure(GoogleCloudKmsConfigureRequest googleCloudKmsConfigureRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsConfigureKey(string key, GoogleCloudKmsConfigureKeyRequest googleCloudKmsConfigureKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsDecryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsDecrypt(string key, GoogleCloudKmsDecryptRequest googleCloudKmsDecryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsDeleteConfiguration(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsDeleteKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsDeregisterKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsEncryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsEncrypt(string key, GoogleCloudKmsEncryptRequest googleCloudKmsEncryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List named keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsListKeys(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsReadConfiguration(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsReadKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsReadKeyConfiguration(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsReencryptRequest"></param>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsReencrypt(string key, GoogleCloudKmsReencryptRequest googleCloudKmsReencryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsRegisterKeyRequest"></param>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsRegisterKey(string key, GoogleCloudKmsRegisterKeyRequest googleCloudKmsRegisterKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsRetrievePublicKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsRotateKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsSignRequest"></param>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsSign(string key, GoogleCloudKmsSignRequest googleCloudKmsSignRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsTrimKeyVersions(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsVerifyRequest"></param>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsVerify(string key, GoogleCloudKmsVerifyRequest googleCloudKmsVerifyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsWriteKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudKmsWriteKey(string key, GoogleCloudKmsWriteKeyRequest googleCloudKmsWriteKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudListImpersonatedAccounts(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudListRolesets(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudListStaticAccounts(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadConfiguration(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadImpersonatedAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudReadStaticAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudRotateRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudRotateRolesetKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudRotateRootCredentials(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudRotateStaticAccountKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteImpersonatedAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudWriteImpersonatedAccount(string name, GoogleCloudWriteImpersonatedAccountRequest googleCloudWriteImpersonatedAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRolesetRequest"></param>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudWriteRoleset(string name, GoogleCloudWriteRolesetRequest googleCloudWriteRolesetRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteStaticAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GoogleCloudWriteStaticAccount(string name, GoogleCloudWriteStaticAccountRequest googleCloudWriteStaticAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesCheckConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesConfigure(KubernetesConfigureRequest kubernetesConfigureRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesDeleteConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesDeleteRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesGenerateCredentialsRequest"></param>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesGenerateCredentials(string name, KubernetesGenerateCredentialsRequest kubernetesGenerateCredentialsRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesListRoles(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesReadConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesReadRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KubernetesWriteRole(string name, KubernetesWriteRoleRequest kubernetesWriteRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV1Delete(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV1Read(string path, string kvV1MountPath = "kv-v1", string list = default(string), TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV1Write(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2ConfigureRequest"></param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2Configure(KvV2ConfigureRequest kvV2ConfigureRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2Delete(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2DeleteMetadata(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2DeleteVersions(string path, KvV2DeleteVersionsRequest kvV2DeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DestroyVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2DestroyVersions(string path, KvV2DestroyVersionsRequest kvV2DestroyVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<KvV2ReadResponse> KvV2Read(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read the backend level settings.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<KvV2ReadConfigurationResponse> KvV2ReadConfiguration(string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of KvV2ReadMetadataResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<KvV2ReadMetadataResponse> KvV2ReadMetadata(string path, string kvV2MountPath = "kv-v2", string list = default(string), TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadSubkeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<KvV2ReadSubkeysResponse> KvV2ReadSubkeys(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2UndeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2UndeleteVersions(string path, KvV2UndeleteVersionsRequest kvV2UndeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2WriteResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<KvV2WriteResponse> KvV2Write(string path, KvV2WriteRequest kvV2WriteRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteMetadataRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> KvV2WriteMetadata(string path, KvV2WriteMetadataRequest kvV2WriteMetadataRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapConfigure(LdapConfigureRequest ldapConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapDeleteConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapDeleteDynamicRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapDeleteStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryCheckStatus(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryConfigureRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryConfigure(string name, LdapLibraryConfigureRequest ldapLibraryConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryDelete(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryForceCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryForceCheckIn(string name, LdapLibraryForceCheckInRequest ldapLibraryForceCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryList(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapLibraryRead(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapListDynamicRoles(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapListStaticRoles(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadDynamicRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapReadStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapRequestDynamicRoleCredentials(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapRequestStaticRoleCredentials(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapRotateRootCredentials(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapRotateStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteDynamicRoleRequest"></param>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapWriteDynamicRole(string name, LdapWriteDynamicRoleRequest ldapWriteDynamicRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> LdapWriteStaticRole(string name, LdapWriteStaticRoleRequest ldapWriteStaticRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasConfigureRequest"></param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasConfigure(MongoDbAtlasConfigureRequest mongoDbAtlasConfigureRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasDeleteRole(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasGenerateCredentials(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasListRoles(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasReadConfiguration(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasReadRole(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasWriteRoleRequest"></param>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> MongoDbAtlasWriteRole(string name, MongoDbAtlasWriteRoleRequest mongoDbAtlasWriteRoleRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureAccessRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadConfigureAccess(NomadConfigureAccessRequest nomadConfigureAccessRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureLeaseRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadConfigureLease(NomadConfigureLeaseRequest nomadConfigureLeaseRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadDeleteAccessConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadDeleteLeaseConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadDeleteRole(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadGenerateCredentials(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadListRoles(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadReadAccessConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadReadLeaseConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadReadRole(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> NomadWriteRole(string name, NomadWriteRoleRequest nomadWriteRoleRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAcmeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiConfigureAcme(PkiConfigureAcmeRequest pkiConfigureAcmeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureAutoTidyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureAutoTidyResponse> PkiConfigureAutoTidy(PkiConfigureAutoTidyRequest pkiConfigureAutoTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCaRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureCaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureCaResponse> PkiConfigureCa(PkiConfigureCaRequest pkiConfigureCaRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureClusterRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureClusterResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureClusterResponse> PkiConfigureCluster(PkiConfigureClusterRequest pkiConfigureClusterRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCrlRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureCrlResponse> PkiConfigureCrl(PkiConfigureCrlRequest pkiConfigureCrlRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureIssuersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureIssuersResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureIssuersResponse> PkiConfigureIssuers(PkiConfigureIssuersRequest pkiConfigureIssuersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureKeysRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureKeysResponse> PkiConfigureKeys(PkiConfigureKeysRequest pkiConfigureKeysRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureUrlsRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureUrlsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiConfigureUrlsResponse> PkiConfigureUrls(PkiConfigureUrlsRequest pkiConfigureUrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCrossSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiCrossSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiCrossSignIntermediateResponse> PkiCrossSignIntermediate(PkiCrossSignIntermediateRequest pkiCrossSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyId">EAB key identifier</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiDeleteEabKey(string keyId, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiDeleteIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiDeleteKey(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiDeleteRole(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiDeleteRoot(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateEabKeyResponse> PkiGenerateEabKey(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateEabKeyForIssuerResponse> PkiGenerateEabKeyForIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForIssuerAndRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse> PkiGenerateEabKeyForIssuerAndRole(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateEabKeyForRoleResponse> PkiGenerateEabKeyForRole(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateExportedKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateExportedKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateExportedKeyResponse> PkiGenerateExportedKey(PkiGenerateExportedKeyRequest pkiGenerateExportedKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateIntermediateResponse> PkiGenerateIntermediate(string exported, PkiGenerateIntermediateRequest pkiGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateInternalKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateInternalKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateInternalKeyResponse> PkiGenerateInternalKey(PkiGenerateInternalKeyRequest pkiGenerateInternalKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateKmsKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateKmsKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateKmsKeyResponse> PkiGenerateKmsKey(PkiGenerateKmsKeyRequest pkiGenerateKmsKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiGenerateRootResponse> PkiGenerateRoot(string exported, PkiGenerateRootRequest pkiGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiImportKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiImportKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiImportKeyResponse> PkiImportKey(PkiImportKeyRequest pkiImportKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssueWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssueWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssueWithRoleResponse> PkiIssueWithRole(string role, PkiIssueWithRoleRequest pkiIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerIssueWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerIssueWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerIssueWithRoleResponse> PkiIssuerIssueWithRole(string issuerRef, string role, PkiIssuerIssueWithRoleRequest pkiIssuerIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlResponse> PkiIssuerReadCrl(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlDeltaResponse> PkiIssuerReadCrlDelta(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlDeltaDerResponse> PkiIssuerReadCrlDeltaDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlDeltaPemResponse> PkiIssuerReadCrlDeltaPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlDerResponse> PkiIssuerReadCrlDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerReadCrlPemResponse> PkiIssuerReadCrlPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerResignCrlsRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerResignCrlsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerResignCrlsResponse> PkiIssuerResignCrls(string issuerRef, PkiIssuerResignCrlsRequest pkiIssuerResignCrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignIntermediateResponse> PkiIssuerSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignRevocationListRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignRevocationListResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignRevocationListResponse> PkiIssuerSignRevocationList(string issuerRef, PkiIssuerSignRevocationListRequest pkiIssuerSignRevocationListRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignSelfIssuedResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignSelfIssuedResponse> PkiIssuerSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignVerbatimResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignVerbatimResponse> PkiIssuerSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignVerbatimWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignVerbatimWithRoleResponse> PkiIssuerSignVerbatimWithRole(string issuerRef, string role, PkiIssuerSignVerbatimWithRoleRequest pkiIssuerSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuerSignWithRoleResponse> PkiIssuerSignWithRole(string issuerRef, string role, PkiIssuerSignWithRoleRequest pkiIssuerSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersGenerateIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuersGenerateIntermediateResponse> PkiIssuersGenerateIntermediate(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersGenerateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuersGenerateRootResponse> PkiIssuersGenerateRoot(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportBundleRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersImportBundleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuersImportBundleResponse> PkiIssuersImportBundle(PkiIssuersImportBundleRequest pkiIssuersImportBundleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersImportCertResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiIssuersImportCertResponse> PkiIssuersImportCert(PkiIssuersImportCertRequest pkiIssuersImportCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListCertsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListCertsResponse> PkiListCerts(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListEabKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListEabKeysResponse> PkiListEabKeys(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListIssuersResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListIssuersResponse> PkiListIssuers(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListKeysResponse> PkiListKeys(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListRevokedCertsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListRevokedCertsResponse> PkiListRevokedCerts(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListRolesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiListRolesResponse> PkiListRoles(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiQueryOcsp(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiQueryOcspWithGetReq(string req, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadAcmeConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadAcmeDirectory(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadAcmeNewNonce(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadAutoTidyConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadAutoTidyConfigurationResponse> PkiReadAutoTidyConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaChainPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCaChainPemResponse> PkiReadCaChainPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCaDerResponse> PkiReadCaDer(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCaPemResponse> PkiReadCaPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertResponse> PkiReadCert(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertCaChainResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertCaChainResponse> PkiReadCertCaChain(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertCrlResponse> PkiReadCertCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertDeltaCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertDeltaCrlResponse> PkiReadCertDeltaCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertRawDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertRawDerResponse> PkiReadCertRawDer(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertRawPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCertRawPemResponse> PkiReadCertRawPem(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadClusterConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadClusterConfigurationResponse> PkiReadClusterConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCrlConfigurationResponse> PkiReadCrlConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDeltaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCrlDeltaResponse> PkiReadCrlDelta(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDeltaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCrlDeltaPemResponse> PkiReadCrlDeltaPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCrlDerResponse> PkiReadCrlDer(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadCrlPemResponse> PkiReadCrlPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadIssuerResponse> PkiReadIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadIssuerDerResponse> PkiReadIssuerDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadIssuerIssuerRefAcmeDirectory(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadIssuerIssuerRefAcmeNewNonce(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadIssuerIssuerRefRolesRoleAcmeDirectory(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerJsonResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadIssuerJsonResponse> PkiReadIssuerJson(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadIssuerPemResponse> PkiReadIssuerPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuersConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadIssuersConfigurationResponse> PkiReadIssuersConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadKeyResponse> PkiReadKey(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadKeysConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadKeysConfigurationResponse> PkiReadKeysConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadRoleResponse> PkiReadRole(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadRolesRoleAcmeDirectory(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiReadRolesRoleAcmeNewNonce(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadUrlsConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReadUrlsConfigurationResponse> PkiReadUrlsConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiReplaceRootRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReplaceRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiReplaceRootResponse> PkiReplaceRoot(PkiReplaceRootRequest pkiReplaceRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRevokeResponse> PkiRevoke(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRevokeIssuerResponse> PkiRevokeIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeWithKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRevokeWithKeyResponse> PkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRootSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRootSignIntermediateResponse> PkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRootSignSelfIssuedResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRootSignSelfIssuedResponse> PkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRotateCrlResponse> PkiRotateCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateDeltaCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRotateDeltaCrlResponse> PkiRotateDeltaCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRotateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiRotateRootResponse> PkiRotateRoot(string exported, PkiRotateRootRequest pkiRotateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSetSignedIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSetSignedIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiSetSignedIntermediateResponse> PkiSetSignedIntermediate(PkiSetSignedIntermediateRequest pkiSetSignedIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignVerbatimResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiSignVerbatimResponse> PkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignVerbatimWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiSignVerbatimWithRoleResponse> PkiSignVerbatimWithRole(string role, PkiSignVerbatimWithRoleRequest pkiSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiSignWithRoleResponse> PkiSignWithRole(string role, PkiSignWithRoleRequest pkiSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiTidy(PkiTidyRequest pkiTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiTidyCancelResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiTidyCancelResponse> PkiTidyCancel(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiTidyStatusResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiTidyStatusResponse> PkiTidyStatus(string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeAccountKid(string kid, PkiWriteAcmeAccountKidRequest pkiWriteAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeAuthorizationAuthId(string authId, PkiWriteAcmeAuthorizationAuthIdRequest pkiWriteAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeChallengeAuthIdChallengeType(string authId, string challengeType, PkiWriteAcmeChallengeAuthIdChallengeTypeRequest pkiWriteAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewAccountRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeNewAccount(PkiWriteAcmeNewAccountRequest pkiWriteAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewOrderRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeNewOrder(PkiWriteAcmeNewOrderRequest pkiWriteAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeOrderOrderId(string orderId, PkiWriteAcmeOrderOrderIdRequest pkiWriteAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeOrderOrderIdCert(string orderId, PkiWriteAcmeOrderOrderIdCertRequest pkiWriteAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeOrderOrderIdFinalize(string orderId, PkiWriteAcmeOrderOrderIdFinalizeRequest pkiWriteAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrdersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeOrders(PkiWriteAcmeOrdersRequest pkiWriteAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeRevokeCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteAcmeRevokeCert(PkiWriteAcmeRevokeCertRequest pkiWriteAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiWriteIssuerResponse> PkiWriteIssuer(string issuerRef, PkiWriteIssuerRequest pkiWriteIssuerRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeAccountKid(string issuerRef, string kid, PkiWriteIssuerIssuerRefAcmeAccountKidRequest pkiWriteIssuerIssuerRefAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId(string authId, string issuerRef, PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string issuerRef, PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeNewAccount(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewAccountRequest pkiWriteIssuerIssuerRefAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeNewOrder(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewOrderRequest pkiWriteIssuerIssuerRefAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderId(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrders(string issuerRef, PkiWriteIssuerIssuerRefAcmeOrdersRequest pkiWriteIssuerIssuerRefAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeRevokeCert(string issuerRef, PkiWriteIssuerIssuerRefAcmeRevokeCertRequest pkiWriteIssuerIssuerRefAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid(string issuerRef, string kid, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId(string authId, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrders(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteKeyRequest"></param>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiWriteKeyResponse> PkiWriteKey(string keyRef, PkiWriteKeyRequest pkiWriteKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<PkiWriteRoleResponse> PkiWriteRole(string name, PkiWriteRoleRequest pkiWriteRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeAccountKid(string kid, string role, PkiWriteRolesRoleAcmeAccountKidRequest pkiWriteRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeAuthorizationAuthId(string authId, string role, PkiWriteRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string role, PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeNewAccount(string role, PkiWriteRolesRoleAcmeNewAccountRequest pkiWriteRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeNewOrder(string role, PkiWriteRolesRoleAcmeNewOrderRequest pkiWriteRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderId(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdRequest pkiWriteRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderIdCert(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdCertRequest pkiWriteRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderIdFinalize(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrdersRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeOrders(string role, PkiWriteRolesRoleAcmeOrdersRequest pkiWriteRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PkiWriteRolesRoleAcmeRevokeCert(string role, PkiWriteRolesRoleAcmeRevokeCertRequest pkiWriteRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqConfigureConnection(RabbitMqConfigureConnectionRequest rabbitMqConfigureConnectionRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqConfigureLease(RabbitMqConfigureLeaseRequest rabbitMqConfigureLeaseRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqDeleteRole(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqListRoles(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqReadLeaseConfiguration(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqReadRole(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Request RabbitMQ credentials for a certain role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqRequestCredentials(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> RabbitMqWriteRole(string name, RabbitMqWriteRoleRequest rabbitMqWriteRoleRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureCaRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshConfigureCa(SshConfigureCaRequest sshConfigureCaRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureZeroAddressRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshConfigureZeroAddress(SshConfigureZeroAddressRequest sshConfigureZeroAddressRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshDeleteCaConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshDeleteRole(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshDeleteZeroAddressConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshGenerateCredentialsRequest"></param>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshGenerateCredentials(string role, SshGenerateCredentialsRequest sshGenerateCredentialsRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshIssueCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshIssueCertificate(string role, SshIssueCertificateRequest sshIssueCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshListRoles(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshListRolesByIpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshListRolesByIp(SshListRolesByIpRequest sshListRolesByIpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshReadCaConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshReadPublicKey(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshReadRole(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshReadZeroAddressConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshSignCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshSignCertificate(string role, SshSignCertificateRequest sshSignCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// This endpoint removes the stored host keys used for the removed Dynamic Key feature, if present.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshTidyDynamicHostKeys(string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyOtpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshVerifyOtp(SshVerifyOtpRequest sshVerifyOtpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshWriteRoleRequest"></param>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> SshWriteRole(string role, SshWriteRoleRequest sshWriteRoleRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudConfigureRequest"></param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudConfigure(TerraformCloudConfigureRequest terraformCloudConfigureRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudDeleteConfiguration(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudDeleteRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudGenerateCredentials(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudListRoles(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudReadConfiguration(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudReadRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudRotateRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TerraformCloudWriteRole(string name, TerraformCloudWriteRoleRequest terraformCloudWriteRoleRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpCreateKeyRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpCreateKey(string name, TotpCreateKeyRequest totpCreateKeyRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpDeleteKey(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpGenerateCode(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpListKeys(string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpReadKey(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpValidateCodeRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TotpValidateCode(string name, TotpValidateCodeRequest totpValidateCodeRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitBackUpKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Securely export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitByokKey(string destination, string source, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Securely export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="version">Optional version of the key to export, else all key versions are exported.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitByokKeyVersion(string destination, string source, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureCacheRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitConfigureCache(TransitConfigureCacheRequest transitConfigureCacheRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitConfigureKey(string name, TransitConfigureKeyRequest transitConfigureKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeysRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitConfigureKeys(TransitConfigureKeysRequest transitConfigureKeysRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCreateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitCreateKey(string name, TransitCreateKeyRequest transitCreateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitDecrypt(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitDeleteKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitEncrypt(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitExportKey(string name, string type, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitExportKeyVersion(string name, string type, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateDataKeyRequest"></param>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateDataKey(string name, string plaintext, TransitGenerateDataKeyRequest transitGenerateDataKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateHmac(string name, TransitGenerateHmacRequest transitGenerateHmacRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacWithAlgorithmRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateHmacWithAlgorithm(string name, string urlalgorithm, TransitGenerateHmacWithAlgorithmRequest transitGenerateHmacWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateRandom(TransitGenerateRandomRequest transitGenerateRandomRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithBytesRequest"></param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateRandomWithBytes(string urlbytes, TransitGenerateRandomWithBytesRequest transitGenerateRandomWithBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateRandomWithSource(string source, TransitGenerateRandomWithSourceRequest transitGenerateRandomWithSourceRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceAndBytesRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitGenerateRandomWithSourceAndBytes(string source, string urlbytes, TransitGenerateRandomWithSourceAndBytesRequest transitGenerateRandomWithSourceAndBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitHash(TransitHashRequest transitHashRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashWithAlgorithmRequest"></param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitHashWithAlgorithm(string urlalgorithm, TransitHashWithAlgorithmRequest transitHashWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitImportKey(string name, TransitImportKeyRequest transitImportKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyVersionRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitImportKeyVersion(string name, TransitImportKeyVersionRequest transitImportKeyVersionRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitListKeys(string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitReadCacheConfiguration(string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitReadKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitReadKeysConfiguration(string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitReadWrappingKey(string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreAndRenameKeyRequest"></param>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitRestoreAndRenameKey(string name, TransitRestoreAndRenameKeyRequest transitRestoreAndRenameKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreKeyRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitRestoreKey(TransitRestoreKeyRequest transitRestoreKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitRewrap(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRotateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitRotateKey(string name, TransitRotateKeyRequest transitRotateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitSign(string name, TransitSignRequest transitSignRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitSignWithAlgorithm(string name, string urlalgorithm, TransitSignWithAlgorithmRequest transitSignWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitTrimKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitTrimKey(string name, TransitTrimKeyRequest transitTrimKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitVerify(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> TransitVerifyWithAlgorithm(string name, string urlalgorithm, TransitVerifyWithAlgorithmRequest transitVerifyWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null);

        #endregion Synchronous Operations
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecretsAsync : IApiAccessor
    {
        #region Asynchronous Operations

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudConfigureRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudConfigureAsync(AliCloudConfigureRequest aliCloudConfigureRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudDeleteConfigurationAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudDeleteRoleAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate an API key or STS credential using the given role&#x27;s configuration.&#x27;
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudGenerateCredentialsAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List the existing roles in this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudListRolesAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudReadConfigurationAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudReadRoleAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteRoleRequest"></param>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AliCloudWriteRoleAsync(string name, AliCloudWriteRoleRequest aliCloudWriteRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureLeaseRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureLeaseAsync(AwsConfigureLeaseRequest awsConfigureLeaseRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRootIamCredentialsRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsConfigureRootIamCredentialsAsync(AwsConfigureRootIamCredentialsRequest awsConfigureRootIamCredentialsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteRoleAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsDeleteStaticRolesNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsGenerateCredentialsAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsGenerateCredentialsWithParametersAsync(string name, AwsGenerateCredentialsWithParametersRequest awsGenerateCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsGenerateStsCredentialsAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateStsCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsGenerateStsCredentialsWithParametersAsync(string name, AwsGenerateStsCredentialsWithParametersRequest awsGenerateStsCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsListRolesAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadLeaseConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRoleAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsReadRootIamCredentialsConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsReadStaticCredsNameResponse)</returns>
        Task<VaultResponse<AwsReadStaticCredsNameResponse>> AwsReadStaticCredsNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsReadStaticRolesNameResponse)</returns>
        Task<VaultResponse<AwsReadStaticRolesNameResponse>> AwsReadStaticRolesNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsRotateRootIamCredentialsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AwsWriteRoleAsync(string name, AwsWriteRoleRequest awsWriteRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStaticRolesNameRequest"></param>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsWriteStaticRolesNameResponse)</returns>
        Task<VaultResponse<AwsWriteStaticRolesNameResponse>> AwsWriteStaticRolesNameAsync(string name, AwsWriteStaticRolesNameRequest awsWriteStaticRolesNameRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureConfigureAsync(AzureConfigureRequest azureConfigureRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureDeleteConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureDeleteRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List existing roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureListRolesAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureReadConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureReadRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureRequestServicePrincipalCredentialsAsync(string role, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureRotateRootAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AzureWriteRoleAsync(string name, AzureWriteRoleRequest azureWriteRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigureAccessRequest"></param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulConfigureAccessAsync(ConsulConfigureAccessRequest consulConfigureAccessRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulDeleteRoleAsync(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulGenerateCredentialsAsync(string role, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulListRolesAsync(string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulReadAccessConfigurationAsync(string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulReadRoleAsync(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ConsulWriteRoleAsync(string name, ConsulWriteRoleRequest consulWriteRoleRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Deletes the secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CubbyholeDeleteAsync(string path, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Retrieve the secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CubbyholeReadAsync(string path, string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Store a secret at the specified location.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> CubbyholeWriteAsync(string path, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseConfigureConnectionRequest"></param>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseConfigureConnectionAsync(string name, DatabaseConfigureConnectionRequest databaseConfigureConnectionRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseDeleteConnectionConfigurationAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseDeleteRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseDeleteStaticRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request database credentials for a certain role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseGenerateCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configure connection details to a database plugin.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseListConnectionsAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseListRolesAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseListStaticRolesAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseReadConnectionConfigurationAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseReadRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseReadStaticRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request database credentials for a certain static role. These credentials are rotated periodically.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseReadStaticRoleCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Resets a database plugin.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseResetConnectionAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseRotateRootCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseRotateStaticRoleCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseWriteRoleAsync(string name, DatabaseWriteRoleRequest databaseWriteRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the static roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DatabaseWriteStaticRoleAsync(string name, DatabaseWriteStaticRoleRequest databaseWriteStaticRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudConfigureAsync(GoogleCloudConfigureRequest googleCloudConfigureRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudDeleteImpersonatedAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudDeleteRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudDeleteStaticAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the impersonated account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateImpersonatedAccountAccessTokenAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateRolesetAccessTokenAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateRolesetAccessTokenWithParametersAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateRolesetKeyAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateRolesetKeyWithParametersRequest"></param>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateRolesetKeyWithParametersAsync(string roleset, GoogleCloudGenerateRolesetKeyWithParametersRequest googleCloudGenerateRolesetKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountAccessTokenAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountAccessTokenWithParametersAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateStaticAccountKeyWithParametersRequest"></param>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountKeyWithParametersAsync(string name, GoogleCloudGenerateStaticAccountKeyWithParametersRequest googleCloudGenerateStaticAccountKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureRequest"></param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsConfigureAsync(GoogleCloudKmsConfigureRequest googleCloudKmsConfigureRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsConfigureKeyAsync(string key, GoogleCloudKmsConfigureKeyRequest googleCloudKmsConfigureKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsDecryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsDecryptAsync(string key, GoogleCloudKmsDecryptRequest googleCloudKmsDecryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsDeleteConfigurationAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsDeleteKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsDeregisterKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Encrypt a plaintext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsEncryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsEncryptAsync(string key, GoogleCloudKmsEncryptRequest googleCloudKmsEncryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List named keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsListKeysAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsReadConfigurationAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsReadKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsReadKeyConfigurationAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsReencryptRequest"></param>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsReencryptAsync(string key, GoogleCloudKmsReencryptRequest googleCloudKmsReencryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsRegisterKeyRequest"></param>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsRegisterKeyAsync(string key, GoogleCloudKmsRegisterKeyRequest googleCloudKmsRegisterKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Retrieve the public key associated with the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsRetrievePublicKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Rotate a crypto key to a new primary version
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsRotateKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Signs a message or digest using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsSignRequest"></param>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsSignAsync(string key, GoogleCloudKmsSignRequest googleCloudKmsSignRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsTrimKeyVersionsAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Verify a signature using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsVerifyRequest"></param>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsVerifyAsync(string key, GoogleCloudKmsVerifyRequest googleCloudKmsVerifyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsWriteKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudKmsWriteKeyAsync(string key, GoogleCloudKmsWriteKeyRequest googleCloudKmsWriteKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudListImpersonatedAccountsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudListRolesetsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudListStaticAccountsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadConfigurationAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadImpersonatedAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudReadStaticAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudRotateRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudRotateRolesetKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudRotateRootCredentialsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudRotateStaticAccountKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteImpersonatedAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudWriteImpersonatedAccountAsync(string name, GoogleCloudWriteImpersonatedAccountRequest googleCloudWriteImpersonatedAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRolesetRequest"></param>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudWriteRolesetAsync(string name, GoogleCloudWriteRolesetRequest googleCloudWriteRolesetRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteStaticAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GoogleCloudWriteStaticAccountAsync(string name, GoogleCloudWriteStaticAccountRequest googleCloudWriteStaticAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesCheckConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesConfigureAsync(KubernetesConfigureRequest kubernetesConfigureRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesDeleteConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesDeleteRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesGenerateCredentialsRequest"></param>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesGenerateCredentialsAsync(string name, KubernetesGenerateCredentialsRequest kubernetesGenerateCredentialsRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesListRolesAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesReadConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesReadRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KubernetesWriteRoleAsync(string name, KubernetesWriteRoleRequest kubernetesWriteRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV1DeleteAsync(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV1ReadAsync(string path, string kvV1MountPath = "kv-v1", string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV1WriteAsync(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2ConfigureRequest"></param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2ConfigureAsync(KvV2ConfigureRequest kvV2ConfigureRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2DeleteAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2DeleteMetadataAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2DeleteVersionsAsync(string path, KvV2DeleteVersionsRequest kvV2DeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DestroyVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2DestroyVersionsAsync(string path, KvV2DestroyVersionsRequest kvV2DestroyVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadResponse)</returns>
        Task<VaultResponse<KvV2ReadResponse>> KvV2ReadAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read the backend level settings.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadConfigurationResponse)</returns>
        Task<VaultResponse<KvV2ReadConfigurationResponse>> KvV2ReadConfigurationAsync(string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadMetadataResponse)</returns>
        Task<VaultResponse<KvV2ReadMetadataResponse>> KvV2ReadMetadataAsync(string path, string kvV2MountPath = "kv-v2", string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadSubkeysResponse)</returns>
        Task<VaultResponse<KvV2ReadSubkeysResponse>> KvV2ReadSubkeysAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2UndeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2UndeleteVersionsAsync(string path, KvV2UndeleteVersionsRequest kvV2UndeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2WriteResponse)</returns>
        Task<VaultResponse<KvV2WriteResponse>> KvV2WriteAsync(string path, KvV2WriteRequest kvV2WriteRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteMetadataRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> KvV2WriteMetadataAsync(string path, KvV2WriteMetadataRequest kvV2WriteMetadataRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapConfigureAsync(LdapConfigureRequest ldapConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapDeleteConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapDeleteDynamicRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapDeleteStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Check a service account out from the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Check the status of the service accounts in a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryCheckStatusAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryConfigureRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryConfigureAsync(string name, LdapLibraryConfigureRequest ldapLibraryConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryDeleteAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Check service accounts in to the library.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryForceCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryForceCheckInAsync(string name, LdapLibraryForceCheckInRequest ldapLibraryForceCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryListAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Read a library set.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapLibraryReadAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapListDynamicRolesAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapListStaticRolesAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadDynamicRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapReadStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapRequestDynamicRoleCredentialsAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapRequestStaticRoleCredentialsAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapRotateRootCredentialsAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapRotateStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteDynamicRoleRequest"></param>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapWriteDynamicRoleAsync(string name, LdapWriteDynamicRoleRequest ldapWriteDynamicRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> LdapWriteStaticRoleAsync(string name, LdapWriteStaticRoleRequest ldapWriteStaticRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasConfigureRequest"></param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasConfigureAsync(MongoDbAtlasConfigureRequest mongoDbAtlasConfigureRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasDeleteRoleAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasGenerateCredentialsAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List the existing roles in this backend
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasListRolesAsync(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasReadConfigurationAsync(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasReadRoleAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasWriteRoleRequest"></param>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> MongoDbAtlasWriteRoleAsync(string name, MongoDbAtlasWriteRoleRequest mongoDbAtlasWriteRoleRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureAccessRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadConfigureAccessAsync(NomadConfigureAccessRequest nomadConfigureAccessRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureLeaseRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadConfigureLeaseAsync(NomadConfigureLeaseRequest nomadConfigureLeaseRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadDeleteAccessConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadDeleteLeaseConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadDeleteRoleAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadGenerateCredentialsAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadListRolesAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadReadAccessConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadReadLeaseConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadReadRoleAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> NomadWriteRoleAsync(string name, NomadWriteRoleRequest nomadWriteRoleRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAcmeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiConfigureAcmeAsync(PkiConfigureAcmeRequest pkiConfigureAcmeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureAutoTidyResponse)</returns>
        Task<VaultResponse<PkiConfigureAutoTidyResponse>> PkiConfigureAutoTidyAsync(PkiConfigureAutoTidyRequest pkiConfigureAutoTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCaRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureCaResponse)</returns>
        Task<VaultResponse<PkiConfigureCaResponse>> PkiConfigureCaAsync(PkiConfigureCaRequest pkiConfigureCaRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureClusterRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureClusterResponse)</returns>
        Task<VaultResponse<PkiConfigureClusterResponse>> PkiConfigureClusterAsync(PkiConfigureClusterRequest pkiConfigureClusterRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCrlRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureCrlResponse)</returns>
        Task<VaultResponse<PkiConfigureCrlResponse>> PkiConfigureCrlAsync(PkiConfigureCrlRequest pkiConfigureCrlRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureIssuersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureIssuersResponse)</returns>
        Task<VaultResponse<PkiConfigureIssuersResponse>> PkiConfigureIssuersAsync(PkiConfigureIssuersRequest pkiConfigureIssuersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureKeysRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureKeysResponse)</returns>
        Task<VaultResponse<PkiConfigureKeysResponse>> PkiConfigureKeysAsync(PkiConfigureKeysRequest pkiConfigureKeysRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureUrlsRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureUrlsResponse)</returns>
        Task<VaultResponse<PkiConfigureUrlsResponse>> PkiConfigureUrlsAsync(PkiConfigureUrlsRequest pkiConfigureUrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCrossSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiCrossSignIntermediateResponse)</returns>
        Task<VaultResponse<PkiCrossSignIntermediateResponse>> PkiCrossSignIntermediateAsync(PkiCrossSignIntermediateRequest pkiCrossSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyId">EAB key identifier</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiDeleteEabKeyAsync(string keyId, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiDeleteIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiDeleteKeyAsync(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiDeleteRoleAsync(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiDeleteRootAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyResponse)</returns>
        Task<VaultResponse<PkiGenerateEabKeyResponse>> PkiGenerateEabKeyAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForIssuerResponse)</returns>
        Task<VaultResponse<PkiGenerateEabKeyForIssuerResponse>> PkiGenerateEabKeyForIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForIssuerAndRoleResponse)</returns>
        Task<VaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse>> PkiGenerateEabKeyForIssuerAndRoleAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForRoleResponse)</returns>
        Task<VaultResponse<PkiGenerateEabKeyForRoleResponse>> PkiGenerateEabKeyForRoleAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateExportedKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateExportedKeyResponse)</returns>
        Task<VaultResponse<PkiGenerateExportedKeyResponse>> PkiGenerateExportedKeyAsync(PkiGenerateExportedKeyRequest pkiGenerateExportedKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateIntermediateResponse)</returns>
        Task<VaultResponse<PkiGenerateIntermediateResponse>> PkiGenerateIntermediateAsync(string exported, PkiGenerateIntermediateRequest pkiGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateInternalKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateInternalKeyResponse)</returns>
        Task<VaultResponse<PkiGenerateInternalKeyResponse>> PkiGenerateInternalKeyAsync(PkiGenerateInternalKeyRequest pkiGenerateInternalKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateKmsKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateKmsKeyResponse)</returns>
        Task<VaultResponse<PkiGenerateKmsKeyResponse>> PkiGenerateKmsKeyAsync(PkiGenerateKmsKeyRequest pkiGenerateKmsKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateRootResponse)</returns>
        Task<VaultResponse<PkiGenerateRootResponse>> PkiGenerateRootAsync(string exported, PkiGenerateRootRequest pkiGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiImportKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiImportKeyResponse)</returns>
        Task<VaultResponse<PkiImportKeyResponse>> PkiImportKeyAsync(PkiImportKeyRequest pkiImportKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssueWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssueWithRoleResponse)</returns>
        Task<VaultResponse<PkiIssueWithRoleResponse>> PkiIssueWithRoleAsync(string role, PkiIssueWithRoleRequest pkiIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerIssueWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerIssueWithRoleResponse)</returns>
        Task<VaultResponse<PkiIssuerIssueWithRoleResponse>> PkiIssuerIssueWithRoleAsync(string issuerRef, string role, PkiIssuerIssueWithRoleRequest pkiIssuerIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlResponse>> PkiIssuerReadCrlAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlDeltaResponse>> PkiIssuerReadCrlDeltaAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaDerResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlDeltaDerResponse>> PkiIssuerReadCrlDeltaDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaPemResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlDeltaPemResponse>> PkiIssuerReadCrlDeltaPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDerResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlDerResponse>> PkiIssuerReadCrlDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlPemResponse)</returns>
        Task<VaultResponse<PkiIssuerReadCrlPemResponse>> PkiIssuerReadCrlPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerResignCrlsRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerResignCrlsResponse)</returns>
        Task<VaultResponse<PkiIssuerResignCrlsResponse>> PkiIssuerResignCrlsAsync(string issuerRef, PkiIssuerResignCrlsRequest pkiIssuerResignCrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignIntermediateResponse)</returns>
        Task<VaultResponse<PkiIssuerSignIntermediateResponse>> PkiIssuerSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignRevocationListRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignRevocationListResponse)</returns>
        Task<VaultResponse<PkiIssuerSignRevocationListResponse>> PkiIssuerSignRevocationListAsync(string issuerRef, PkiIssuerSignRevocationListRequest pkiIssuerSignRevocationListRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignSelfIssuedResponse)</returns>
        Task<VaultResponse<PkiIssuerSignSelfIssuedResponse>> PkiIssuerSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignVerbatimResponse)</returns>
        Task<VaultResponse<PkiIssuerSignVerbatimResponse>> PkiIssuerSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignVerbatimWithRoleResponse)</returns>
        Task<VaultResponse<PkiIssuerSignVerbatimWithRoleResponse>> PkiIssuerSignVerbatimWithRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimWithRoleRequest pkiIssuerSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignWithRoleResponse)</returns>
        Task<VaultResponse<PkiIssuerSignWithRoleResponse>> PkiIssuerSignWithRoleAsync(string issuerRef, string role, PkiIssuerSignWithRoleRequest pkiIssuerSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersGenerateIntermediateResponse)</returns>
        Task<VaultResponse<PkiIssuersGenerateIntermediateResponse>> PkiIssuersGenerateIntermediateAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersGenerateRootResponse)</returns>
        Task<VaultResponse<PkiIssuersGenerateRootResponse>> PkiIssuersGenerateRootAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportBundleRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersImportBundleResponse)</returns>
        Task<VaultResponse<PkiIssuersImportBundleResponse>> PkiIssuersImportBundleAsync(PkiIssuersImportBundleRequest pkiIssuersImportBundleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersImportCertResponse)</returns>
        Task<VaultResponse<PkiIssuersImportCertResponse>> PkiIssuersImportCertAsync(PkiIssuersImportCertRequest pkiIssuersImportCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListCertsResponse)</returns>
        Task<VaultResponse<PkiListCertsResponse>> PkiListCertsAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListEabKeysResponse)</returns>
        Task<VaultResponse<PkiListEabKeysResponse>> PkiListEabKeysAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListIssuersResponse)</returns>
        Task<VaultResponse<PkiListIssuersResponse>> PkiListIssuersAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListKeysResponse)</returns>
        Task<VaultResponse<PkiListKeysResponse>> PkiListKeysAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListRevokedCertsResponse)</returns>
        Task<VaultResponse<PkiListRevokedCertsResponse>> PkiListRevokedCertsAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListRolesResponse)</returns>
        Task<VaultResponse<PkiListRolesResponse>> PkiListRolesAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiQueryOcspAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiQueryOcspWithGetReqAsync(string req, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadAcmeConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadAcmeDirectoryAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadAcmeNewNonceAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadAutoTidyConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadAutoTidyConfigurationResponse>> PkiReadAutoTidyConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaChainPemResponse)</returns>
        Task<VaultResponse<PkiReadCaChainPemResponse>> PkiReadCaChainPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaDerResponse)</returns>
        Task<VaultResponse<PkiReadCaDerResponse>> PkiReadCaDerAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaPemResponse)</returns>
        Task<VaultResponse<PkiReadCaPemResponse>> PkiReadCaPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertResponse)</returns>
        Task<VaultResponse<PkiReadCertResponse>> PkiReadCertAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertCaChainResponse)</returns>
        Task<VaultResponse<PkiReadCertCaChainResponse>> PkiReadCertCaChainAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertCrlResponse)</returns>
        Task<VaultResponse<PkiReadCertCrlResponse>> PkiReadCertCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertDeltaCrlResponse)</returns>
        Task<VaultResponse<PkiReadCertDeltaCrlResponse>> PkiReadCertDeltaCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertRawDerResponse)</returns>
        Task<VaultResponse<PkiReadCertRawDerResponse>> PkiReadCertRawDerAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertRawPemResponse)</returns>
        Task<VaultResponse<PkiReadCertRawPemResponse>> PkiReadCertRawPemAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadClusterConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadClusterConfigurationResponse>> PkiReadClusterConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadCrlConfigurationResponse>> PkiReadCrlConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDeltaResponse)</returns>
        Task<VaultResponse<PkiReadCrlDeltaResponse>> PkiReadCrlDeltaAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDeltaPemResponse)</returns>
        Task<VaultResponse<PkiReadCrlDeltaPemResponse>> PkiReadCrlDeltaPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDerResponse)</returns>
        Task<VaultResponse<PkiReadCrlDerResponse>> PkiReadCrlDerAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlPemResponse)</returns>
        Task<VaultResponse<PkiReadCrlPemResponse>> PkiReadCrlPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerResponse)</returns>
        Task<VaultResponse<PkiReadIssuerResponse>> PkiReadIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerDerResponse)</returns>
        Task<VaultResponse<PkiReadIssuerDerResponse>> PkiReadIssuerDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadIssuerIssuerRefAcmeDirectoryAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadIssuerIssuerRefAcmeNewNonceAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadIssuerIssuerRefRolesRoleAcmeDirectoryAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadIssuerIssuerRefRolesRoleAcmeNewNonceAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerJsonResponse)</returns>
        Task<VaultResponse<PkiReadIssuerJsonResponse>> PkiReadIssuerJsonAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerPemResponse)</returns>
        Task<VaultResponse<PkiReadIssuerPemResponse>> PkiReadIssuerPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuersConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadIssuersConfigurationResponse>> PkiReadIssuersConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadKeyResponse)</returns>
        Task<VaultResponse<PkiReadKeyResponse>> PkiReadKeyAsync(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadKeysConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadKeysConfigurationResponse>> PkiReadKeysConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadRoleResponse)</returns>
        Task<VaultResponse<PkiReadRoleResponse>> PkiReadRoleAsync(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadRolesRoleAcmeDirectoryAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiReadRolesRoleAcmeNewNonceAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadUrlsConfigurationResponse)</returns>
        Task<VaultResponse<PkiReadUrlsConfigurationResponse>> PkiReadUrlsConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiReplaceRootRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReplaceRootResponse)</returns>
        Task<VaultResponse<PkiReplaceRootResponse>> PkiReplaceRootAsync(PkiReplaceRootRequest pkiReplaceRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeResponse)</returns>
        Task<VaultResponse<PkiRevokeResponse>> PkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeIssuerResponse)</returns>
        Task<VaultResponse<PkiRevokeIssuerResponse>> PkiRevokeIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeWithKeyResponse)</returns>
        Task<VaultResponse<PkiRevokeWithKeyResponse>> PkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRootSignIntermediateResponse)</returns>
        Task<VaultResponse<PkiRootSignIntermediateResponse>> PkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRootSignSelfIssuedResponse)</returns>
        Task<VaultResponse<PkiRootSignSelfIssuedResponse>> PkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateCrlResponse)</returns>
        Task<VaultResponse<PkiRotateCrlResponse>> PkiRotateCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateDeltaCrlResponse)</returns>
        Task<VaultResponse<PkiRotateDeltaCrlResponse>> PkiRotateDeltaCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRotateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateRootResponse)</returns>
        Task<VaultResponse<PkiRotateRootResponse>> PkiRotateRootAsync(string exported, PkiRotateRootRequest pkiRotateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSetSignedIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSetSignedIntermediateResponse)</returns>
        Task<VaultResponse<PkiSetSignedIntermediateResponse>> PkiSetSignedIntermediateAsync(PkiSetSignedIntermediateRequest pkiSetSignedIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignVerbatimResponse)</returns>
        Task<VaultResponse<PkiSignVerbatimResponse>> PkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignVerbatimWithRoleResponse)</returns>
        Task<VaultResponse<PkiSignVerbatimWithRoleResponse>> PkiSignVerbatimWithRoleAsync(string role, PkiSignVerbatimWithRoleRequest pkiSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignWithRoleResponse)</returns>
        Task<VaultResponse<PkiSignWithRoleResponse>> PkiSignWithRoleAsync(string role, PkiSignWithRoleRequest pkiSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiTidyAsync(PkiTidyRequest pkiTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiTidyCancelResponse)</returns>
        Task<VaultResponse<PkiTidyCancelResponse>> PkiTidyCancelAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiTidyStatusResponse)</returns>
        Task<VaultResponse<PkiTidyStatusResponse>> PkiTidyStatusAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeAccountKidAsync(string kid, PkiWriteAcmeAccountKidRequest pkiWriteAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeAuthorizationAuthIdAsync(string authId, PkiWriteAcmeAuthorizationAuthIdRequest pkiWriteAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, PkiWriteAcmeChallengeAuthIdChallengeTypeRequest pkiWriteAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewAccountRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeNewAccountAsync(PkiWriteAcmeNewAccountRequest pkiWriteAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewOrderRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeNewOrderAsync(PkiWriteAcmeNewOrderRequest pkiWriteAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdAsync(string orderId, PkiWriteAcmeOrderOrderIdRequest pkiWriteAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdCertAsync(string orderId, PkiWriteAcmeOrderOrderIdCertRequest pkiWriteAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdFinalizeAsync(string orderId, PkiWriteAcmeOrderOrderIdFinalizeRequest pkiWriteAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrdersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeOrdersAsync(PkiWriteAcmeOrdersRequest pkiWriteAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeRevokeCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteAcmeRevokeCertAsync(PkiWriteAcmeRevokeCertRequest pkiWriteAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteIssuerResponse)</returns>
        Task<VaultResponse<PkiWriteIssuerResponse>> PkiWriteIssuerAsync(string issuerRef, PkiWriteIssuerRequest pkiWriteIssuerRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeAccountKidAsync(string issuerRef, string kid, PkiWriteIssuerIssuerRefAcmeAccountKidRequest pkiWriteIssuerIssuerRefAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdAsync(string authId, string issuerRef, PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string issuerRef, PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeNewAccountAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewAccountRequest pkiWriteIssuerIssuerRefAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeNewOrderAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewOrderRequest pkiWriteIssuerIssuerRefAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrdersAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeOrdersRequest pkiWriteIssuerIssuerRefAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeRevokeCertAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeRevokeCertRequest pkiWriteIssuerIssuerRefAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidAsync(string issuerRef, string kid, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdAsync(string authId, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteKeyRequest"></param>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteKeyResponse)</returns>
        Task<VaultResponse<PkiWriteKeyResponse>> PkiWriteKeyAsync(string keyRef, PkiWriteKeyRequest pkiWriteKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteRoleResponse)</returns>
        Task<VaultResponse<PkiWriteRoleResponse>> PkiWriteRoleAsync(string name, PkiWriteRoleRequest pkiWriteRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeAccountKidAsync(string kid, string role, PkiWriteRolesRoleAcmeAccountKidRequest pkiWriteRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeAuthorizationAuthIdAsync(string authId, string role, PkiWriteRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string role, PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeNewAccountAsync(string role, PkiWriteRolesRoleAcmeNewAccountRequest pkiWriteRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeNewOrderAsync(string role, PkiWriteRolesRoleAcmeNewOrderRequest pkiWriteRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdRequest pkiWriteRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdCertAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdCertRequest pkiWriteRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdFinalizeAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrdersRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrdersAsync(string role, PkiWriteRolesRoleAcmeOrdersRequest pkiWriteRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeRevokeCertAsync(string role, PkiWriteRolesRoleAcmeRevokeCertRequest pkiWriteRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqConfigureConnectionAsync(RabbitMqConfigureConnectionRequest rabbitMqConfigureConnectionRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqConfigureLeaseAsync(RabbitMqConfigureLeaseRequest rabbitMqConfigureLeaseRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqDeleteRoleAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqListRolesAsync(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqReadLeaseConfigurationAsync(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqReadRoleAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request RabbitMQ credentials for a certain role.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqRequestCredentialsAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the roles that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> RabbitMqWriteRoleAsync(string name, RabbitMqWriteRoleRequest rabbitMqWriteRoleRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureCaRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshConfigureCaAsync(SshConfigureCaRequest sshConfigureCaRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureZeroAddressRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshConfigureZeroAddressAsync(SshConfigureZeroAddressRequest sshConfigureZeroAddressRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshDeleteCaConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshDeleteRoleAsync(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshDeleteZeroAddressConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshGenerateCredentialsRequest"></param>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshGenerateCredentialsAsync(string role, SshGenerateCredentialsRequest sshGenerateCredentialsRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshIssueCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshIssueCertificateAsync(string role, SshIssueCertificateRequest sshIssueCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshListRolesAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List all the roles associated with the given IP address.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshListRolesByIpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshListRolesByIpAsync(SshListRolesByIpRequest sshListRolesByIpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshReadCaConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Retrieve the public key.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshReadPublicKeyAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshReadRoleAsync(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshReadZeroAddressConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshSignCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshSignCertificateAsync(string role, SshSignCertificateRequest sshSignCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// This endpoint removes the stored host keys used for the removed Dynamic Key feature, if present.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshTidyDynamicHostKeysAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyOtpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshVerifyOtpAsync(SshVerifyOtpRequest sshVerifyOtpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshWriteRoleRequest"></param>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> SshWriteRoleAsync(string role, SshWriteRoleRequest sshWriteRoleRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudConfigureRequest"></param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudConfigureAsync(TerraformCloudConfigureRequest terraformCloudConfigureRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudDeleteConfigurationAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudDeleteRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudGenerateCredentialsAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudListRolesAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudReadConfigurationAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudReadRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudRotateRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TerraformCloudWriteRoleAsync(string name, TerraformCloudWriteRoleRequest terraformCloudWriteRoleRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpCreateKeyRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpCreateKeyAsync(string name, TotpCreateKeyRequest totpCreateKeyRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpDeleteKeyAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpGenerateCodeAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Manage the keys that can be created with this backend.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpListKeysAsync(string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpReadKeyAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpValidateCodeRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TotpValidateCodeAsync(string name, TotpValidateCodeRequest totpValidateCodeRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Backup the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitBackUpKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Securely export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitByokKeyAsync(string destination, string source, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Securely export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="version">Optional version of the key to export, else all key versions are exported.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitByokKeyVersionAsync(string destination, string source, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configures a new cache of the specified size
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureCacheRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitConfigureCacheAsync(TransitConfigureCacheRequest transitConfigureCacheRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Configure a named encryption key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitConfigureKeyAsync(string name, TransitConfigureKeyRequest transitConfigureKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeysRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitConfigureKeysAsync(TransitConfigureKeysRequest transitConfigureKeysRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCreateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitCreateKeyAsync(string name, TransitCreateKeyRequest transitCreateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Decrypt a ciphertext value using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitDecryptAsync(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitDeleteKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitEncryptAsync(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitExportKeyAsync(string name, string type, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Export named encryption or signing key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitExportKeyVersionAsync(string name, string type, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate a data key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateDataKeyRequest"></param>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateDataKeyAsync(string name, string plaintext, TransitGenerateDataKeyRequest transitGenerateDataKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateHmacAsync(string name, TransitGenerateHmacRequest transitGenerateHmacRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate an HMAC for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacWithAlgorithmRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateHmacWithAlgorithmAsync(string name, string urlalgorithm, TransitGenerateHmacWithAlgorithmRequest transitGenerateHmacWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateRandomAsync(TransitGenerateRandomRequest transitGenerateRandomRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithBytesRequest"></param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateRandomWithBytesAsync(string urlbytes, TransitGenerateRandomWithBytesRequest transitGenerateRandomWithBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateRandomWithSourceAsync(string source, TransitGenerateRandomWithSourceRequest transitGenerateRandomWithSourceRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceAndBytesRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitGenerateRandomWithSourceAndBytesAsync(string source, string urlbytes, TransitGenerateRandomWithSourceAndBytesRequest transitGenerateRandomWithSourceAndBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitHashAsync(TransitHashRequest transitHashRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashWithAlgorithmRequest"></param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitHashWithAlgorithmAsync(string urlalgorithm, TransitHashWithAlgorithmRequest transitHashWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Imports an externally-generated key into a new transit key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitImportKeyAsync(string name, TransitImportKeyRequest transitImportKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Imports an externally-generated key into an existing imported key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyVersionRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitImportKeyVersionAsync(string name, TransitImportKeyVersionRequest transitImportKeyVersionRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Managed named encryption keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitListKeysAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the size of the active cache
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitReadCacheConfigurationAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitReadKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitReadKeysConfigurationAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Returns the public key to use for wrapping imported keys
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitReadWrappingKeyAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreAndRenameKeyRequest"></param>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitRestoreAndRenameKeyAsync(string name, TransitRestoreAndRenameKeyRequest transitRestoreAndRenameKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Restore the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreKeyRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitRestoreKeyAsync(TransitRestoreKeyRequest transitRestoreKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Rewrap ciphertext
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitRewrapAsync(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Rotate named encryption key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRotateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitRotateKeyAsync(string name, TransitRotateKeyRequest transitRotateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitSignAsync(string name, TransitSignRequest transitSignRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Generate a signature for input data using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitSignWithAlgorithmAsync(string name, string urlalgorithm, TransitSignWithAlgorithmRequest transitSignWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Trim key versions of a named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitTrimKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitTrimKeyAsync(string name, TransitTrimKeyRequest transitTrimKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitVerifyAsync(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> TransitVerifyWithAlgorithmAsync(string name, string urlalgorithm, TransitVerifyWithAlgorithmRequest transitVerifyWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));

        #endregion Asynchronous Operations
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISecrets : ISecretsSync, ISecretsAsync { }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Secrets : ISecrets
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Secrets
        /// </summary>
        public Secrets(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");

            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = VaultConfiguration.DefaultExceptionFactory;
        }


        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }


        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public VaultConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudConfigureRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudConfigure(AliCloudConfigureRequest aliCloudConfigureRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'aliCloudConfigureRequest' is set
            if (aliCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudConfigureRequest' when calling Secrets->AliCloudConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter





            requestOptions.Data = aliCloudConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudConfigureRequest"></param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudConfigureAsync(AliCloudConfigureRequest aliCloudConfigureRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'aliCloudConfigureRequest' is set
            if (aliCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudConfigureRequest' when calling Secrets->AliCloudConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.Data = aliCloudConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudDeleteConfiguration(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudDeleteConfigurationAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudDeleteRole(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudDeleteRoleAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate an API key or STS credential using the given role&#x27;s configuration.&#x27; 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudGenerateCredentials(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate an API key or STS credential using the given role&#x27;s configuration.&#x27; 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudGenerateCredentialsAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List the existing roles in this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudListRoles(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudListRolesAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudReadConfiguration(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudReadConfigurationAsync(string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudReadRole(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudReadRoleAsync(string name, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteRoleRequest"></param>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AliCloudWriteRole(string name, AliCloudWriteRoleRequest aliCloudWriteRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudWriteRole");


            // verify the required parameter 'aliCloudWriteRoleRequest' is set
            if (aliCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudWriteRoleRequest' when calling Secrets->AliCloudWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter





            requestOptions.Data = aliCloudWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{alicloud_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference policies and roles that API keys or STS credentials can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="aliCloudWriteRoleRequest"></param>
        /// <param name="name">The name of the role.</param>
        /// <param name="alicloudMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AliCloudWriteRoleAsync(string name, AliCloudWriteRoleRequest aliCloudWriteRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AliCloudWriteRole");


            // verify the required parameter 'aliCloudWriteRoleRequest' is set
            if (aliCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'aliCloudWriteRoleRequest' when calling Secrets->AliCloudWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter



            requestOptions.Data = aliCloudWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{alicloud_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AliCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureLeaseRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureLease(AwsConfigureLeaseRequest awsConfigureLeaseRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureLeaseRequest' is set
            if (awsConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureLeaseRequest' when calling Secrets->AwsConfigureLease");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureLeaseRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureLeaseRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureLeaseAsync(AwsConfigureLeaseRequest awsConfigureLeaseRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureLeaseRequest' is set
            if (awsConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureLeaseRequest' when calling Secrets->AwsConfigureLease");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureLeaseRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRootIamCredentialsRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsConfigureRootIamCredentials(AwsConfigureRootIamCredentialsRequest awsConfigureRootIamCredentialsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'awsConfigureRootIamCredentialsRequest' is set
            if (awsConfigureRootIamCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRootIamCredentialsRequest' when calling Secrets->AwsConfigureRootIamCredentials");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsConfigureRootIamCredentialsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRootIamCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigureRootIamCredentialsRequest"></param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsConfigureRootIamCredentialsAsync(AwsConfigureRootIamCredentialsRequest awsConfigureRootIamCredentialsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'awsConfigureRootIamCredentialsRequest' is set
            if (awsConfigureRootIamCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigureRootIamCredentialsRequest' when calling Secrets->AwsConfigureRootIamCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsConfigureRootIamCredentialsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsConfigureRootIamCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteRole(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteRoleAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsDeleteStaticRolesName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsDeleteStaticRolesName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{aws_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsDeleteStaticRolesNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsDeleteStaticRolesName");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{aws_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsDeleteStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsGenerateCredentials(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsGenerateCredentialsAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsGenerateCredentialsWithParameters(string name, AwsGenerateCredentialsWithParametersRequest awsGenerateCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateCredentialsWithParameters");


            // verify the required parameter 'awsGenerateCredentialsWithParametersRequest' is set
            if (awsGenerateCredentialsWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsGenerateCredentialsWithParametersRequest' when calling Secrets->AwsGenerateCredentialsWithParameters");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsGenerateCredentialsWithParametersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateCredentialsWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsGenerateCredentialsWithParametersAsync(string name, AwsGenerateCredentialsWithParametersRequest awsGenerateCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateCredentialsWithParameters");


            // verify the required parameter 'awsGenerateCredentialsWithParametersRequest' is set
            if (awsGenerateCredentialsWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsGenerateCredentialsWithParametersRequest' when calling Secrets->AwsGenerateCredentialsWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsGenerateCredentialsWithParametersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateCredentialsWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsGenerateStsCredentials(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateStsCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateStsCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsGenerateStsCredentialsAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateStsCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateStsCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateStsCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsGenerateStsCredentialsWithParameters(string name, AwsGenerateStsCredentialsWithParametersRequest awsGenerateStsCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateStsCredentialsWithParameters");


            // verify the required parameter 'awsGenerateStsCredentialsWithParametersRequest' is set
            if (awsGenerateStsCredentialsWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsGenerateStsCredentialsWithParametersRequest' when calling Secrets->AwsGenerateStsCredentialsWithParameters");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsGenerateStsCredentialsWithParametersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/sts/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateStsCredentialsWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsGenerateStsCredentialsWithParametersRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsGenerateStsCredentialsWithParametersAsync(string name, AwsGenerateStsCredentialsWithParametersRequest awsGenerateStsCredentialsWithParametersRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsGenerateStsCredentialsWithParameters");


            // verify the required parameter 'awsGenerateStsCredentialsWithParametersRequest' is set
            if (awsGenerateStsCredentialsWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsGenerateStsCredentialsWithParametersRequest' when calling Secrets->AwsGenerateStsCredentialsWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsGenerateStsCredentialsWithParametersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/sts/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsGenerateStsCredentialsWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsListRoles(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsListRolesAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadLeaseConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadLeaseConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRole(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRoleAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsReadRootIamCredentialsConfiguration(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{aws_mount_path}/config/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRootIamCredentialsConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsReadRootIamCredentialsConfigurationAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{aws_mount_path}/config/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadRootIamCredentialsConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsReadStaticCredsNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AwsReadStaticCredsNameResponse> AwsReadStaticCredsName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadStaticCredsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AwsReadStaticCredsNameResponse>("/{aws_mount_path}/static-creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStaticCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsReadStaticCredsNameResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsReadStaticCredsNameResponse)</returns>
        public async Task<VaultResponse<AwsReadStaticCredsNameResponse>> AwsReadStaticCredsNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadStaticCredsName");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AwsReadStaticCredsNameResponse>("/{aws_mount_path}/static-creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStaticCredsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsReadStaticCredsNameResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsReadStaticRolesNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AwsReadStaticRolesNameResponse> AwsReadStaticRolesName(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadStaticRolesName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<AwsReadStaticRolesNameResponse>("/{aws_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsReadStaticRolesNameResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsReadStaticRolesNameResponse)</returns>
        public async Task<VaultResponse<AwsReadStaticRolesNameResponse>> AwsReadStaticRolesNameAsync(string name, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsReadStaticRolesName");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<AwsReadStaticRolesNameResponse>("/{aws_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsReadStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsReadStaticRolesNameResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsRotateRootIamCredentials(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsRotateRootIamCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsRotateRootIamCredentialsAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsRotateRootIamCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AwsWriteRole(string name, AwsWriteRoleRequest awsWriteRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsWriteRole");


            // verify the required parameter 'awsWriteRoleRequest' is set
            if (awsWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteRoleRequest' when calling Secrets->AwsWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{aws_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read, write and reference IAM policies that access keys can be made for. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AwsWriteRoleAsync(string name, AwsWriteRoleRequest awsWriteRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsWriteRole");


            // verify the required parameter 'awsWriteRoleRequest' is set
            if (awsWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteRoleRequest' when calling Secrets->AwsWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{aws_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStaticRolesNameRequest"></param>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of AwsWriteStaticRolesNameResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<AwsWriteStaticRolesNameResponse> AwsWriteStaticRolesName(string name, AwsWriteStaticRolesNameRequest awsWriteStaticRolesNameRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsWriteStaticRolesName");


            // verify the required parameter 'awsWriteStaticRolesNameRequest' is set
            if (awsWriteStaticRolesNameRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteStaticRolesNameRequest' when calling Secrets->AwsWriteStaticRolesName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter





            requestOptions.Data = awsWriteStaticRolesNameRequest;


            // make the HTTP request
            var response = this.Client.Post<AwsWriteStaticRolesNameResponse>("/{aws_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsWriteStaticRolesNameResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsWriteStaticRolesNameRequest"></param>
        /// <param name="name">The name of this role.</param>
        /// <param name="awsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (AwsWriteStaticRolesNameResponse)</returns>
        public async Task<VaultResponse<AwsWriteStaticRolesNameResponse>> AwsWriteStaticRolesNameAsync(string name, AwsWriteStaticRolesNameRequest awsWriteStaticRolesNameRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AwsWriteStaticRolesName");


            // verify the required parameter 'awsWriteStaticRolesNameRequest' is set
            if (awsWriteStaticRolesNameRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsWriteStaticRolesNameRequest' when calling Secrets->AwsWriteStaticRolesName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter



            requestOptions.Data = awsWriteStaticRolesNameRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<AwsWriteStaticRolesNameResponse>("/{aws_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AwsWriteStaticRolesName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<AwsWriteStaticRolesNameResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureConfigure(AzureConfigureRequest azureConfigureRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'azureConfigureRequest' is set
            if (azureConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigureRequest' when calling Secrets->AzureConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter





            requestOptions.Data = azureConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigureRequest"></param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureConfigureAsync(AzureConfigureRequest azureConfigureRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'azureConfigureRequest' is set
            if (azureConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigureRequest' when calling Secrets->AzureConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.Data = azureConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureDeleteConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureDeleteConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureDeleteRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureDeleteRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List existing roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureListRoles(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List existing roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureListRolesAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureReadConfiguration(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureReadConfigurationAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureReadRole(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureReadRoleAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureRequestServicePrincipalCredentials(string role, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->AzureRequestServicePrincipalCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{azure_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRequestServicePrincipalCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the Vault role</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureRequestServicePrincipalCredentialsAsync(string role, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->AzureRequestServicePrincipalCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{azure_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRequestServicePrincipalCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureRotateRoot(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureRotateRootAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> AzureWriteRole(string name, AzureWriteRoleRequest azureWriteRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureWriteRole");


            // verify the required parameter 'azureWriteRoleRequest' is set
            if (azureWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureWriteRoleRequest' when calling Secrets->AzureWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter





            requestOptions.Data = azureWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{azure_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the Vault roles used to generate Azure credentials. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AzureWriteRoleAsync(string name, AzureWriteRoleRequest azureWriteRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->AzureWriteRole");


            // verify the required parameter 'azureWriteRoleRequest' is set
            if (azureWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureWriteRoleRequest' when calling Secrets->AzureWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter



            requestOptions.Data = azureWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{azure_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AzureWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigureAccessRequest"></param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulConfigureAccess(ConsulConfigureAccessRequest consulConfigureAccessRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'consulConfigureAccessRequest' is set
            if (consulConfigureAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulConfigureAccessRequest' when calling Secrets->ConsulConfigureAccess");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter





            requestOptions.Data = consulConfigureAccessRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{consul_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulConfigureAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulConfigureAccessRequest"></param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulConfigureAccessAsync(ConsulConfigureAccessRequest consulConfigureAccessRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'consulConfigureAccessRequest' is set
            if (consulConfigureAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulConfigureAccessRequest' when calling Secrets->ConsulConfigureAccess");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            requestOptions.Data = consulConfigureAccessRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{consul_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulConfigureAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulDeleteRole(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulDeleteRoleAsync(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulGenerateCredentials(string role, string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ConsulGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulGenerateCredentialsAsync(string role, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->ConsulGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulListRoles(string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulListRolesAsync(string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulReadAccessConfiguration(string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulReadAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulReadAccessConfigurationAsync(string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulReadAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulReadRole(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulReadRoleAsync(string name, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> ConsulWriteRole(string name, ConsulWriteRoleRequest consulWriteRoleRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulWriteRole");


            // verify the required parameter 'consulWriteRoleRequest' is set
            if (consulWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulWriteRoleRequest' when calling Secrets->ConsulWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter





            requestOptions.Data = consulWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{consul_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="consulWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="consulMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ConsulWriteRoleAsync(string name, ConsulWriteRoleRequest consulWriteRoleRequest, string consulMountPath = "consul", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->ConsulWriteRole");


            // verify the required parameter 'consulWriteRoleRequest' is set
            if (consulWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'consulWriteRoleRequest' when calling Secrets->ConsulWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("consul_mount_path", ClientUtils.ParameterToString(consulMountPath)); // path parameter



            requestOptions.Data = consulWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{consul_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ConsulWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CubbyholeDelete(string path, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeDelete");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/cubbyhole/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeDelete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Deletes the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CubbyholeDeleteAsync(string path, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeDelete");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/cubbyhole/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeDelete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CubbyholeRead(string path, string list = default(string), TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeRead");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter




            if (list != null)
            {


                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            }



            // make the HTTP request
            var response = this.Client.Get<Object>("/cubbyhole/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeRead", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CubbyholeReadAsync(string path, string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeRead");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter




            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }
            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/cubbyhole/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeRead", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> CubbyholeWrite(string path, TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeWrite");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/cubbyhole/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeWrite", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Store a secret at the specified location. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Specifies the path of the secret.</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> CubbyholeWriteAsync(string path, TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->CubbyholeWrite");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/cubbyhole/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CubbyholeWrite", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseConfigureConnectionRequest"></param>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseConfigureConnection(string name, DatabaseConfigureConnectionRequest databaseConfigureConnectionRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseConfigureConnection");


            // verify the required parameter 'databaseConfigureConnectionRequest' is set
            if (databaseConfigureConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseConfigureConnectionRequest' when calling Secrets->DatabaseConfigureConnection");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter





            requestOptions.Data = databaseConfigureConnectionRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/config/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseConfigureConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseConfigureConnectionRequest"></param>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseConfigureConnectionAsync(string name, DatabaseConfigureConnectionRequest databaseConfigureConnectionRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseConfigureConnection");


            // verify the required parameter 'databaseConfigureConnectionRequest' is set
            if (databaseConfigureConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseConfigureConnectionRequest' when calling Secrets->DatabaseConfigureConnection");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.Data = databaseConfigureConnectionRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/config/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseConfigureConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseDeleteConnectionConfiguration(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteConnectionConfiguration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{database_mount_path}/config/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteConnectionConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseDeleteConnectionConfigurationAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteConnectionConfiguration");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{database_mount_path}/config/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteConnectionConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseDeleteRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{database_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseDeleteRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{database_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseDeleteStaticRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{database_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseDeleteStaticRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseDeleteStaticRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{database_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseDeleteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Request database credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseGenerateCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Request database credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseGenerateCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configure connection details to a database plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseListConnections(string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListConnections", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configure connection details to a database plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseListConnectionsAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListConnections", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseListRoles(string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseListRolesAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseListStaticRoles(string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/static-roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListStaticRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseListStaticRolesAsync(string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/static-roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseListStaticRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseReadConnectionConfiguration(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadConnectionConfiguration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/config/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadConnectionConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseReadConnectionConfigurationAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadConnectionConfiguration");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/config/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadConnectionConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseReadRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseReadRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseReadStaticRole(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseReadStaticRoleAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadStaticRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Request database credentials for a certain static role. These credentials are rotated periodically. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseReadStaticRoleCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadStaticRoleCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{database_mount_path}/static-creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Request database credentials for a certain static role. These credentials are rotated periodically. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseReadStaticRoleCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseReadStaticRoleCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{database_mount_path}/static-creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseReadStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Resets a database plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseResetConnection(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseResetConnection");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/reset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseResetConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Resets a database plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseResetConnectionAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseResetConnection");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/reset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseResetConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseRotateRootCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseRotateRootCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/rotate-root/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of this database connection</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseRotateRootCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseRotateRootCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/rotate-root/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseRotateStaticRoleCredentials(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseRotateStaticRoleCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseRotateStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseRotateStaticRoleCredentialsAsync(string name, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseRotateStaticRoleCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseRotateStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseWriteRole(string name, DatabaseWriteRoleRequest databaseWriteRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseWriteRole");


            // verify the required parameter 'databaseWriteRoleRequest' is set
            if (databaseWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseWriteRoleRequest' when calling Secrets->DatabaseWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter





            requestOptions.Data = databaseWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseWriteRoleAsync(string name, DatabaseWriteRoleRequest databaseWriteRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseWriteRole");


            // verify the required parameter 'databaseWriteRoleRequest' is set
            if (databaseWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseWriteRoleRequest' when calling Secrets->DatabaseWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.Data = databaseWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DatabaseWriteStaticRole(string name, DatabaseWriteStaticRoleRequest databaseWriteStaticRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseWriteStaticRole");


            // verify the required parameter 'databaseWriteStaticRoleRequest' is set
            if (databaseWriteStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseWriteStaticRoleRequest' when calling Secrets->DatabaseWriteStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter





            requestOptions.Data = databaseWriteStaticRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{database_mount_path}/static-roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseWriteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the static roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="databaseWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="databaseMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DatabaseWriteStaticRoleAsync(string name, DatabaseWriteStaticRoleRequest databaseWriteStaticRoleRequest, string databaseMountPath = "database", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->DatabaseWriteStaticRole");


            // verify the required parameter 'databaseWriteStaticRoleRequest' is set
            if (databaseWriteStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'databaseWriteStaticRoleRequest' when calling Secrets->DatabaseWriteStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("database_mount_path", ClientUtils.ParameterToString(databaseMountPath)); // path parameter



            requestOptions.Data = databaseWriteStaticRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{database_mount_path}/static-roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DatabaseWriteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudConfigure(GoogleCloudConfigureRequest googleCloudConfigureRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'googleCloudConfigureRequest' is set
            if (googleCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudConfigureRequest' when calling Secrets->GoogleCloudConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudConfigureRequest"></param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudConfigureAsync(GoogleCloudConfigureRequest googleCloudConfigureRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'googleCloudConfigureRequest' is set
            if (googleCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudConfigureRequest' when calling Secrets->GoogleCloudConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudDeleteImpersonatedAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteImpersonatedAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudDeleteImpersonatedAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteImpersonatedAccount");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudDeleteRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteRoleset");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudDeleteRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteRoleset");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudDeleteStaticAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteStaticAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudDeleteStaticAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudDeleteStaticAccount");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudDeleteStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the impersonated account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateImpersonatedAccountAccessToken(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateImpersonatedAccountAccessToken");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/impersonated-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateImpersonatedAccountAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the impersonated account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateImpersonatedAccountAccessTokenAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateImpersonatedAccountAccessToken");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/impersonated-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateImpersonatedAccountAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateRolesetAccessToken(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetAccessToken");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateRolesetAccessTokenAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetAccessToken");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateRolesetAccessTokenWithParameters(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetAccessTokenWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetAccessTokenWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateRolesetAccessTokenWithParametersAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetAccessTokenWithParameters");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetAccessTokenWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateRolesetKey(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateRolesetKeyAsync(string roleset, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateRolesetKeyWithParametersRequest"></param>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateRolesetKeyWithParameters(string roleset, GoogleCloudGenerateRolesetKeyWithParametersRequest googleCloudGenerateRolesetKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetKeyWithParameters");


            // verify the required parameter 'googleCloudGenerateRolesetKeyWithParametersRequest' is set
            if (googleCloudGenerateRolesetKeyWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudGenerateRolesetKeyWithParametersRequest' when calling Secrets->GoogleCloudGenerateRolesetKeyWithParameters");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudGenerateRolesetKeyWithParametersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetKeyWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateRolesetKeyWithParametersRequest"></param>
        /// <param name="roleset">Required. Name of the role set.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateRolesetKeyWithParametersAsync(string roleset, GoogleCloudGenerateRolesetKeyWithParametersRequest googleCloudGenerateRolesetKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'roleset' is set
            if (roleset == null)
                throw new VaultApiException(400, "Missing required parameter 'roleset' when calling Secrets->GoogleCloudGenerateRolesetKeyWithParameters");


            // verify the required parameter 'googleCloudGenerateRolesetKeyWithParametersRequest' is set
            if (googleCloudGenerateRolesetKeyWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudGenerateRolesetKeyWithParametersRequest' when calling Secrets->GoogleCloudGenerateRolesetKeyWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("roleset", ClientUtils.ParameterToString(roleset)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudGenerateRolesetKeyWithParametersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{roleset}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateRolesetKeyWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateStaticAccountAccessToken(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountAccessToken");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountAccessTokenAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountAccessToken");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountAccessToken", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateStaticAccountAccessTokenWithParameters(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountAccessTokenWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountAccessTokenWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountAccessTokenWithParametersAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountAccessTokenWithParameters");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/token", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountAccessTokenWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateStaticAccountKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateStaticAccountKeyWithParametersRequest"></param>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudGenerateStaticAccountKeyWithParameters(string name, GoogleCloudGenerateStaticAccountKeyWithParametersRequest googleCloudGenerateStaticAccountKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountKeyWithParameters");


            // verify the required parameter 'googleCloudGenerateStaticAccountKeyWithParametersRequest' is set
            if (googleCloudGenerateStaticAccountKeyWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudGenerateStaticAccountKeyWithParametersRequest' when calling Secrets->GoogleCloudGenerateStaticAccountKeyWithParameters");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudGenerateStaticAccountKeyWithParametersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountKeyWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudGenerateStaticAccountKeyWithParametersRequest"></param>
        /// <param name="name">Required. Name of the static account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudGenerateStaticAccountKeyWithParametersAsync(string name, GoogleCloudGenerateStaticAccountKeyWithParametersRequest googleCloudGenerateStaticAccountKeyWithParametersRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudGenerateStaticAccountKeyWithParameters");


            // verify the required parameter 'googleCloudGenerateStaticAccountKeyWithParametersRequest' is set
            if (googleCloudGenerateStaticAccountKeyWithParametersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudGenerateStaticAccountKeyWithParametersRequest' when calling Secrets->GoogleCloudGenerateStaticAccountKeyWithParameters");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudGenerateStaticAccountKeyWithParametersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudGenerateStaticAccountKeyWithParameters", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureRequest"></param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsConfigure(GoogleCloudKmsConfigureRequest googleCloudKmsConfigureRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'googleCloudKmsConfigureRequest' is set
            if (googleCloudKmsConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsConfigureRequest' when calling Secrets->GoogleCloudKmsConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureRequest"></param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsConfigureAsync(GoogleCloudKmsConfigureRequest googleCloudKmsConfigureRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'googleCloudKmsConfigureRequest' is set
            if (googleCloudKmsConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsConfigureRequest' when calling Secrets->GoogleCloudKmsConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsConfigureKey(string key, GoogleCloudKmsConfigureKeyRequest googleCloudKmsConfigureKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsConfigureKey");


            // verify the required parameter 'googleCloudKmsConfigureKeyRequest' is set
            if (googleCloudKmsConfigureKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsConfigureKeyRequest' when calling Secrets->GoogleCloudKmsConfigureKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsConfigureKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsConfigureKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsConfigureKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsConfigureKeyAsync(string key, GoogleCloudKmsConfigureKeyRequest googleCloudKmsConfigureKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsConfigureKey");


            // verify the required parameter 'googleCloudKmsConfigureKeyRequest' is set
            if (googleCloudKmsConfigureKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsConfigureKeyRequest' when calling Secrets->GoogleCloudKmsConfigureKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsConfigureKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsConfigureKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsDecryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsDecrypt(string key, GoogleCloudKmsDecryptRequest googleCloudKmsDecryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDecrypt");


            // verify the required parameter 'googleCloudKmsDecryptRequest' is set
            if (googleCloudKmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsDecryptRequest' when calling Secrets->GoogleCloudKmsDecrypt");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsDecryptRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/decrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDecrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsDecryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsDecryptAsync(string key, GoogleCloudKmsDecryptRequest googleCloudKmsDecryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDecrypt");


            // verify the required parameter 'googleCloudKmsDecryptRequest' is set
            if (googleCloudKmsDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsDecryptRequest' when calling Secrets->GoogleCloudKmsDecrypt");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsDecryptRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/decrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDecrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsDeleteConfiguration(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsDeleteConfigurationAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsDeleteKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDeleteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsDeleteKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDeleteKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsDeregisterKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDeregisterKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsDeregisterKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsDeregisterKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/deregister/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsDeregisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsEncryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsEncrypt(string key, GoogleCloudKmsEncryptRequest googleCloudKmsEncryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsEncrypt");


            // verify the required parameter 'googleCloudKmsEncryptRequest' is set
            if (googleCloudKmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsEncryptRequest' when calling Secrets->GoogleCloudKmsEncrypt");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsEncryptRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/encrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsEncrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsEncryptRequest"></param>
        /// <param name="key">Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsEncryptAsync(string key, GoogleCloudKmsEncryptRequest googleCloudKmsEncryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsEncrypt");


            // verify the required parameter 'googleCloudKmsEncryptRequest' is set
            if (googleCloudKmsEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsEncryptRequest' when calling Secrets->GoogleCloudKmsEncrypt");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsEncryptRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/encrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsEncrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List named keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsListKeys(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List named keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsListKeysAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsReadConfiguration(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsReadConfigurationAsync(string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsReadKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReadKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsReadKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReadKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsReadKeyConfiguration(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReadKeyConfiguration");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadKeyConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsReadKeyConfigurationAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReadKeyConfiguration");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/keys/config/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReadKeyConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsReencryptRequest"></param>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsReencrypt(string key, GoogleCloudKmsReencryptRequest googleCloudKmsReencryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReencrypt");


            // verify the required parameter 'googleCloudKmsReencryptRequest' is set
            if (googleCloudKmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsReencryptRequest' when calling Secrets->GoogleCloudKmsReencrypt");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsReencryptRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/reencrypt/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReencrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Re-encrypt existing ciphertext data to a new version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsReencryptRequest"></param>
        /// <param name="key">Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsReencryptAsync(string key, GoogleCloudKmsReencryptRequest googleCloudKmsReencryptRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsReencrypt");


            // verify the required parameter 'googleCloudKmsReencryptRequest' is set
            if (googleCloudKmsReencryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsReencryptRequest' when calling Secrets->GoogleCloudKmsReencrypt");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsReencryptRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/reencrypt/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsReencrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsRegisterKeyRequest"></param>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsRegisterKey(string key, GoogleCloudKmsRegisterKeyRequest googleCloudKmsRegisterKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRegisterKey");


            // verify the required parameter 'googleCloudKmsRegisterKeyRequest' is set
            if (googleCloudKmsRegisterKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsRegisterKeyRequest' when calling Secrets->GoogleCloudKmsRegisterKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsRegisterKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/register/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Register an existing crypto key in Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsRegisterKeyRequest"></param>
        /// <param name="key">Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsRegisterKeyAsync(string key, GoogleCloudKmsRegisterKeyRequest googleCloudKmsRegisterKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRegisterKey");


            // verify the required parameter 'googleCloudKmsRegisterKeyRequest' is set
            if (googleCloudKmsRegisterKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsRegisterKeyRequest' when calling Secrets->GoogleCloudKmsRegisterKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsRegisterKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/register/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRegisterKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsRetrievePublicKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRetrievePublicKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcpkms_mount_path}/pubkey/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRetrievePublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key associated with the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsRetrievePublicKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRetrievePublicKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcpkms_mount_path}/pubkey/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRetrievePublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsRotateKey(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/rotate/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Rotate a crypto key to a new primary version 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsRotateKeyAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsRotateKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/rotate/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsSignRequest"></param>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsSign(string key, GoogleCloudKmsSignRequest googleCloudKmsSignRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsSign");


            // verify the required parameter 'googleCloudKmsSignRequest' is set
            if (googleCloudKmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsSignRequest' when calling Secrets->GoogleCloudKmsSign");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsSignRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/sign/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Signs a message or digest using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsSignRequest"></param>
        /// <param name="key">Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsSignAsync(string key, GoogleCloudKmsSignRequest googleCloudKmsSignRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsSign");


            // verify the required parameter 'googleCloudKmsSignRequest' is set
            if (googleCloudKmsSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsSignRequest' when calling Secrets->GoogleCloudKmsSign");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsSignRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/sign/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsTrimKeyVersions(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsTrimKeyVersions");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsTrimKeyVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsTrimKeyVersionsAsync(string key, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsTrimKeyVersions");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/trim/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsTrimKeyVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsVerifyRequest"></param>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsVerify(string key, GoogleCloudKmsVerifyRequest googleCloudKmsVerifyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsVerify");


            // verify the required parameter 'googleCloudKmsVerifyRequest' is set
            if (googleCloudKmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsVerifyRequest' when calling Secrets->GoogleCloudKmsVerify");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsVerifyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/verify/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsVerifyRequest"></param>
        /// <param name="key">Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsVerifyAsync(string key, GoogleCloudKmsVerifyRequest googleCloudKmsVerifyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsVerify");


            // verify the required parameter 'googleCloudKmsVerifyRequest' is set
            if (googleCloudKmsVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsVerifyRequest' when calling Secrets->GoogleCloudKmsVerify");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsVerifyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/verify/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsWriteKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudKmsWriteKey(string key, GoogleCloudKmsWriteKeyRequest googleCloudKmsWriteKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsWriteKey");


            // verify the required parameter 'googleCloudKmsWriteKeyRequest' is set
            if (googleCloudKmsWriteKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsWriteKeyRequest' when calling Secrets->GoogleCloudKmsWriteKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter





            requestOptions.Data = googleCloudKmsWriteKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsWriteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Interact with crypto keys in Vault and Google Cloud KMS 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudKmsWriteKeyRequest"></param>
        /// <param name="key">Name of the key in Vault.</param>
        /// <param name="gcpkmsMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudKmsWriteKeyAsync(string key, GoogleCloudKmsWriteKeyRequest googleCloudKmsWriteKeyRequest, string gcpkmsMountPath = "gcpkms", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Secrets->GoogleCloudKmsWriteKey");


            // verify the required parameter 'googleCloudKmsWriteKeyRequest' is set
            if (googleCloudKmsWriteKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudKmsWriteKeyRequest' when calling Secrets->GoogleCloudKmsWriteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter


            requestOptions.PathParameters.Add("gcpkms_mount_path", ClientUtils.ParameterToString(gcpkmsMountPath)); // path parameter



            requestOptions.Data = googleCloudKmsWriteKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcpkms_mount_path}/keys/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudKmsWriteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudListImpersonatedAccounts(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/impersonated-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListImpersonatedAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudListImpersonatedAccountsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/impersonated-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListImpersonatedAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudListRolesets(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudListRolesetsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListRolesets", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudListStaticAccounts(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudListStaticAccountsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudListStaticAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadConfiguration(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadConfigurationAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadImpersonatedAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadImpersonatedAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadImpersonatedAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadImpersonatedAccount");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadRoleset");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadRoleset");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudReadStaticAccount(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadStaticAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudReadStaticAccountAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudReadStaticAccount");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudReadStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudRotateRoleset(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateRoleset");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudRotateRolesetAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateRoleset");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudRotateRolesetKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateRolesetKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudRotateRolesetKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateRolesetKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRolesetKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudRotateRootCredentials(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudRotateRootCredentialsAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudRotateStaticAccountKey(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateStaticAccountKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}/rotate-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateStaticAccountKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the account.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudRotateStaticAccountKeyAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudRotateStaticAccountKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}/rotate-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudRotateStaticAccountKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteImpersonatedAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudWriteImpersonatedAccount(string name, GoogleCloudWriteImpersonatedAccountRequest googleCloudWriteImpersonatedAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteImpersonatedAccount");


            // verify the required parameter 'googleCloudWriteImpersonatedAccountRequest' is set
            if (googleCloudWriteImpersonatedAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteImpersonatedAccountRequest' when calling Secrets->GoogleCloudWriteImpersonatedAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudWriteImpersonatedAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteImpersonatedAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this impersonated account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudWriteImpersonatedAccountAsync(string name, GoogleCloudWriteImpersonatedAccountRequest googleCloudWriteImpersonatedAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteImpersonatedAccount");


            // verify the required parameter 'googleCloudWriteImpersonatedAccountRequest' is set
            if (googleCloudWriteImpersonatedAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteImpersonatedAccountRequest' when calling Secrets->GoogleCloudWriteImpersonatedAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudWriteImpersonatedAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/impersonated-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteImpersonatedAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRolesetRequest"></param>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudWriteRoleset(string name, GoogleCloudWriteRolesetRequest googleCloudWriteRolesetRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteRoleset");


            // verify the required parameter 'googleCloudWriteRolesetRequest' is set
            if (googleCloudWriteRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteRolesetRequest' when calling Secrets->GoogleCloudWriteRoleset");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudWriteRolesetRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteRolesetRequest"></param>
        /// <param name="name">Required. Name of the role.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudWriteRolesetAsync(string name, GoogleCloudWriteRolesetRequest googleCloudWriteRolesetRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteRoleset");


            // verify the required parameter 'googleCloudWriteRolesetRequest' is set
            if (googleCloudWriteRolesetRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteRolesetRequest' when calling Secrets->GoogleCloudWriteRoleset");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudWriteRolesetRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/roleset/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteRoleset", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteStaticAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GoogleCloudWriteStaticAccount(string name, GoogleCloudWriteStaticAccountRequest googleCloudWriteStaticAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteStaticAccount");


            // verify the required parameter 'googleCloudWriteStaticAccountRequest' is set
            if (googleCloudWriteStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteStaticAccountRequest' when calling Secrets->GoogleCloudWriteStaticAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter





            requestOptions.Data = googleCloudWriteStaticAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="googleCloudWriteStaticAccountRequest"></param>
        /// <param name="name">Required. Name to refer to this static account in Vault. Cannot be updated.</param>
        /// <param name="gcpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GoogleCloudWriteStaticAccountAsync(string name, GoogleCloudWriteStaticAccountRequest googleCloudWriteStaticAccountRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->GoogleCloudWriteStaticAccount");


            // verify the required parameter 'googleCloudWriteStaticAccountRequest' is set
            if (googleCloudWriteStaticAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'googleCloudWriteStaticAccountRequest' when calling Secrets->GoogleCloudWriteStaticAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter



            requestOptions.Data = googleCloudWriteStaticAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{gcp_mount_path}/static-account/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GoogleCloudWriteStaticAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesCheckConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/check", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesCheckConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesCheckConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/check", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesCheckConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesConfigure(KubernetesConfigureRequest kubernetesConfigureRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kubernetesConfigureRequest' is set
            if (kubernetesConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigureRequest' when calling Secrets->KubernetesConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigureRequest"></param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesConfigureAsync(KubernetesConfigureRequest kubernetesConfigureRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kubernetesConfigureRequest' is set
            if (kubernetesConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigureRequest' when calling Secrets->KubernetesConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesDeleteConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesDeleteConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesDeleteRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesDeleteRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesGenerateCredentialsRequest"></param>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesGenerateCredentials(string name, KubernetesGenerateCredentialsRequest kubernetesGenerateCredentialsRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesGenerateCredentials");


            // verify the required parameter 'kubernetesGenerateCredentialsRequest' is set
            if (kubernetesGenerateCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesGenerateCredentialsRequest' when calling Secrets->KubernetesGenerateCredentials");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesGenerateCredentialsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesGenerateCredentialsRequest"></param>
        /// <param name="name">Name of the Vault role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesGenerateCredentialsAsync(string name, KubernetesGenerateCredentialsRequest kubernetesGenerateCredentialsRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesGenerateCredentials");


            // verify the required parameter 'kubernetesGenerateCredentialsRequest' is set
            if (kubernetesGenerateCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesGenerateCredentialsRequest' when calling Secrets->KubernetesGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesGenerateCredentialsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesListRoles(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesListRolesAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesReadConfiguration(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesReadConfigurationAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesReadRole(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesReadRoleAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KubernetesWriteRole(string name, KubernetesWriteRoleRequest kubernetesWriteRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesWriteRole");


            // verify the required parameter 'kubernetesWriteRoleRequest' is set
            if (kubernetesWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesWriteRoleRequest' when calling Secrets->KubernetesWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter





            requestOptions.Data = kubernetesWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="kubernetesMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KubernetesWriteRoleAsync(string name, KubernetesWriteRoleRequest kubernetesWriteRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->KubernetesWriteRole");


            // verify the required parameter 'kubernetesWriteRoleRequest' is set
            if (kubernetesWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesWriteRoleRequest' when calling Secrets->KubernetesWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter



            requestOptions.Data = kubernetesWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kubernetes_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KubernetesWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV1Delete(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Delete");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kv_v1_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Delete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV1DeleteAsync(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Delete");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kv_v1_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Delete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV1Read(string path, string kvV1MountPath = "kv-v1", string list = default(string), TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Read");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter




            if (list != null)
            {


                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            }



            // make the HTTP request
            var response = this.Client.Get<Object>("/{kv_v1_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Read", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV1ReadAsync(string path, string kvV1MountPath = "kv-v1", string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Read");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter




            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }
            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{kv_v1_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Read", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV1Write(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Write");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v1_mount_path}/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Write", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV1MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV1WriteAsync(string path, string kvV1MountPath = "kv-v1", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV1Write");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v1_mount_path", ClientUtils.ParameterToString(kvV1MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v1_mount_path}/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV1Write", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2ConfigureRequest"></param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2Configure(KvV2ConfigureRequest kvV2ConfigureRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'kvV2ConfigureRequest' is set
            if (kvV2ConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2ConfigureRequest' when calling Secrets->KvV2Configure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2ConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v2_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Configure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configure backend level settings that are applied to every key in the key-value store. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2ConfigureRequest"></param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2ConfigureAsync(KvV2ConfigureRequest kvV2ConfigureRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'kvV2ConfigureRequest' is set
            if (kvV2ConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2ConfigureRequest' when calling Secrets->KvV2Configure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2ConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v2_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Configure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2Delete(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Delete");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kv_v2_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Delete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2DeleteAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Delete");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kv_v2_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Delete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2DeleteMetadata(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DeleteMetadata");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{kv_v2_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DeleteMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2DeleteMetadataAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DeleteMetadata");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{kv_v2_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DeleteMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2DeleteVersions(string path, KvV2DeleteVersionsRequest kvV2DeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DeleteVersions");


            // verify the required parameter 'kvV2DeleteVersionsRequest' is set
            if (kvV2DeleteVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2DeleteVersionsRequest' when calling Secrets->KvV2DeleteVersions");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2DeleteVersionsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v2_mount_path}/delete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DeleteVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2DeleteVersionsAsync(string path, KvV2DeleteVersionsRequest kvV2DeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DeleteVersions");


            // verify the required parameter 'kvV2DeleteVersionsRequest' is set
            if (kvV2DeleteVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2DeleteVersionsRequest' when calling Secrets->KvV2DeleteVersions");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2DeleteVersionsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v2_mount_path}/delete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DeleteVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DestroyVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2DestroyVersions(string path, KvV2DestroyVersionsRequest kvV2DestroyVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DestroyVersions");


            // verify the required parameter 'kvV2DestroyVersionsRequest' is set
            if (kvV2DestroyVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2DestroyVersionsRequest' when calling Secrets->KvV2DestroyVersions");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2DestroyVersionsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v2_mount_path}/destroy/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DestroyVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2DestroyVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2DestroyVersionsAsync(string path, KvV2DestroyVersionsRequest kvV2DestroyVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2DestroyVersions");


            // verify the required parameter 'kvV2DestroyVersionsRequest' is set
            if (kvV2DestroyVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2DestroyVersionsRequest' when calling Secrets->KvV2DestroyVersions");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2DestroyVersionsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v2_mount_path}/destroy/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2DestroyVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<KvV2ReadResponse> KvV2Read(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Read");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<KvV2ReadResponse>("/{kv_v2_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Read", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadResponse)</returns>
        public async Task<VaultResponse<KvV2ReadResponse>> KvV2ReadAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Read");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<KvV2ReadResponse>("/{kv_v2_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Read", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadResponse>(response.RawContent);
        }
        /// <summary>
        /// Read the backend level settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<KvV2ReadConfigurationResponse> KvV2ReadConfiguration(string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<KvV2ReadConfigurationResponse>("/{kv_v2_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        /// Read the backend level settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadConfigurationResponse)</returns>
        public async Task<VaultResponse<KvV2ReadConfigurationResponse>> KvV2ReadConfigurationAsync(string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<KvV2ReadConfigurationResponse>("/{kv_v2_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>VaultResponse of KvV2ReadMetadataResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<KvV2ReadMetadataResponse> KvV2ReadMetadata(string path, string kvV2MountPath = "kv-v2", string list = default(string), TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2ReadMetadata");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter




            if (list != null)
            {


                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            }



            // make the HTTP request
            var response = this.Client.Get<KvV2ReadMetadataResponse>("/{kv_v2_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadMetadataResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>

        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadMetadataResponse)</returns>
        public async Task<VaultResponse<KvV2ReadMetadataResponse>> KvV2ReadMetadataAsync(string path, string kvV2MountPath = "kv-v2", string list = default(string), TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2ReadMetadata");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter




            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }
            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<KvV2ReadMetadataResponse>("/{kv_v2_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadMetadataResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2ReadSubkeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<KvV2ReadSubkeysResponse> KvV2ReadSubkeys(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2ReadSubkeys");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<KvV2ReadSubkeysResponse>("/{kv_v2_mount_path}/subkeys/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadSubkeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadSubkeysResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2ReadSubkeysResponse)</returns>
        public async Task<VaultResponse<KvV2ReadSubkeysResponse>> KvV2ReadSubkeysAsync(string path, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2ReadSubkeys");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<KvV2ReadSubkeysResponse>("/{kv_v2_mount_path}/subkeys/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2ReadSubkeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2ReadSubkeysResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2UndeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2UndeleteVersions(string path, KvV2UndeleteVersionsRequest kvV2UndeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2UndeleteVersions");


            // verify the required parameter 'kvV2UndeleteVersionsRequest' is set
            if (kvV2UndeleteVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2UndeleteVersionsRequest' when calling Secrets->KvV2UndeleteVersions");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2UndeleteVersionsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v2_mount_path}/undelete/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2UndeleteVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2UndeleteVersionsRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2UndeleteVersionsAsync(string path, KvV2UndeleteVersionsRequest kvV2UndeleteVersionsRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2UndeleteVersions");


            // verify the required parameter 'kvV2UndeleteVersionsRequest' is set
            if (kvV2UndeleteVersionsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2UndeleteVersionsRequest' when calling Secrets->KvV2UndeleteVersions");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2UndeleteVersionsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v2_mount_path}/undelete/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2UndeleteVersions", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of KvV2WriteResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<KvV2WriteResponse> KvV2Write(string path, KvV2WriteRequest kvV2WriteRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Write");


            // verify the required parameter 'kvV2WriteRequest' is set
            if (kvV2WriteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2WriteRequest' when calling Secrets->KvV2Write");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2WriteRequest;


            // make the HTTP request
            var response = this.Client.Post<KvV2WriteResponse>("/{kv_v2_mount_path}/data/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Write", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2WriteResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (KvV2WriteResponse)</returns>
        public async Task<VaultResponse<KvV2WriteResponse>> KvV2WriteAsync(string path, KvV2WriteRequest kvV2WriteRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2Write");


            // verify the required parameter 'kvV2WriteRequest' is set
            if (kvV2WriteRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2WriteRequest' when calling Secrets->KvV2Write");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2WriteRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<KvV2WriteResponse>("/{kv_v2_mount_path}/data/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2Write", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<KvV2WriteResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteMetadataRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> KvV2WriteMetadata(string path, KvV2WriteMetadataRequest kvV2WriteMetadataRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2WriteMetadata");


            // verify the required parameter 'kvV2WriteMetadataRequest' is set
            if (kvV2WriteMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2WriteMetadataRequest' when calling Secrets->KvV2WriteMetadata");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter





            requestOptions.Data = kvV2WriteMetadataRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{kv_v2_mount_path}/metadata/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2WriteMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kvV2WriteMetadataRequest"></param>
        /// <param name="path">Location of the secret.</param>
        /// <param name="kvV2MountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> KvV2WriteMetadataAsync(string path, KvV2WriteMetadataRequest kvV2WriteMetadataRequest, string kvV2MountPath = "kv-v2", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling Secrets->KvV2WriteMetadata");


            // verify the required parameter 'kvV2WriteMetadataRequest' is set
            if (kvV2WriteMetadataRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kvV2WriteMetadataRequest' when calling Secrets->KvV2WriteMetadata");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter


            requestOptions.PathParameters.Add("kv_v2_mount_path", ClientUtils.ParameterToString(kvV2MountPath)); // path parameter



            requestOptions.Data = kvV2WriteMetadataRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{kv_v2_mount_path}/metadata/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("KvV2WriteMetadata", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapConfigure(LdapConfigureRequest ldapConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'ldapConfigureRequest' is set
            if (ldapConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigureRequest' when calling Secrets->LdapConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigureRequest"></param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapConfigureAsync(LdapConfigureRequest ldapConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'ldapConfigureRequest' is set
            if (ldapConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigureRequest' when calling Secrets->LdapConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapDeleteConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapDeleteConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapDeleteDynamicRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapDeleteDynamicRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapDeleteDynamicRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapDeleteDynamicRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapDeleteStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapDeleteStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapDeleteStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapDeleteStaticRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapDeleteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryCheckIn(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckIn");


            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->LdapLibraryCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapLibraryCheckInRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryCheckInAsync(string name, LdapLibraryCheckInRequest ldapLibraryCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckIn");


            // verify the required parameter 'ldapLibraryCheckInRequest' is set
            if (ldapLibraryCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckInRequest' when calling Secrets->LdapLibraryCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapLibraryCheckInRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryCheckOut(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckOut");


            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->LdapLibraryCheckOut");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapLibraryCheckOutRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}/check-out", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Check a service account out from the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryCheckOutRequest"></param>
        /// <param name="name">Name of the set</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryCheckOutAsync(string name, LdapLibraryCheckOutRequest ldapLibraryCheckOutRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckOut");


            // verify the required parameter 'ldapLibraryCheckOutRequest' is set
            if (ldapLibraryCheckOutRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryCheckOutRequest' when calling Secrets->LdapLibraryCheckOut");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapLibraryCheckOutRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}/check-out", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckOut", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryCheckStatus(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckStatus");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library/{name}/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Check the status of the service accounts in a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryCheckStatusAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryCheckStatus");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library/{name}/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryCheckStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryConfigureRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryConfigure(string name, LdapLibraryConfigureRequest ldapLibraryConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryConfigure");


            // verify the required parameter 'ldapLibraryConfigureRequest' is set
            if (ldapLibraryConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryConfigureRequest' when calling Secrets->LdapLibraryConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapLibraryConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Update a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryConfigureRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryConfigureAsync(string name, LdapLibraryConfigureRequest ldapLibraryConfigureRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryConfigure");


            // verify the required parameter 'ldapLibraryConfigureRequest' is set
            if (ldapLibraryConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryConfigureRequest' when calling Secrets->LdapLibraryConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapLibraryConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryDelete(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryDelete");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryDelete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Delete a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryDeleteAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryDelete");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryDelete", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryForceCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryForceCheckIn(string name, LdapLibraryForceCheckInRequest ldapLibraryForceCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryForceCheckIn");


            // verify the required parameter 'ldapLibraryForceCheckInRequest' is set
            if (ldapLibraryForceCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryForceCheckInRequest' when calling Secrets->LdapLibraryForceCheckIn");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapLibraryForceCheckInRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/library/manage/{name}/check-in", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryForceCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Check service accounts in to the library. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapLibraryForceCheckInRequest"></param>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryForceCheckInAsync(string name, LdapLibraryForceCheckInRequest ldapLibraryForceCheckInRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryForceCheckIn");


            // verify the required parameter 'ldapLibraryForceCheckInRequest' is set
            if (ldapLibraryForceCheckInRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLibraryForceCheckInRequest' when calling Secrets->LdapLibraryForceCheckIn");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapLibraryForceCheckInRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/library/manage/{name}/check-in", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryForceCheckIn", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryList(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryListAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapLibraryRead(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryRead");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/library/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryRead", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Read a library set. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the set.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapLibraryReadAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapLibraryRead");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/library/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapLibraryRead", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapListDynamicRoles(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListDynamicRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapListDynamicRolesAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListDynamicRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapListStaticRoles(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListStaticRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapListStaticRolesAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapListStaticRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadConfiguration(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadConfigurationAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadDynamicRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapReadDynamicRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadDynamicRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapReadDynamicRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapReadStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapReadStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapReadStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapReadStaticRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapReadStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapRequestDynamicRoleCredentials(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRequestDynamicRoleCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRequestDynamicRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the dynamic role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapRequestDynamicRoleCredentialsAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRequestDynamicRoleCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRequestDynamicRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapRequestStaticRoleCredentials(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRequestStaticRoleCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ldap_mount_path}/static-cred/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRequestStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role.</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapRequestStaticRoleCredentialsAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRequestStaticRoleCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ldap_mount_path}/static-cred/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRequestStaticRoleCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapRotateRootCredentials(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapRotateRootCredentialsAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRotateRootCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapRotateStaticRole(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRotateStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRotateStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the static role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapRotateStaticRoleAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapRotateStaticRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapRotateStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteDynamicRoleRequest"></param>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapWriteDynamicRole(string name, LdapWriteDynamicRoleRequest ldapWriteDynamicRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapWriteDynamicRole");


            // verify the required parameter 'ldapWriteDynamicRoleRequest' is set
            if (ldapWriteDynamicRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteDynamicRoleRequest' when calling Secrets->LdapWriteDynamicRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapWriteDynamicRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteDynamicRoleRequest"></param>
        /// <param name="name">Name of the role (lowercase)</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapWriteDynamicRoleAsync(string name, LdapWriteDynamicRoleRequest ldapWriteDynamicRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapWriteDynamicRole");


            // verify the required parameter 'ldapWriteDynamicRoleRequest' is set
            if (ldapWriteDynamicRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteDynamicRoleRequest' when calling Secrets->LdapWriteDynamicRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapWriteDynamicRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteDynamicRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> LdapWriteStaticRole(string name, LdapWriteStaticRoleRequest ldapWriteStaticRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapWriteStaticRole");


            // verify the required parameter 'ldapWriteStaticRoleRequest' is set
            if (ldapWriteStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteStaticRoleRequest' when calling Secrets->LdapWriteStaticRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter





            requestOptions.Data = ldapWriteStaticRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapWriteStaticRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="ldapMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> LdapWriteStaticRoleAsync(string name, LdapWriteStaticRoleRequest ldapWriteStaticRoleRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->LdapWriteStaticRole");


            // verify the required parameter 'ldapWriteStaticRoleRequest' is set
            if (ldapWriteStaticRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapWriteStaticRoleRequest' when calling Secrets->LdapWriteStaticRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter



            requestOptions.Data = ldapWriteStaticRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ldap_mount_path}/static-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("LdapWriteStaticRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasConfigureRequest"></param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasConfigure(MongoDbAtlasConfigureRequest mongoDbAtlasConfigureRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'mongoDbAtlasConfigureRequest' is set
            if (mongoDbAtlasConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongoDbAtlasConfigureRequest' when calling Secrets->MongoDbAtlasConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter





            requestOptions.Data = mongoDbAtlasConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{mongodbatlas_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasConfigureRequest"></param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasConfigureAsync(MongoDbAtlasConfigureRequest mongoDbAtlasConfigureRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'mongoDbAtlasConfigureRequest' is set
            if (mongoDbAtlasConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongoDbAtlasConfigureRequest' when calling Secrets->MongoDbAtlasConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            requestOptions.Data = mongoDbAtlasConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mongodbatlas_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasDeleteRole(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasDeleteRoleAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasGenerateCredentials(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasGenerateCredentialsAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasListRoles(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List the existing roles in this backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasListRolesAsync(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasReadConfiguration(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasReadConfigurationAsync(string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasReadRole(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasReadRoleAsync(string name, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasWriteRoleRequest"></param>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> MongoDbAtlasWriteRole(string name, MongoDbAtlasWriteRoleRequest mongoDbAtlasWriteRoleRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasWriteRole");


            // verify the required parameter 'mongoDbAtlasWriteRoleRequest' is set
            if (mongoDbAtlasWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongoDbAtlasWriteRoleRequest' when calling Secrets->MongoDbAtlasWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter





            requestOptions.Data = mongoDbAtlasWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles used to generate MongoDB Atlas Programmatic API Keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mongoDbAtlasWriteRoleRequest"></param>
        /// <param name="name">Name of the Roles</param>
        /// <param name="mongodbatlasMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> MongoDbAtlasWriteRoleAsync(string name, MongoDbAtlasWriteRoleRequest mongoDbAtlasWriteRoleRequest, string mongodbatlasMountPath = "mongodbatlas", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->MongoDbAtlasWriteRole");


            // verify the required parameter 'mongoDbAtlasWriteRoleRequest' is set
            if (mongoDbAtlasWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'mongoDbAtlasWriteRoleRequest' when calling Secrets->MongoDbAtlasWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("mongodbatlas_mount_path", ClientUtils.ParameterToString(mongodbatlasMountPath)); // path parameter



            requestOptions.Data = mongoDbAtlasWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{mongodbatlas_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("MongoDbAtlasWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureAccessRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadConfigureAccess(NomadConfigureAccessRequest nomadConfigureAccessRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'nomadConfigureAccessRequest' is set
            if (nomadConfigureAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigureAccessRequest' when calling Secrets->NomadConfigureAccess");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter





            requestOptions.Data = nomadConfigureAccessRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadConfigureAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureAccessRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadConfigureAccessAsync(NomadConfigureAccessRequest nomadConfigureAccessRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'nomadConfigureAccessRequest' is set
            if (nomadConfigureAccessRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigureAccessRequest' when calling Secrets->NomadConfigureAccess");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            requestOptions.Data = nomadConfigureAccessRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadConfigureAccess", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureLeaseRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadConfigureLease(NomadConfigureLeaseRequest nomadConfigureLeaseRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'nomadConfigureLeaseRequest' is set
            if (nomadConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigureLeaseRequest' when calling Secrets->NomadConfigureLease");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter





            requestOptions.Data = nomadConfigureLeaseRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadConfigureLeaseRequest"></param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadConfigureLeaseAsync(NomadConfigureLeaseRequest nomadConfigureLeaseRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'nomadConfigureLeaseRequest' is set
            if (nomadConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadConfigureLeaseRequest' when calling Secrets->NomadConfigureLease");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            requestOptions.Data = nomadConfigureLeaseRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadDeleteAccessConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadDeleteAccessConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadDeleteLeaseConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadDeleteLeaseConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadDeleteRole(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadDeleteRoleAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadGenerateCredentials(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadGenerateCredentialsAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadListRoles(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadListRolesAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadReadAccessConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/config/access", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadReadAccessConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/config/access", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadAccessConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadReadLeaseConfiguration(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadReadLeaseConfigurationAsync(string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadReadRole(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadReadRoleAsync(string name, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> NomadWriteRole(string name, NomadWriteRoleRequest nomadWriteRoleRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadWriteRole");


            // verify the required parameter 'nomadWriteRoleRequest' is set
            if (nomadWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadWriteRoleRequest' when calling Secrets->NomadWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter





            requestOptions.Data = nomadWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{nomad_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nomadWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="nomadMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> NomadWriteRoleAsync(string name, NomadWriteRoleRequest nomadWriteRoleRequest, string nomadMountPath = "nomad", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->NomadWriteRole");


            // verify the required parameter 'nomadWriteRoleRequest' is set
            if (nomadWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'nomadWriteRoleRequest' when calling Secrets->NomadWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("nomad_mount_path", ClientUtils.ParameterToString(nomadMountPath)); // path parameter



            requestOptions.Data = nomadWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{nomad_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("NomadWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAcmeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiConfigureAcme(PkiConfigureAcmeRequest pkiConfigureAcmeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureAcmeRequest' is set
            if (pkiConfigureAcmeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureAcmeRequest' when calling Secrets->PkiConfigureAcme");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureAcmeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/config/acme", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureAcme", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAcmeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiConfigureAcmeAsync(PkiConfigureAcmeRequest pkiConfigureAcmeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureAcmeRequest' is set
            if (pkiConfigureAcmeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureAcmeRequest' when calling Secrets->PkiConfigureAcme");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureAcmeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/config/acme", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureAcme", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureAutoTidyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureAutoTidyResponse> PkiConfigureAutoTidy(PkiConfigureAutoTidyRequest pkiConfigureAutoTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureAutoTidyRequest' is set
            if (pkiConfigureAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureAutoTidyRequest' when calling Secrets->PkiConfigureAutoTidy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureAutoTidyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureAutoTidyResponse>("/{pki_mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureAutoTidyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureAutoTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureAutoTidyResponse)</returns>
        public async Task<VaultResponse<PkiConfigureAutoTidyResponse>> PkiConfigureAutoTidyAsync(PkiConfigureAutoTidyRequest pkiConfigureAutoTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureAutoTidyRequest' is set
            if (pkiConfigureAutoTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureAutoTidyRequest' when calling Secrets->PkiConfigureAutoTidy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureAutoTidyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureAutoTidyResponse>("/{pki_mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureAutoTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureAutoTidyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCaRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureCaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureCaResponse> PkiConfigureCa(PkiConfigureCaRequest pkiConfigureCaRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureCaRequest' is set
            if (pkiConfigureCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureCaRequest' when calling Secrets->PkiConfigureCa");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureCaRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureCaResponse>("/{pki_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureCaResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCaRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureCaResponse)</returns>
        public async Task<VaultResponse<PkiConfigureCaResponse>> PkiConfigureCaAsync(PkiConfigureCaRequest pkiConfigureCaRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureCaRequest' is set
            if (pkiConfigureCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureCaRequest' when calling Secrets->PkiConfigureCa");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureCaRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureCaResponse>("/{pki_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureCaResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureClusterRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureClusterResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureClusterResponse> PkiConfigureCluster(PkiConfigureClusterRequest pkiConfigureClusterRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureClusterRequest' is set
            if (pkiConfigureClusterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureClusterRequest' when calling Secrets->PkiConfigureCluster");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureClusterRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureClusterResponse>("/{pki_mount_path}/config/cluster", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCluster", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureClusterResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureClusterRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureClusterResponse)</returns>
        public async Task<VaultResponse<PkiConfigureClusterResponse>> PkiConfigureClusterAsync(PkiConfigureClusterRequest pkiConfigureClusterRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureClusterRequest' is set
            if (pkiConfigureClusterRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureClusterRequest' when calling Secrets->PkiConfigureCluster");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureClusterRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureClusterResponse>("/{pki_mount_path}/config/cluster", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCluster", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureClusterResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCrlRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureCrlResponse> PkiConfigureCrl(PkiConfigureCrlRequest pkiConfigureCrlRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureCrlRequest' is set
            if (pkiConfigureCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureCrlRequest' when calling Secrets->PkiConfigureCrl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureCrlRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureCrlResponse>("/{pki_mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureCrlRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureCrlResponse)</returns>
        public async Task<VaultResponse<PkiConfigureCrlResponse>> PkiConfigureCrlAsync(PkiConfigureCrlRequest pkiConfigureCrlRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureCrlRequest' is set
            if (pkiConfigureCrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureCrlRequest' when calling Secrets->PkiConfigureCrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureCrlRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureCrlResponse>("/{pki_mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureIssuersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureIssuersResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureIssuersResponse> PkiConfigureIssuers(PkiConfigureIssuersRequest pkiConfigureIssuersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureIssuersRequest' is set
            if (pkiConfigureIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureIssuersRequest' when calling Secrets->PkiConfigureIssuers");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureIssuersRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureIssuersResponse>("/{pki_mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureIssuersResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureIssuersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureIssuersResponse)</returns>
        public async Task<VaultResponse<PkiConfigureIssuersResponse>> PkiConfigureIssuersAsync(PkiConfigureIssuersRequest pkiConfigureIssuersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureIssuersRequest' is set
            if (pkiConfigureIssuersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureIssuersRequest' when calling Secrets->PkiConfigureIssuers");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureIssuersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureIssuersResponse>("/{pki_mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureIssuersResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureKeysRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureKeysResponse> PkiConfigureKeys(PkiConfigureKeysRequest pkiConfigureKeysRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureKeysRequest' is set
            if (pkiConfigureKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureKeysRequest' when calling Secrets->PkiConfigureKeys");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureKeysRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureKeysResponse>("/{pki_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureKeysResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureKeysRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureKeysResponse)</returns>
        public async Task<VaultResponse<PkiConfigureKeysResponse>> PkiConfigureKeysAsync(PkiConfigureKeysRequest pkiConfigureKeysRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureKeysRequest' is set
            if (pkiConfigureKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureKeysRequest' when calling Secrets->PkiConfigureKeys");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureKeysRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureKeysResponse>("/{pki_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureKeysResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureUrlsRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiConfigureUrlsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiConfigureUrlsResponse> PkiConfigureUrls(PkiConfigureUrlsRequest pkiConfigureUrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiConfigureUrlsRequest' is set
            if (pkiConfigureUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureUrlsRequest' when calling Secrets->PkiConfigureUrls");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiConfigureUrlsRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiConfigureUrlsResponse>("/{pki_mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureUrlsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiConfigureUrlsRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiConfigureUrlsResponse)</returns>
        public async Task<VaultResponse<PkiConfigureUrlsResponse>> PkiConfigureUrlsAsync(PkiConfigureUrlsRequest pkiConfigureUrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiConfigureUrlsRequest' is set
            if (pkiConfigureUrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiConfigureUrlsRequest' when calling Secrets->PkiConfigureUrls");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiConfigureUrlsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiConfigureUrlsResponse>("/{pki_mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiConfigureUrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiConfigureUrlsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCrossSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiCrossSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiCrossSignIntermediateResponse> PkiCrossSignIntermediate(PkiCrossSignIntermediateRequest pkiCrossSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiCrossSignIntermediateRequest' is set
            if (pkiCrossSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCrossSignIntermediateRequest' when calling Secrets->PkiCrossSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiCrossSignIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiCrossSignIntermediateResponse>("/{pki_mount_path}/intermediate/cross-sign", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiCrossSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiCrossSignIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiCrossSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiCrossSignIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiCrossSignIntermediateResponse>> PkiCrossSignIntermediateAsync(PkiCrossSignIntermediateRequest pkiCrossSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiCrossSignIntermediateRequest' is set
            if (pkiCrossSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiCrossSignIntermediateRequest' when calling Secrets->PkiCrossSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiCrossSignIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiCrossSignIntermediateResponse>("/{pki_mount_path}/intermediate/cross-sign", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiCrossSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiCrossSignIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyId">EAB key identifier</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiDeleteEabKey(string keyId, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'keyId' is set
            if (keyId == null)
                throw new VaultApiException(400, "Missing required parameter 'keyId' when calling Secrets->PkiDeleteEabKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_id", ClientUtils.ParameterToString(keyId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/eab/{key_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteEabKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyId">EAB key identifier</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiDeleteEabKeyAsync(string keyId, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'keyId' is set
            if (keyId == null)
                throw new VaultApiException(400, "Missing required parameter 'keyId' when calling Secrets->PkiDeleteEabKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_id", ClientUtils.ParameterToString(keyId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/eab/{key_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteEabKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiDeleteIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiDeleteIssuer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiDeleteIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiDeleteIssuer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiDeleteKey(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiDeleteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiDeleteKeyAsync(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiDeleteKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiDeleteRole(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiDeleteRoleAsync(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiDeleteRoot(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{pki_mount_path}/root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiDeleteRootAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{pki_mount_path}/root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiDeleteRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateEabKeyResponse> PkiGenerateEabKey(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiGenerateEabKeyResponse>("/{pki_mount_path}/acme/new-eab", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyResponse)</returns>
        public async Task<VaultResponse<PkiGenerateEabKeyResponse>> PkiGenerateEabKeyAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateEabKeyResponse>("/{pki_mount_path}/acme/new-eab", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateEabKeyForIssuerResponse> PkiGenerateEabKeyForIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiGenerateEabKeyForIssuer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiGenerateEabKeyForIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-eab", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForIssuerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForIssuerResponse)</returns>
        public async Task<VaultResponse<PkiGenerateEabKeyForIssuerResponse>> PkiGenerateEabKeyForIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiGenerateEabKeyForIssuer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateEabKeyForIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-eab", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForIssuerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForIssuerAndRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse> PkiGenerateEabKeyForIssuerAndRole(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiGenerateEabKeyForIssuerAndRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiGenerateEabKeyForIssuerAndRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiGenerateEabKeyForIssuerAndRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-eab", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForIssuerAndRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForIssuerAndRoleResponse)</returns>
        public async Task<VaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse>> PkiGenerateEabKeyForIssuerAndRoleAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiGenerateEabKeyForIssuerAndRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiGenerateEabKeyForIssuerAndRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateEabKeyForIssuerAndRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-eab", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForIssuerAndRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForIssuerAndRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateEabKeyForRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateEabKeyForRoleResponse> PkiGenerateEabKeyForRole(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiGenerateEabKeyForRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiGenerateEabKeyForRoleResponse>("/{pki_mount_path}/roles/{role}/acme/new-eab", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateEabKeyForRoleResponse)</returns>
        public async Task<VaultResponse<PkiGenerateEabKeyForRoleResponse>> PkiGenerateEabKeyForRoleAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiGenerateEabKeyForRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateEabKeyForRoleResponse>("/{pki_mount_path}/roles/{role}/acme/new-eab", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateEabKeyForRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateEabKeyForRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateExportedKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateExportedKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateExportedKeyResponse> PkiGenerateExportedKey(PkiGenerateExportedKeyRequest pkiGenerateExportedKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiGenerateExportedKeyRequest' is set
            if (pkiGenerateExportedKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateExportedKeyRequest' when calling Secrets->PkiGenerateExportedKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiGenerateExportedKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiGenerateExportedKeyResponse>("/{pki_mount_path}/keys/generate/exported", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateExportedKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateExportedKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateExportedKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateExportedKeyResponse)</returns>
        public async Task<VaultResponse<PkiGenerateExportedKeyResponse>> PkiGenerateExportedKeyAsync(PkiGenerateExportedKeyRequest pkiGenerateExportedKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiGenerateExportedKeyRequest' is set
            if (pkiGenerateExportedKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateExportedKeyRequest' when calling Secrets->PkiGenerateExportedKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiGenerateExportedKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateExportedKeyResponse>("/{pki_mount_path}/keys/generate/exported", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateExportedKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateExportedKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateIntermediateResponse> PkiGenerateIntermediate(string exported, PkiGenerateIntermediateRequest pkiGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiGenerateIntermediate");


            // verify the required parameter 'pkiGenerateIntermediateRequest' is set
            if (pkiGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateIntermediateRequest' when calling Secrets->PkiGenerateIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiGenerateIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiGenerateIntermediateResponse>("/{pki_mount_path}/intermediate/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiGenerateIntermediateResponse>> PkiGenerateIntermediateAsync(string exported, PkiGenerateIntermediateRequest pkiGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiGenerateIntermediate");


            // verify the required parameter 'pkiGenerateIntermediateRequest' is set
            if (pkiGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateIntermediateRequest' when calling Secrets->PkiGenerateIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiGenerateIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateIntermediateResponse>("/{pki_mount_path}/intermediate/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateInternalKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateInternalKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateInternalKeyResponse> PkiGenerateInternalKey(PkiGenerateInternalKeyRequest pkiGenerateInternalKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiGenerateInternalKeyRequest' is set
            if (pkiGenerateInternalKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateInternalKeyRequest' when calling Secrets->PkiGenerateInternalKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiGenerateInternalKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiGenerateInternalKeyResponse>("/{pki_mount_path}/keys/generate/internal", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateInternalKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateInternalKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateInternalKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateInternalKeyResponse)</returns>
        public async Task<VaultResponse<PkiGenerateInternalKeyResponse>> PkiGenerateInternalKeyAsync(PkiGenerateInternalKeyRequest pkiGenerateInternalKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiGenerateInternalKeyRequest' is set
            if (pkiGenerateInternalKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateInternalKeyRequest' when calling Secrets->PkiGenerateInternalKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiGenerateInternalKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateInternalKeyResponse>("/{pki_mount_path}/keys/generate/internal", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateInternalKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateInternalKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateKmsKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateKmsKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateKmsKeyResponse> PkiGenerateKmsKey(PkiGenerateKmsKeyRequest pkiGenerateKmsKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiGenerateKmsKeyRequest' is set
            if (pkiGenerateKmsKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateKmsKeyRequest' when calling Secrets->PkiGenerateKmsKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiGenerateKmsKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiGenerateKmsKeyResponse>("/{pki_mount_path}/keys/generate/kms", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateKmsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateKmsKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateKmsKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateKmsKeyResponse)</returns>
        public async Task<VaultResponse<PkiGenerateKmsKeyResponse>> PkiGenerateKmsKeyAsync(PkiGenerateKmsKeyRequest pkiGenerateKmsKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiGenerateKmsKeyRequest' is set
            if (pkiGenerateKmsKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateKmsKeyRequest' when calling Secrets->PkiGenerateKmsKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiGenerateKmsKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateKmsKeyResponse>("/{pki_mount_path}/keys/generate/kms", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateKmsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateKmsKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiGenerateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiGenerateRootResponse> PkiGenerateRoot(string exported, PkiGenerateRootRequest pkiGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiGenerateRoot");


            // verify the required parameter 'pkiGenerateRootRequest' is set
            if (pkiGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateRootRequest' when calling Secrets->PkiGenerateRoot");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiGenerateRootRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiGenerateRootResponse>("/{pki_mount_path}/root/generate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateRootResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiGenerateRootResponse)</returns>
        public async Task<VaultResponse<PkiGenerateRootResponse>> PkiGenerateRootAsync(string exported, PkiGenerateRootRequest pkiGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiGenerateRoot");


            // verify the required parameter 'pkiGenerateRootRequest' is set
            if (pkiGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiGenerateRootRequest' when calling Secrets->PkiGenerateRoot");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiGenerateRootRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiGenerateRootResponse>("/{pki_mount_path}/root/generate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiGenerateRootResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiImportKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiImportKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiImportKeyResponse> PkiImportKey(PkiImportKeyRequest pkiImportKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiImportKeyRequest' is set
            if (pkiImportKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiImportKeyRequest' when calling Secrets->PkiImportKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiImportKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiImportKeyResponse>("/{pki_mount_path}/keys/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiImportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiImportKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiImportKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiImportKeyResponse)</returns>
        public async Task<VaultResponse<PkiImportKeyResponse>> PkiImportKeyAsync(PkiImportKeyRequest pkiImportKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiImportKeyRequest' is set
            if (pkiImportKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiImportKeyRequest' when calling Secrets->PkiImportKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiImportKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiImportKeyResponse>("/{pki_mount_path}/keys/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiImportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiImportKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssueWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssueWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssueWithRoleResponse> PkiIssueWithRole(string role, PkiIssueWithRoleRequest pkiIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssueWithRole");


            // verify the required parameter 'pkiIssueWithRoleRequest' is set
            if (pkiIssueWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssueWithRoleRequest' when calling Secrets->PkiIssueWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssueWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssueWithRoleResponse>("/{pki_mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssueWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssueWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssueWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssueWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiIssueWithRoleResponse>> PkiIssueWithRoleAsync(string role, PkiIssueWithRoleRequest pkiIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssueWithRole");


            // verify the required parameter 'pkiIssueWithRoleRequest' is set
            if (pkiIssueWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssueWithRoleRequest' when calling Secrets->PkiIssueWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssueWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssueWithRoleResponse>("/{pki_mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssueWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssueWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerIssueWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerIssueWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerIssueWithRoleResponse> PkiIssuerIssueWithRole(string issuerRef, string role, PkiIssuerIssueWithRoleRequest pkiIssuerIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerIssueWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerIssueWithRole");


            // verify the required parameter 'pkiIssuerIssueWithRoleRequest' is set
            if (pkiIssuerIssueWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueWithRoleRequest' when calling Secrets->PkiIssuerIssueWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerIssueWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerIssueWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerIssueWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerIssueWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerIssueWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerIssueWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiIssuerIssueWithRoleResponse>> PkiIssuerIssueWithRoleAsync(string issuerRef, string role, PkiIssuerIssueWithRoleRequest pkiIssuerIssueWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerIssueWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerIssueWithRole");


            // verify the required parameter 'pkiIssuerIssueWithRoleRequest' is set
            if (pkiIssuerIssueWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerIssueWithRoleRequest' when calling Secrets->PkiIssuerIssueWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerIssueWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerIssueWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerIssueWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerIssueWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlResponse> PkiIssuerReadCrl(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlResponse>> PkiIssuerReadCrlAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrl");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlDeltaResponse> PkiIssuerReadCrlDelta(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDelta");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlDeltaResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlDeltaResponse>> PkiIssuerReadCrlDeltaAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDelta");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlDeltaResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlDeltaDerResponse> PkiIssuerReadCrlDeltaDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDeltaDer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlDeltaDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDeltaDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaDerResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlDeltaDerResponse>> PkiIssuerReadCrlDeltaDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDeltaDer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlDeltaDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDeltaDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDeltaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlDeltaPemResponse> PkiIssuerReadCrlDeltaPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDeltaPem");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlDeltaPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDeltaPemResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlDeltaPemResponse>> PkiIssuerReadCrlDeltaPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDeltaPem");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlDeltaPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDeltaPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlDerResponse> PkiIssuerReadCrlDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlDerResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlDerResponse>> PkiIssuerReadCrlDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlDer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerReadCrlPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerReadCrlPemResponse> PkiIssuerReadCrlPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlPem");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiIssuerReadCrlPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerReadCrlPemResponse)</returns>
        public async Task<VaultResponse<PkiIssuerReadCrlPemResponse>> PkiIssuerReadCrlPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerReadCrlPem");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiIssuerReadCrlPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/crl/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerReadCrlPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerReadCrlPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerResignCrlsRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerResignCrlsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerResignCrlsResponse> PkiIssuerResignCrls(string issuerRef, PkiIssuerResignCrlsRequest pkiIssuerResignCrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerResignCrls");


            // verify the required parameter 'pkiIssuerResignCrlsRequest' is set
            if (pkiIssuerResignCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerResignCrlsRequest' when calling Secrets->PkiIssuerResignCrls");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerResignCrlsRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerResignCrlsResponse>("/{pki_mount_path}/issuer/{issuer_ref}/resign-crls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerResignCrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerResignCrlsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerResignCrlsRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerResignCrlsResponse)</returns>
        public async Task<VaultResponse<PkiIssuerResignCrlsResponse>> PkiIssuerResignCrlsAsync(string issuerRef, PkiIssuerResignCrlsRequest pkiIssuerResignCrlsRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerResignCrls");


            // verify the required parameter 'pkiIssuerResignCrlsRequest' is set
            if (pkiIssuerResignCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerResignCrlsRequest' when calling Secrets->PkiIssuerResignCrls");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerResignCrlsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerResignCrlsResponse>("/{pki_mount_path}/issuer/{issuer_ref}/resign-crls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerResignCrls", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerResignCrlsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignIntermediateResponse> PkiIssuerSignIntermediate(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignIntermediate");


            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->PkiIssuerSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignIntermediateResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignIntermediateRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignIntermediateResponse>> PkiIssuerSignIntermediateAsync(string issuerRef, PkiIssuerSignIntermediateRequest pkiIssuerSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignIntermediate");


            // verify the required parameter 'pkiIssuerSignIntermediateRequest' is set
            if (pkiIssuerSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignIntermediateRequest' when calling Secrets->PkiIssuerSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignIntermediateResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignRevocationListRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignRevocationListResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignRevocationListResponse> PkiIssuerSignRevocationList(string issuerRef, PkiIssuerSignRevocationListRequest pkiIssuerSignRevocationListRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignRevocationList");


            // verify the required parameter 'pkiIssuerSignRevocationListRequest' is set
            if (pkiIssuerSignRevocationListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRevocationListRequest' when calling Secrets->PkiIssuerSignRevocationList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignRevocationListRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignRevocationListResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-revocation-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignRevocationList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignRevocationListResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignRevocationListRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignRevocationListResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignRevocationListResponse>> PkiIssuerSignRevocationListAsync(string issuerRef, PkiIssuerSignRevocationListRequest pkiIssuerSignRevocationListRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignRevocationList");


            // verify the required parameter 'pkiIssuerSignRevocationListRequest' is set
            if (pkiIssuerSignRevocationListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignRevocationListRequest' when calling Secrets->PkiIssuerSignRevocationList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignRevocationListRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignRevocationListResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-revocation-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignRevocationList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignRevocationListResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignSelfIssuedResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignSelfIssuedResponse> PkiIssuerSignSelfIssued(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignSelfIssued");


            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->PkiIssuerSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignSelfIssuedResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignSelfIssuedResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignSelfIssuedRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignSelfIssuedResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignSelfIssuedResponse>> PkiIssuerSignSelfIssuedAsync(string issuerRef, PkiIssuerSignSelfIssuedRequest pkiIssuerSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignSelfIssued");


            // verify the required parameter 'pkiIssuerSignSelfIssuedRequest' is set
            if (pkiIssuerSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignSelfIssuedRequest' when calling Secrets->PkiIssuerSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignSelfIssuedRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignSelfIssuedResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignSelfIssuedResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignVerbatimResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignVerbatimResponse> PkiIssuerSignVerbatim(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignVerbatim");


            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PkiIssuerSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignVerbatimRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignVerbatimResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignVerbatimResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignVerbatimResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignVerbatimResponse>> PkiIssuerSignVerbatimAsync(string issuerRef, PkiIssuerSignVerbatimRequest pkiIssuerSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignVerbatim");


            // verify the required parameter 'pkiIssuerSignVerbatimRequest' is set
            if (pkiIssuerSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimRequest' when calling Secrets->PkiIssuerSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignVerbatimRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignVerbatimResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignVerbatimResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignVerbatimWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignVerbatimWithRoleResponse> PkiIssuerSignVerbatimWithRole(string issuerRef, string role, PkiIssuerSignVerbatimWithRoleRequest pkiIssuerSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignVerbatimWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerSignVerbatimWithRole");


            // verify the required parameter 'pkiIssuerSignVerbatimWithRoleRequest' is set
            if (pkiIssuerSignVerbatimWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimWithRoleRequest' when calling Secrets->PkiIssuerSignVerbatimWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignVerbatimWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignVerbatimWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignVerbatimWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignVerbatimWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignVerbatimWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignVerbatimWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignVerbatimWithRoleResponse>> PkiIssuerSignVerbatimWithRoleAsync(string issuerRef, string role, PkiIssuerSignVerbatimWithRoleRequest pkiIssuerSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignVerbatimWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerSignVerbatimWithRole");


            // verify the required parameter 'pkiIssuerSignVerbatimWithRoleRequest' is set
            if (pkiIssuerSignVerbatimWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignVerbatimWithRoleRequest' when calling Secrets->PkiIssuerSignVerbatimWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignVerbatimWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignVerbatimWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignVerbatimWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignVerbatimWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuerSignWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuerSignWithRoleResponse> PkiIssuerSignWithRole(string issuerRef, string role, PkiIssuerSignWithRoleRequest pkiIssuerSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerSignWithRole");


            // verify the required parameter 'pkiIssuerSignWithRoleRequest' is set
            if (pkiIssuerSignWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignWithRoleRequest' when calling Secrets->PkiIssuerSignWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuerSignWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuerSignWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuerSignWithRoleRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuerSignWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiIssuerSignWithRoleResponse>> PkiIssuerSignWithRoleAsync(string issuerRef, string role, PkiIssuerSignWithRoleRequest pkiIssuerSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiIssuerSignWithRole");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiIssuerSignWithRole");


            // verify the required parameter 'pkiIssuerSignWithRoleRequest' is set
            if (pkiIssuerSignWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuerSignWithRoleRequest' when calling Secrets->PkiIssuerSignWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuerSignWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuerSignWithRoleResponse>("/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuerSignWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuerSignWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersGenerateIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuersGenerateIntermediateResponse> PkiIssuersGenerateIntermediate(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiIssuersGenerateIntermediate");


            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->PkiIssuersGenerateIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuersGenerateIntermediateResponse>("/{pki_mount_path}/issuers/generate/intermediate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersGenerateIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersGenerateIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateIntermediateRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersGenerateIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiIssuersGenerateIntermediateResponse>> PkiIssuersGenerateIntermediateAsync(string exported, PkiIssuersGenerateIntermediateRequest pkiIssuersGenerateIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiIssuersGenerateIntermediate");


            // verify the required parameter 'pkiIssuersGenerateIntermediateRequest' is set
            if (pkiIssuersGenerateIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateIntermediateRequest' when calling Secrets->PkiIssuersGenerateIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuersGenerateIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuersGenerateIntermediateResponse>("/{pki_mount_path}/issuers/generate/intermediate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersGenerateIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersGenerateIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersGenerateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuersGenerateRootResponse> PkiIssuersGenerateRoot(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiIssuersGenerateRoot");


            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->PkiIssuersGenerateRoot");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuersGenerateRootRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuersGenerateRootResponse>("/{pki_mount_path}/issuers/generate/root/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersGenerateRootResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersGenerateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersGenerateRootResponse)</returns>
        public async Task<VaultResponse<PkiIssuersGenerateRootResponse>> PkiIssuersGenerateRootAsync(string exported, PkiIssuersGenerateRootRequest pkiIssuersGenerateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiIssuersGenerateRoot");


            // verify the required parameter 'pkiIssuersGenerateRootRequest' is set
            if (pkiIssuersGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersGenerateRootRequest' when calling Secrets->PkiIssuersGenerateRoot");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuersGenerateRootRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuersGenerateRootResponse>("/{pki_mount_path}/issuers/generate/root/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersGenerateRootResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportBundleRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersImportBundleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuersImportBundleResponse> PkiIssuersImportBundle(PkiIssuersImportBundleRequest pkiIssuersImportBundleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiIssuersImportBundleRequest' is set
            if (pkiIssuersImportBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersImportBundleRequest' when calling Secrets->PkiIssuersImportBundle");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuersImportBundleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuersImportBundleResponse>("/{pki_mount_path}/issuers/import/bundle", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersImportBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersImportBundleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportBundleRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersImportBundleResponse)</returns>
        public async Task<VaultResponse<PkiIssuersImportBundleResponse>> PkiIssuersImportBundleAsync(PkiIssuersImportBundleRequest pkiIssuersImportBundleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiIssuersImportBundleRequest' is set
            if (pkiIssuersImportBundleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersImportBundleRequest' when calling Secrets->PkiIssuersImportBundle");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuersImportBundleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuersImportBundleResponse>("/{pki_mount_path}/issuers/import/bundle", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersImportBundle", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersImportBundleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiIssuersImportCertResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiIssuersImportCertResponse> PkiIssuersImportCert(PkiIssuersImportCertRequest pkiIssuersImportCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiIssuersImportCertRequest' is set
            if (pkiIssuersImportCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersImportCertRequest' when calling Secrets->PkiIssuersImportCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiIssuersImportCertRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiIssuersImportCertResponse>("/{pki_mount_path}/issuers/import/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersImportCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersImportCertResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiIssuersImportCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiIssuersImportCertResponse)</returns>
        public async Task<VaultResponse<PkiIssuersImportCertResponse>> PkiIssuersImportCertAsync(PkiIssuersImportCertRequest pkiIssuersImportCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiIssuersImportCertRequest' is set
            if (pkiIssuersImportCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiIssuersImportCertRequest' when calling Secrets->PkiIssuersImportCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiIssuersImportCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiIssuersImportCertResponse>("/{pki_mount_path}/issuers/import/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiIssuersImportCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiIssuersImportCertResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListCertsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListCertsResponse> PkiListCerts(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListCertsResponse>("/{pki_mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListCertsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListCertsResponse)</returns>
        public async Task<VaultResponse<PkiListCertsResponse>> PkiListCertsAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListCertsResponse>("/{pki_mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListCertsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListEabKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListEabKeysResponse> PkiListEabKeys(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListEabKeysResponse>("/{pki_mount_path}/eab", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListEabKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListEabKeysResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListEabKeysResponse)</returns>
        public async Task<VaultResponse<PkiListEabKeysResponse>> PkiListEabKeysAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListEabKeysResponse>("/{pki_mount_path}/eab", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListEabKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListEabKeysResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListIssuersResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListIssuersResponse> PkiListIssuers(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListIssuersResponse>("/{pki_mount_path}/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListIssuersResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListIssuersResponse)</returns>
        public async Task<VaultResponse<PkiListIssuersResponse>> PkiListIssuersAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListIssuersResponse>("/{pki_mount_path}/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListIssuers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListIssuersResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListKeysResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListKeysResponse> PkiListKeys(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListKeysResponse>("/{pki_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListKeysResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListKeysResponse)</returns>
        public async Task<VaultResponse<PkiListKeysResponse>> PkiListKeysAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListKeysResponse>("/{pki_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListKeysResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListRevokedCertsResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListRevokedCertsResponse> PkiListRevokedCerts(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListRevokedCertsResponse>("/{pki_mount_path}/certs/revoked", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListRevokedCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListRevokedCertsResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListRevokedCertsResponse)</returns>
        public async Task<VaultResponse<PkiListRevokedCertsResponse>> PkiListRevokedCertsAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListRevokedCertsResponse>("/{pki_mount_path}/certs/revoked", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListRevokedCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListRevokedCertsResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiListRolesResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiListRolesResponse> PkiListRoles(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<PkiListRolesResponse>("/{pki_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListRolesResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiListRolesResponse)</returns>
        public async Task<VaultResponse<PkiListRolesResponse>> PkiListRolesAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiListRolesResponse>("/{pki_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiListRolesResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiQueryOcsp(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/ocsp", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiQueryOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiQueryOcspAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/ocsp", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiQueryOcsp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiQueryOcspWithGetReq(string req, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->PkiQueryOcspWithGetReq");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/ocsp/{req}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiQueryOcspWithGetReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="req">base-64 encoded ocsp request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiQueryOcspWithGetReqAsync(string req, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'req' is set
            if (req == null)
                throw new VaultApiException(400, "Missing required parameter 'req' when calling Secrets->PkiQueryOcspWithGetReq");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("req", ClientUtils.ParameterToString(req)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/ocsp/{req}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiQueryOcspWithGetReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadAcmeConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/config/acme", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadAcmeConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/config/acme", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadAcmeDirectory(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/acme/directory", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadAcmeDirectoryAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/acme/directory", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadAcmeNewNonce(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/acme/new-nonce", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadAcmeNewNonceAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/acme/new-nonce", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadAutoTidyConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadAutoTidyConfigurationResponse> PkiReadAutoTidyConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadAutoTidyConfigurationResponse>("/{pki_mount_path}/config/auto-tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAutoTidyConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadAutoTidyConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadAutoTidyConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadAutoTidyConfigurationResponse>> PkiReadAutoTidyConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadAutoTidyConfigurationResponse>("/{pki_mount_path}/config/auto-tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadAutoTidyConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadAutoTidyConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaChainPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCaChainPemResponse> PkiReadCaChainPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCaChainPemResponse>("/{pki_mount_path}/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaChainPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaChainPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaChainPemResponse)</returns>
        public async Task<VaultResponse<PkiReadCaChainPemResponse>> PkiReadCaChainPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCaChainPemResponse>("/{pki_mount_path}/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaChainPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaChainPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCaDerResponse> PkiReadCaDer(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCaDerResponse>("/{pki_mount_path}/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaDerResponse)</returns>
        public async Task<VaultResponse<PkiReadCaDerResponse>> PkiReadCaDerAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCaDerResponse>("/{pki_mount_path}/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCaPemResponse> PkiReadCaPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCaPemResponse>("/{pki_mount_path}/ca/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCaPemResponse)</returns>
        public async Task<VaultResponse<PkiReadCaPemResponse>> PkiReadCaPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCaPemResponse>("/{pki_mount_path}/ca/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCaPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertResponse> PkiReadCert(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertResponse>("/{pki_mount_path}/cert/{serial}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertResponse)</returns>
        public async Task<VaultResponse<PkiReadCertResponse>> PkiReadCertAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCert");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertResponse>("/{pki_mount_path}/cert/{serial}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertCaChainResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertCaChainResponse> PkiReadCertCaChain(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertCaChainResponse>("/{pki_mount_path}/cert/ca_chain", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertCaChainResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertCaChainResponse)</returns>
        public async Task<VaultResponse<PkiReadCertCaChainResponse>> PkiReadCertCaChainAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertCaChainResponse>("/{pki_mount_path}/cert/ca_chain", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertCaChain", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertCaChainResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertCrlResponse> PkiReadCertCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertCrlResponse>("/{pki_mount_path}/cert/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertCrlResponse)</returns>
        public async Task<VaultResponse<PkiReadCertCrlResponse>> PkiReadCertCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertCrlResponse>("/{pki_mount_path}/cert/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertDeltaCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertDeltaCrlResponse> PkiReadCertDeltaCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertDeltaCrlResponse>("/{pki_mount_path}/cert/delta-crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertDeltaCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertDeltaCrlResponse)</returns>
        public async Task<VaultResponse<PkiReadCertDeltaCrlResponse>> PkiReadCertDeltaCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertDeltaCrlResponse>("/{pki_mount_path}/cert/delta-crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertDeltaCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertRawDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertRawDerResponse> PkiReadCertRawDer(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCertRawDer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertRawDerResponse>("/{pki_mount_path}/cert/{serial}/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertRawDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertRawDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertRawDerResponse)</returns>
        public async Task<VaultResponse<PkiReadCertRawDerResponse>> PkiReadCertRawDerAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCertRawDer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertRawDerResponse>("/{pki_mount_path}/cert/{serial}/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertRawDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertRawDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCertRawPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCertRawPemResponse> PkiReadCertRawPem(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCertRawPem");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCertRawPemResponse>("/{pki_mount_path}/cert/{serial}/raw/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertRawPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="serial">Certificate serial number, in colon- or hyphen-separated octal</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCertRawPemResponse)</returns>
        public async Task<VaultResponse<PkiReadCertRawPemResponse>> PkiReadCertRawPemAsync(string serial, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'serial' is set
            if (serial == null)
                throw new VaultApiException(400, "Missing required parameter 'serial' when calling Secrets->PkiReadCertRawPem");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("serial", ClientUtils.ParameterToString(serial)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCertRawPemResponse>("/{pki_mount_path}/cert/{serial}/raw/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCertRawPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCertRawPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadClusterConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadClusterConfigurationResponse> PkiReadClusterConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadClusterConfigurationResponse>("/{pki_mount_path}/config/cluster", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadClusterConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadClusterConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadClusterConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadClusterConfigurationResponse>> PkiReadClusterConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadClusterConfigurationResponse>("/{pki_mount_path}/config/cluster", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadClusterConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadClusterConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCrlConfigurationResponse> PkiReadCrlConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCrlConfigurationResponse>("/{pki_mount_path}/config/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadCrlConfigurationResponse>> PkiReadCrlConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCrlConfigurationResponse>("/{pki_mount_path}/config/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDeltaResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCrlDeltaResponse> PkiReadCrlDelta(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCrlDeltaResponse>("/{pki_mount_path}/crl/delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDeltaResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDeltaResponse)</returns>
        public async Task<VaultResponse<PkiReadCrlDeltaResponse>> PkiReadCrlDeltaAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCrlDeltaResponse>("/{pki_mount_path}/crl/delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDelta", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDeltaResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDeltaPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCrlDeltaPemResponse> PkiReadCrlDeltaPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCrlDeltaPemResponse>("/{pki_mount_path}/crl/delta/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDeltaPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDeltaPemResponse)</returns>
        public async Task<VaultResponse<PkiReadCrlDeltaPemResponse>> PkiReadCrlDeltaPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCrlDeltaPemResponse>("/{pki_mount_path}/crl/delta/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDeltaPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDeltaPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCrlDerResponse> PkiReadCrlDer(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCrlDerResponse>("/{pki_mount_path}/crl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlDerResponse)</returns>
        public async Task<VaultResponse<PkiReadCrlDerResponse>> PkiReadCrlDerAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCrlDerResponse>("/{pki_mount_path}/crl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadCrlPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadCrlPemResponse> PkiReadCrlPem(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadCrlPemResponse>("/{pki_mount_path}/crl/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadCrlPemResponse)</returns>
        public async Task<VaultResponse<PkiReadCrlPemResponse>> PkiReadCrlPemAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadCrlPemResponse>("/{pki_mount_path}/crl/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadCrlPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadCrlPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadIssuerResponse> PkiReadIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerResponse)</returns>
        public async Task<VaultResponse<PkiReadIssuerResponse>> PkiReadIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerDerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadIssuerDerResponse> PkiReadIssuerDer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerDer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadIssuerDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/der", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerDerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerDerResponse)</returns>
        public async Task<VaultResponse<PkiReadIssuerDerResponse>> PkiReadIssuerDerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerDer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadIssuerDerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/der", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerDer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerDerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadIssuerIssuerRefAcmeDirectory(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefAcmeDirectory");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/directory", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadIssuerIssuerRefAcmeDirectoryAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefAcmeDirectory");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/directory", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadIssuerIssuerRefAcmeNewNonce(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefAcmeNewNonce");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-nonce", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadIssuerIssuerRefAcmeNewNonceAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefAcmeNewNonce");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-nonce", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadIssuerIssuerRefRolesRoleAcmeDirectory(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeDirectory");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeDirectory");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/directory", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefRolesRoleAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadIssuerIssuerRefRolesRoleAcmeDirectoryAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeDirectory");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeDirectory");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/directory", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefRolesRoleAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-nonce", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadIssuerIssuerRefRolesRoleAcmeNewNonceAsync(string issuerRef, string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-nonce", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerIssuerRefRolesRoleAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerJsonResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadIssuerJsonResponse> PkiReadIssuerJson(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerJson");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadIssuerJsonResponse>("/{pki_mount_path}/issuer/{issuer_ref}/json", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerJsonResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerJsonResponse)</returns>
        public async Task<VaultResponse<PkiReadIssuerJsonResponse>> PkiReadIssuerJsonAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerJson");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadIssuerJsonResponse>("/{pki_mount_path}/issuer/{issuer_ref}/json", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerJson", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerJsonResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuerPemResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadIssuerPemResponse> PkiReadIssuerPem(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerPem");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadIssuerPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/pem", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerPemResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuerPemResponse)</returns>
        public async Task<VaultResponse<PkiReadIssuerPemResponse>> PkiReadIssuerPemAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiReadIssuerPem");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadIssuerPemResponse>("/{pki_mount_path}/issuer/{issuer_ref}/pem", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuerPem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuerPemResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadIssuersConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadIssuersConfigurationResponse> PkiReadIssuersConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadIssuersConfigurationResponse>("/{pki_mount_path}/config/issuers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuersConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuersConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadIssuersConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadIssuersConfigurationResponse>> PkiReadIssuersConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadIssuersConfigurationResponse>("/{pki_mount_path}/config/issuers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadIssuersConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadIssuersConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadKeyResponse> PkiReadKey(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiReadKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadKeyResponse>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadKeyResponse)</returns>
        public async Task<VaultResponse<PkiReadKeyResponse>> PkiReadKeyAsync(string keyRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiReadKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadKeyResponse>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadKeysConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadKeysConfigurationResponse> PkiReadKeysConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadKeysConfigurationResponse>("/{pki_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadKeysConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadKeysConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadKeysConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadKeysConfigurationResponse>> PkiReadKeysConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadKeysConfigurationResponse>("/{pki_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadKeysConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadKeysConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadRoleResponse> PkiReadRole(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadRoleResponse>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadRoleResponse)</returns>
        public async Task<VaultResponse<PkiReadRoleResponse>> PkiReadRoleAsync(string name, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadRoleResponse>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadRolesRoleAcmeDirectory(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadRolesRoleAcmeDirectory");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/roles/{role}/acme/directory", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRolesRoleAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadRolesRoleAcmeDirectoryAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadRolesRoleAcmeDirectory");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/roles/{role}/acme/directory", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRolesRoleAcmeDirectory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiReadRolesRoleAcmeNewNonce(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadRolesRoleAcmeNewNonce");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{pki_mount_path}/roles/{role}/acme/new-nonce", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRolesRoleAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiReadRolesRoleAcmeNewNonceAsync(string role, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiReadRolesRoleAcmeNewNonce");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{pki_mount_path}/roles/{role}/acme/new-nonce", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadRolesRoleAcmeNewNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReadUrlsConfigurationResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReadUrlsConfigurationResponse> PkiReadUrlsConfiguration(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiReadUrlsConfigurationResponse>("/{pki_mount_path}/config/urls", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadUrlsConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadUrlsConfigurationResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReadUrlsConfigurationResponse)</returns>
        public async Task<VaultResponse<PkiReadUrlsConfigurationResponse>> PkiReadUrlsConfigurationAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiReadUrlsConfigurationResponse>("/{pki_mount_path}/config/urls", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReadUrlsConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReadUrlsConfigurationResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiReplaceRootRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiReplaceRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiReplaceRootResponse> PkiReplaceRoot(PkiReplaceRootRequest pkiReplaceRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiReplaceRootRequest' is set
            if (pkiReplaceRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiReplaceRootRequest' when calling Secrets->PkiReplaceRoot");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiReplaceRootRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiReplaceRootResponse>("/{pki_mount_path}/root/replace", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReplaceRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReplaceRootResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiReplaceRootRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiReplaceRootResponse)</returns>
        public async Task<VaultResponse<PkiReplaceRootResponse>> PkiReplaceRootAsync(PkiReplaceRootRequest pkiReplaceRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiReplaceRootRequest' is set
            if (pkiReplaceRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiReplaceRootRequest' when calling Secrets->PkiReplaceRoot");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiReplaceRootRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiReplaceRootResponse>("/{pki_mount_path}/root/replace", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiReplaceRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiReplaceRootResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRevokeResponse> PkiRevoke(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->PkiRevoke");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiRevokeRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiRevokeResponse>("/{pki_mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeResponse)</returns>
        public async Task<VaultResponse<PkiRevokeResponse>> PkiRevokeAsync(PkiRevokeRequest pkiRevokeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiRevokeRequest' is set
            if (pkiRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeRequest' when calling Secrets->PkiRevoke");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiRevokeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRevokeResponse>("/{pki_mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRevokeIssuerResponse> PkiRevokeIssuer(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiRevokeIssuer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiRevokeIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevokeIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeIssuerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeIssuerResponse)</returns>
        public async Task<VaultResponse<PkiRevokeIssuerResponse>> PkiRevokeIssuerAsync(string issuerRef, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiRevokeIssuer");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRevokeIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevokeIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeIssuerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRevokeWithKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRevokeWithKeyResponse> PkiRevokeWithKey(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->PkiRevokeWithKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiRevokeWithKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiRevokeWithKeyResponse>("/{pki_mount_path}/revoke-with-key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeWithKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRevokeWithKeyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRevokeWithKeyResponse)</returns>
        public async Task<VaultResponse<PkiRevokeWithKeyResponse>> PkiRevokeWithKeyAsync(PkiRevokeWithKeyRequest pkiRevokeWithKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiRevokeWithKeyRequest' is set
            if (pkiRevokeWithKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRevokeWithKeyRequest' when calling Secrets->PkiRevokeWithKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiRevokeWithKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRevokeWithKeyResponse>("/{pki_mount_path}/revoke-with-key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRevokeWithKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRevokeWithKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRootSignIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRootSignIntermediateResponse> PkiRootSignIntermediate(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->PkiRootSignIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiRootSignIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiRootSignIntermediateResponse>("/{pki_mount_path}/root/sign-intermediate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRootSignIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRootSignIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiRootSignIntermediateResponse>> PkiRootSignIntermediateAsync(PkiRootSignIntermediateRequest pkiRootSignIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiRootSignIntermediateRequest' is set
            if (pkiRootSignIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignIntermediateRequest' when calling Secrets->PkiRootSignIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiRootSignIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRootSignIntermediateResponse>("/{pki_mount_path}/root/sign-intermediate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRootSignIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRootSignIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRootSignSelfIssuedResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRootSignSelfIssuedResponse> PkiRootSignSelfIssued(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->PkiRootSignSelfIssued");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiRootSignSelfIssuedRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiRootSignSelfIssuedResponse>("/{pki_mount_path}/root/sign-self-issued", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRootSignSelfIssuedResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRootSignSelfIssuedRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRootSignSelfIssuedResponse)</returns>
        public async Task<VaultResponse<PkiRootSignSelfIssuedResponse>> PkiRootSignSelfIssuedAsync(PkiRootSignSelfIssuedRequest pkiRootSignSelfIssuedRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiRootSignSelfIssuedRequest' is set
            if (pkiRootSignSelfIssuedRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRootSignSelfIssuedRequest' when calling Secrets->PkiRootSignSelfIssued");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiRootSignSelfIssuedRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRootSignSelfIssuedResponse>("/{pki_mount_path}/root/sign-self-issued", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRootSignSelfIssued", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRootSignSelfIssuedResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRotateCrlResponse> PkiRotateCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiRotateCrlResponse>("/{pki_mount_path}/crl/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateCrlResponse)</returns>
        public async Task<VaultResponse<PkiRotateCrlResponse>> PkiRotateCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiRotateCrlResponse>("/{pki_mount_path}/crl/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateDeltaCrlResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRotateDeltaCrlResponse> PkiRotateDeltaCrl(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiRotateDeltaCrlResponse>("/{pki_mount_path}/crl/rotate-delta", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateDeltaCrlResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateDeltaCrlResponse)</returns>
        public async Task<VaultResponse<PkiRotateDeltaCrlResponse>> PkiRotateDeltaCrlAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiRotateDeltaCrlResponse>("/{pki_mount_path}/crl/rotate-delta", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateDeltaCrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateDeltaCrlResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRotateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiRotateRootResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiRotateRootResponse> PkiRotateRoot(string exported, PkiRotateRootRequest pkiRotateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiRotateRoot");


            // verify the required parameter 'pkiRotateRootRequest' is set
            if (pkiRotateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRotateRootRequest' when calling Secrets->PkiRotateRoot");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiRotateRootRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiRotateRootResponse>("/{pki_mount_path}/root/rotate/{exported}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateRootResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiRotateRootRequest"></param>
        /// <param name="exported">Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiRotateRootResponse)</returns>
        public async Task<VaultResponse<PkiRotateRootResponse>> PkiRotateRootAsync(string exported, PkiRotateRootRequest pkiRotateRootRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'exported' is set
            if (exported == null)
                throw new VaultApiException(400, "Missing required parameter 'exported' when calling Secrets->PkiRotateRoot");


            // verify the required parameter 'pkiRotateRootRequest' is set
            if (pkiRotateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiRotateRootRequest' when calling Secrets->PkiRotateRoot");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("exported", ClientUtils.ParameterToString(exported)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiRotateRootRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiRotateRootResponse>("/{pki_mount_path}/root/rotate/{exported}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiRotateRootResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSetSignedIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSetSignedIntermediateResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiSetSignedIntermediateResponse> PkiSetSignedIntermediate(PkiSetSignedIntermediateRequest pkiSetSignedIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiSetSignedIntermediateRequest' is set
            if (pkiSetSignedIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSetSignedIntermediateRequest' when calling Secrets->PkiSetSignedIntermediate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiSetSignedIntermediateRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiSetSignedIntermediateResponse>("/{pki_mount_path}/intermediate/set-signed", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSetSignedIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSetSignedIntermediateResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSetSignedIntermediateRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSetSignedIntermediateResponse)</returns>
        public async Task<VaultResponse<PkiSetSignedIntermediateResponse>> PkiSetSignedIntermediateAsync(PkiSetSignedIntermediateRequest pkiSetSignedIntermediateRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiSetSignedIntermediateRequest' is set
            if (pkiSetSignedIntermediateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSetSignedIntermediateRequest' when calling Secrets->PkiSetSignedIntermediate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiSetSignedIntermediateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiSetSignedIntermediateResponse>("/{pki_mount_path}/intermediate/set-signed", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSetSignedIntermediate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSetSignedIntermediateResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignVerbatimResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiSignVerbatimResponse> PkiSignVerbatim(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PkiSignVerbatim");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiSignVerbatimRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiSignVerbatimResponse>("/{pki_mount_path}/sign-verbatim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignVerbatimResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignVerbatimResponse)</returns>
        public async Task<VaultResponse<PkiSignVerbatimResponse>> PkiSignVerbatimAsync(PkiSignVerbatimRequest pkiSignVerbatimRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiSignVerbatimRequest' is set
            if (pkiSignVerbatimRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimRequest' when calling Secrets->PkiSignVerbatim");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiSignVerbatimRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiSignVerbatimResponse>("/{pki_mount_path}/sign-verbatim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignVerbatim", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignVerbatimResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignVerbatimWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiSignVerbatimWithRoleResponse> PkiSignVerbatimWithRole(string role, PkiSignVerbatimWithRoleRequest pkiSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiSignVerbatimWithRole");


            // verify the required parameter 'pkiSignVerbatimWithRoleRequest' is set
            if (pkiSignVerbatimWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimWithRoleRequest' when calling Secrets->PkiSignVerbatimWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiSignVerbatimWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiSignVerbatimWithRoleResponse>("/{pki_mount_path}/sign-verbatim/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignVerbatimWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignVerbatimWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignVerbatimWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignVerbatimWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiSignVerbatimWithRoleResponse>> PkiSignVerbatimWithRoleAsync(string role, PkiSignVerbatimWithRoleRequest pkiSignVerbatimWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiSignVerbatimWithRole");


            // verify the required parameter 'pkiSignVerbatimWithRoleRequest' is set
            if (pkiSignVerbatimWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignVerbatimWithRoleRequest' when calling Secrets->PkiSignVerbatimWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiSignVerbatimWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiSignVerbatimWithRoleResponse>("/{pki_mount_path}/sign-verbatim/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignVerbatimWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignVerbatimWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiSignWithRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiSignWithRoleResponse> PkiSignWithRole(string role, PkiSignWithRoleRequest pkiSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiSignWithRole");


            // verify the required parameter 'pkiSignWithRoleRequest' is set
            if (pkiSignWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignWithRoleRequest' when calling Secrets->PkiSignWithRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiSignWithRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiSignWithRoleResponse>("/{pki_mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignWithRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiSignWithRoleRequest"></param>
        /// <param name="role">The desired role with configuration for this request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiSignWithRoleResponse)</returns>
        public async Task<VaultResponse<PkiSignWithRoleResponse>> PkiSignWithRoleAsync(string role, PkiSignWithRoleRequest pkiSignWithRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiSignWithRole");


            // verify the required parameter 'pkiSignWithRoleRequest' is set
            if (pkiSignWithRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiSignWithRoleRequest' when calling Secrets->PkiSignWithRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiSignWithRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiSignWithRoleResponse>("/{pki_mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiSignWithRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiSignWithRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiTidy(PkiTidyRequest pkiTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->PkiTidy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiTidyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiTidyRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiTidyAsync(PkiTidyRequest pkiTidyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiTidyRequest' is set
            if (pkiTidyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiTidyRequest' when calling Secrets->PkiTidy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiTidyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiTidyCancelResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiTidyCancelResponse> PkiTidyCancel(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<PkiTidyCancelResponse>("/{pki_mount_path}/tidy-cancel", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiTidyCancelResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiTidyCancelResponse)</returns>
        public async Task<VaultResponse<PkiTidyCancelResponse>> PkiTidyCancelAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiTidyCancelResponse>("/{pki_mount_path}/tidy-cancel", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidyCancel", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiTidyCancelResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiTidyStatusResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiTidyStatusResponse> PkiTidyStatus(string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<PkiTidyStatusResponse>("/{pki_mount_path}/tidy-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiTidyStatusResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiTidyStatusResponse)</returns>
        public async Task<VaultResponse<PkiTidyStatusResponse>> PkiTidyStatusAsync(string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<PkiTidyStatusResponse>("/{pki_mount_path}/tidy-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiTidyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiTidyStatusResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeAccountKid(string kid, PkiWriteAcmeAccountKidRequest pkiWriteAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteAcmeAccountKid");


            // verify the required parameter 'pkiWriteAcmeAccountKidRequest' is set
            if (pkiWriteAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeAccountKidRequest' when calling Secrets->PkiWriteAcmeAccountKid");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeAccountKidRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/account/{kid}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeAccountKidAsync(string kid, PkiWriteAcmeAccountKidRequest pkiWriteAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteAcmeAccountKid");


            // verify the required parameter 'pkiWriteAcmeAccountKidRequest' is set
            if (pkiWriteAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeAccountKidRequest' when calling Secrets->PkiWriteAcmeAccountKid");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeAccountKidRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/account/{kid}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeAuthorizationAuthId(string authId, PkiWriteAcmeAuthorizationAuthIdRequest pkiWriteAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteAcmeAuthorizationAuthId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeAuthorizationAuthIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/authorization/{auth_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeAuthorizationAuthIdAsync(string authId, PkiWriteAcmeAuthorizationAuthIdRequest pkiWriteAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteAcmeAuthorizationAuthId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeAuthorizationAuthIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/authorization/{auth_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeChallengeAuthIdChallengeType(string authId, string challengeType, PkiWriteAcmeChallengeAuthIdChallengeTypeRequest pkiWriteAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeChallengeAuthIdChallengeTypeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/challenge/{auth_id}/{challenge_type}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, PkiWriteAcmeChallengeAuthIdChallengeTypeRequest pkiWriteAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteAcmeChallengeAuthIdChallengeType");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeChallengeAuthIdChallengeTypeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/challenge/{auth_id}/{challenge_type}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewAccountRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeNewAccount(PkiWriteAcmeNewAccountRequest pkiWriteAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiWriteAcmeNewAccountRequest' is set
            if (pkiWriteAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeNewAccountRequest' when calling Secrets->PkiWriteAcmeNewAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeNewAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/new-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewAccountRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeNewAccountAsync(PkiWriteAcmeNewAccountRequest pkiWriteAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiWriteAcmeNewAccountRequest' is set
            if (pkiWriteAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeNewAccountRequest' when calling Secrets->PkiWriteAcmeNewAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeNewAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/new-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewOrderRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeNewOrder(PkiWriteAcmeNewOrderRequest pkiWriteAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiWriteAcmeNewOrderRequest' is set
            if (pkiWriteAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeNewOrderRequest' when calling Secrets->PkiWriteAcmeNewOrder");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeNewOrderRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/new-order", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeNewOrderRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeNewOrderAsync(PkiWriteAcmeNewOrderRequest pkiWriteAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiWriteAcmeNewOrderRequest' is set
            if (pkiWriteAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeNewOrderRequest' when calling Secrets->PkiWriteAcmeNewOrder");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeNewOrderRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/new-order", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeOrderOrderId(string orderId, PkiWriteAcmeOrderOrderIdRequest pkiWriteAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdRequest' is set
            if (pkiWriteAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteAcmeOrderOrderId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeOrderOrderIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/order/{order_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdAsync(string orderId, PkiWriteAcmeOrderOrderIdRequest pkiWriteAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdRequest' is set
            if (pkiWriteAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteAcmeOrderOrderId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeOrderOrderIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/order/{order_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeOrderOrderIdCert(string orderId, PkiWriteAcmeOrderOrderIdCertRequest pkiWriteAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteAcmeOrderOrderIdCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeOrderOrderIdCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/order/{order_id}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdCertAsync(string orderId, PkiWriteAcmeOrderOrderIdCertRequest pkiWriteAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteAcmeOrderOrderIdCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeOrderOrderIdCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/order/{order_id}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeOrderOrderIdFinalize(string orderId, PkiWriteAcmeOrderOrderIdFinalizeRequest pkiWriteAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteAcmeOrderOrderIdFinalize");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeOrderOrderIdFinalizeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/order/{order_id}/finalize", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeOrderOrderIdFinalizeAsync(string orderId, PkiWriteAcmeOrderOrderIdFinalizeRequest pkiWriteAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteAcmeOrderOrderIdFinalize");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeOrderOrderIdFinalizeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/order/{order_id}/finalize", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrdersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeOrders(PkiWriteAcmeOrdersRequest pkiWriteAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiWriteAcmeOrdersRequest' is set
            if (pkiWriteAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrdersRequest' when calling Secrets->PkiWriteAcmeOrders");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeOrdersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/orders", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeOrdersRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeOrdersAsync(PkiWriteAcmeOrdersRequest pkiWriteAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiWriteAcmeOrdersRequest' is set
            if (pkiWriteAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeOrdersRequest' when calling Secrets->PkiWriteAcmeOrders");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeOrdersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/orders", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeRevokeCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteAcmeRevokeCert(PkiWriteAcmeRevokeCertRequest pkiWriteAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'pkiWriteAcmeRevokeCertRequest' is set
            if (pkiWriteAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeRevokeCertRequest' when calling Secrets->PkiWriteAcmeRevokeCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteAcmeRevokeCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/acme/revoke-cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteAcmeRevokeCertRequest"></param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteAcmeRevokeCertAsync(PkiWriteAcmeRevokeCertRequest pkiWriteAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'pkiWriteAcmeRevokeCertRequest' is set
            if (pkiWriteAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteAcmeRevokeCertRequest' when calling Secrets->PkiWriteAcmeRevokeCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteAcmeRevokeCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/acme/revoke-cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteIssuerResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiWriteIssuerResponse> PkiWriteIssuer(string issuerRef, PkiWriteIssuerRequest pkiWriteIssuerRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuer");


            // verify the required parameter 'pkiWriteIssuerRequest' is set
            if (pkiWriteIssuerRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerRequest' when calling Secrets->PkiWriteIssuer");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiWriteIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteIssuerResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerRequest"></param>
        /// <param name="issuerRef">Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteIssuerResponse)</returns>
        public async Task<VaultResponse<PkiWriteIssuerResponse>> PkiWriteIssuerAsync(string issuerRef, PkiWriteIssuerRequest pkiWriteIssuerRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuer");


            // verify the required parameter 'pkiWriteIssuerRequest' is set
            if (pkiWriteIssuerRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerRequest' when calling Secrets->PkiWriteIssuer");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiWriteIssuerResponse>("/{pki_mount_path}/issuer/{issuer_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuer", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteIssuerResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeAccountKid(string issuerRef, string kid, PkiWriteIssuerIssuerRefAcmeAccountKidRequest pkiWriteIssuerIssuerRefAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeAccountKidRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeAccountKidRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeAccountKidRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/account/{kid}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeAccountKidAsync(string issuerRef, string kid, PkiWriteIssuerIssuerRefAcmeAccountKidRequest pkiWriteIssuerIssuerRefAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeAccountKidRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeAccountKidRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAccountKid");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeAccountKidRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/account/{kid}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId(string authId, string issuerRef, PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/authorization/{auth_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdAsync(string authId, string issuerRef, PkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeAuthorizationAuthIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/authorization/{auth_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string issuerRef, PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/challenge/{auth_id}/{challenge_type}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string issuerRef, PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeTypeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/challenge/{auth_id}/{challenge_type}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeNewAccount(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewAccountRequest pkiWriteIssuerIssuerRefAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewAccount");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeNewAccountRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeNewAccountRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeNewAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeNewAccountAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewAccountRequest pkiWriteIssuerIssuerRefAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewAccount");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeNewAccountRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeNewAccountRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeNewAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeNewOrder(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewOrderRequest pkiWriteIssuerIssuerRefAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewOrder");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeNewOrderRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeNewOrderRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewOrder");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeNewOrderRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-order", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeNewOrderAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeNewOrderRequest pkiWriteIssuerIssuerRefAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewOrder");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeNewOrderRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeNewOrderRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeNewOrder");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeNewOrderRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/new-order", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderId(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/finalize", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeAsync(string issuerRef, string orderId, PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalizeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/order/{order_id}/finalize", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeOrders(string issuerRef, PkiWriteIssuerIssuerRefAcmeOrdersRequest pkiWriteIssuerIssuerRefAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrders");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrdersRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrdersRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrders");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrdersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/orders", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeOrdersAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeOrdersRequest pkiWriteIssuerIssuerRefAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrders");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeOrdersRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeOrdersRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeOrders");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeOrdersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/orders", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefAcmeRevokeCert(string issuerRef, PkiWriteIssuerIssuerRefAcmeRevokeCertRequest pkiWriteIssuerIssuerRefAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeRevokeCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeRevokeCertRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeRevokeCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeRevokeCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeRevokeCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/revoke-cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefAcmeRevokeCertAsync(string issuerRef, PkiWriteIssuerIssuerRefAcmeRevokeCertRequest pkiWriteIssuerIssuerRefAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefAcmeRevokeCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefAcmeRevokeCertRequest' is set
            if (pkiWriteIssuerIssuerRefAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefAcmeRevokeCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefAcmeRevokeCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefAcmeRevokeCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/acme/revoke-cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid(string issuerRef, string kid, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/account/{kid}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidAsync(string issuerRef, string kid, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeAccountKidRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/account/{kid}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId(string authId, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/authorization/{auth_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdAsync(string authId, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/authorization/{auth_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeTypeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeNewAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-order", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeNewOrderRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/new-order", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/finalize", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeAsync(string issuerRef, string orderId, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalizeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/order/{order_id}/finalize", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeOrders(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/orders", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeOrders");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeOrdersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/orders", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/revoke-cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="issuerRef">Reference to an existing issuer name or issuer id</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertAsync(string issuerRef, string role, PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'issuerRef' is set
            if (issuerRef == null)
                throw new VaultApiException(400, "Missing required parameter 'issuerRef' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");


            // verify the required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest' is set
            if (pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest' when calling Secrets->PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("issuer_ref", ClientUtils.ParameterToString(issuerRef)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/issuer/{issuer_ref}/roles/{role}/acme/revoke-cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteIssuerIssuerRefRolesRoleAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteKeyRequest"></param>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteKeyResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiWriteKeyResponse> PkiWriteKey(string keyRef, PkiWriteKeyRequest pkiWriteKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiWriteKey");


            // verify the required parameter 'pkiWriteKeyRequest' is set
            if (pkiWriteKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteKeyRequest' when calling Secrets->PkiWriteKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiWriteKeyResponse>("/{pki_mount_path}/key/{key_ref}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteKeyResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteKeyRequest"></param>
        /// <param name="keyRef">Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteKeyResponse)</returns>
        public async Task<VaultResponse<PkiWriteKeyResponse>> PkiWriteKeyAsync(string keyRef, PkiWriteKeyRequest pkiWriteKeyRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'keyRef' is set
            if (keyRef == null)
                throw new VaultApiException(400, "Missing required parameter 'keyRef' when calling Secrets->PkiWriteKey");


            // verify the required parameter 'pkiWriteKeyRequest' is set
            if (pkiWriteKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteKeyRequest' when calling Secrets->PkiWriteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("key_ref", ClientUtils.ParameterToString(keyRef)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiWriteKeyResponse>("/{pki_mount_path}/key/{key_ref}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteKeyResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of PkiWriteRoleResponse</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<PkiWriteRoleResponse> PkiWriteRole(string name, PkiWriteRoleRequest pkiWriteRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiWriteRole");


            // verify the required parameter 'pkiWriteRoleRequest' is set
            if (pkiWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRoleRequest' when calling Secrets->PkiWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<PkiWriteRoleResponse>("/{pki_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteRoleResponse>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse (PkiWriteRoleResponse)</returns>
        public async Task<VaultResponse<PkiWriteRoleResponse>> PkiWriteRoleAsync(string name, PkiWriteRoleRequest pkiWriteRoleRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->PkiWriteRole");


            // verify the required parameter 'pkiWriteRoleRequest' is set
            if (pkiWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRoleRequest' when calling Secrets->PkiWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<PkiWriteRoleResponse>("/{pki_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<PkiWriteRoleResponse>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeAccountKid(string kid, string role, PkiWriteRolesRoleAcmeAccountKidRequest pkiWriteRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");


            // verify the required parameter 'pkiWriteRolesRoleAcmeAccountKidRequest' is set
            if (pkiWriteRolesRoleAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeAccountKidRequest' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeAccountKidRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/account/{kid}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAccountKidRequest"></param>
        /// <param name="kid">The key identifier provided by the CA</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeAccountKidAsync(string kid, string role, PkiWriteRolesRoleAcmeAccountKidRequest pkiWriteRolesRoleAcmeAccountKidRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'kid' is set
            if (kid == null)
                throw new VaultApiException(400, "Missing required parameter 'kid' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");


            // verify the required parameter 'pkiWriteRolesRoleAcmeAccountKidRequest' is set
            if (pkiWriteRolesRoleAcmeAccountKidRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeAccountKidRequest' when calling Secrets->PkiWriteRolesRoleAcmeAccountKid");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("kid", ClientUtils.ParameterToString(kid)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeAccountKidRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/account/{kid}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeAccountKid", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeAuthorizationAuthId(string authId, string role, PkiWriteRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/authorization/{auth_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeAuthorizationAuthIdAsync(string authId, string role, PkiWriteRolesRoleAcmeAuthorizationAuthIdRequest pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");


            // verify the required parameter 'pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest' is set
            if (pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest' when calling Secrets->PkiWriteRolesRoleAcmeAuthorizationAuthId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeAuthorizationAuthIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/authorization/{auth_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeAuthorizationAuthId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType(string authId, string challengeType, string role, PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest"></param>
        /// <param name="authId">ACME authorization identifier value</param>
        /// <param name="challengeType">ACME challenge type</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeAsync(string authId, string challengeType, string role, PkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'authId' is set
            if (authId == null)
                throw new VaultApiException(400, "Missing required parameter 'authId' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'challengeType' is set
            if (challengeType == null)
                throw new VaultApiException(400, "Missing required parameter 'challengeType' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");


            // verify the required parameter 'pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' is set
            if (pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest' when calling Secrets->PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("auth_id", ClientUtils.ParameterToString(authId)); // path parameter


            requestOptions.PathParameters.Add("challenge_type", ClientUtils.ParameterToString(challengeType)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeChallengeAuthIdChallengeTypeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/challenge/{auth_id}/{challenge_type}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeChallengeAuthIdChallengeType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeNewAccount(string role, PkiWriteRolesRoleAcmeNewAccountRequest pkiWriteRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeNewAccount");


            // verify the required parameter 'pkiWriteRolesRoleAcmeNewAccountRequest' is set
            if (pkiWriteRolesRoleAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeNewAccountRequest' when calling Secrets->PkiWriteRolesRoleAcmeNewAccount");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeNewAccountRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/new-account", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewAccountRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeNewAccountAsync(string role, PkiWriteRolesRoleAcmeNewAccountRequest pkiWriteRolesRoleAcmeNewAccountRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeNewAccount");


            // verify the required parameter 'pkiWriteRolesRoleAcmeNewAccountRequest' is set
            if (pkiWriteRolesRoleAcmeNewAccountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeNewAccountRequest' when calling Secrets->PkiWriteRolesRoleAcmeNewAccount");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeNewAccountRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/new-account", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeNewAccount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeNewOrder(string role, PkiWriteRolesRoleAcmeNewOrderRequest pkiWriteRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeNewOrder");


            // verify the required parameter 'pkiWriteRolesRoleAcmeNewOrderRequest' is set
            if (pkiWriteRolesRoleAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeNewOrderRequest' when calling Secrets->PkiWriteRolesRoleAcmeNewOrder");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeNewOrderRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/new-order", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeNewOrderRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeNewOrderAsync(string role, PkiWriteRolesRoleAcmeNewOrderRequest pkiWriteRolesRoleAcmeNewOrderRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeNewOrder");


            // verify the required parameter 'pkiWriteRolesRoleAcmeNewOrderRequest' is set
            if (pkiWriteRolesRoleAcmeNewOrderRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeNewOrderRequest' when calling Secrets->PkiWriteRolesRoleAcmeNewOrder");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeNewOrderRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/new-order", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeNewOrder", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderId(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdRequest pkiWriteRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdRequest pkiWriteRolesRoleAcmeOrderOrderIdRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderIdCert(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdCertRequest pkiWriteRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}/cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdCertRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdCertAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdCertRequest pkiWriteRolesRoleAcmeOrderOrderIdCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdCertRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdCertRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}/cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderIdCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeOrderOrderIdFinalize(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}/finalize", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest"></param>
        /// <param name="orderId">The ACME order identifier to fetch</param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrderOrderIdFinalizeAsync(string orderId, string role, PkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new VaultApiException(400, "Missing required parameter 'orderId' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest' is set
            if (pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrderOrderIdFinalize");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeOrderOrderIdFinalizeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/order/{order_id}/finalize", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrderOrderIdFinalize", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrdersRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeOrders(string role, PkiWriteRolesRoleAcmeOrdersRequest pkiWriteRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrders");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrdersRequest' is set
            if (pkiWriteRolesRoleAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrdersRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrders");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeOrdersRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/orders", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeOrdersRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeOrdersAsync(string role, PkiWriteRolesRoleAcmeOrdersRequest pkiWriteRolesRoleAcmeOrdersRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeOrders");


            // verify the required parameter 'pkiWriteRolesRoleAcmeOrdersRequest' is set
            if (pkiWriteRolesRoleAcmeOrdersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeOrdersRequest' when calling Secrets->PkiWriteRolesRoleAcmeOrders");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeOrdersRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/orders", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeOrders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PkiWriteRolesRoleAcmeRevokeCert(string role, PkiWriteRolesRoleAcmeRevokeCertRequest pkiWriteRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeRevokeCert");


            // verify the required parameter 'pkiWriteRolesRoleAcmeRevokeCertRequest' is set
            if (pkiWriteRolesRoleAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeRevokeCertRequest' when calling Secrets->PkiWriteRolesRoleAcmeRevokeCert");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter





            requestOptions.Data = pkiWriteRolesRoleAcmeRevokeCertRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{pki_mount_path}/roles/{role}/acme/revoke-cert", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="pkiWriteRolesRoleAcmeRevokeCertRequest"></param>
        /// <param name="role">The desired role for the acme request</param>
        /// <param name="pkiMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PkiWriteRolesRoleAcmeRevokeCertAsync(string role, PkiWriteRolesRoleAcmeRevokeCertRequest pkiWriteRolesRoleAcmeRevokeCertRequest, string pkiMountPath = "pki", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->PkiWriteRolesRoleAcmeRevokeCert");


            // verify the required parameter 'pkiWriteRolesRoleAcmeRevokeCertRequest' is set
            if (pkiWriteRolesRoleAcmeRevokeCertRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'pkiWriteRolesRoleAcmeRevokeCertRequest' when calling Secrets->PkiWriteRolesRoleAcmeRevokeCert");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("pki_mount_path", ClientUtils.ParameterToString(pkiMountPath)); // path parameter



            requestOptions.Data = pkiWriteRolesRoleAcmeRevokeCertRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{pki_mount_path}/roles/{role}/acme/revoke-cert", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PkiWriteRolesRoleAcmeRevokeCert", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqConfigureConnection(RabbitMqConfigureConnectionRequest rabbitMqConfigureConnectionRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'rabbitMqConfigureConnectionRequest' is set
            if (rabbitMqConfigureConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqConfigureConnectionRequest' when calling Secrets->RabbitMqConfigureConnection");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter





            requestOptions.Data = rabbitMqConfigureConnectionRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/config/connection", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqConfigureConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureConnectionRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqConfigureConnectionAsync(RabbitMqConfigureConnectionRequest rabbitMqConfigureConnectionRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'rabbitMqConfigureConnectionRequest' is set
            if (rabbitMqConfigureConnectionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqConfigureConnectionRequest' when calling Secrets->RabbitMqConfigureConnection");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            requestOptions.Data = rabbitMqConfigureConnectionRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/config/connection", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqConfigureConnection", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqConfigureLease(RabbitMqConfigureLeaseRequest rabbitMqConfigureLeaseRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'rabbitMqConfigureLeaseRequest' is set
            if (rabbitMqConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqConfigureLeaseRequest' when calling Secrets->RabbitMqConfigureLease");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter





            requestOptions.Data = rabbitMqConfigureLeaseRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqConfigureLeaseRequest"></param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqConfigureLeaseAsync(RabbitMqConfigureLeaseRequest rabbitMqConfigureLeaseRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'rabbitMqConfigureLeaseRequest' is set
            if (rabbitMqConfigureLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqConfigureLeaseRequest' when calling Secrets->RabbitMqConfigureLease");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            requestOptions.Data = rabbitMqConfigureLeaseRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqConfigureLease", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqDeleteRole(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqDeleteRoleAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqListRoles(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqListRolesAsync(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqReadLeaseConfiguration(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqReadLeaseConfigurationAsync(string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/config/lease", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqReadLeaseConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqReadRole(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqReadRoleAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Request RabbitMQ credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqRequestCredentials(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqRequestCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{rabbitmq_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqRequestCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Request RabbitMQ credentials for a certain role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqRequestCredentialsAsync(string name, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqRequestCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{rabbitmq_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqRequestCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> RabbitMqWriteRole(string name, RabbitMqWriteRoleRequest rabbitMqWriteRoleRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqWriteRole");


            // verify the required parameter 'rabbitMqWriteRoleRequest' is set
            if (rabbitMqWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqWriteRoleRequest' when calling Secrets->RabbitMqWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter





            requestOptions.Data = rabbitMqWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the roles that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="rabbitMqWriteRoleRequest"></param>
        /// <param name="name">Name of the role.</param>
        /// <param name="rabbitmqMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> RabbitMqWriteRoleAsync(string name, RabbitMqWriteRoleRequest rabbitMqWriteRoleRequest, string rabbitmqMountPath = "rabbitmq", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->RabbitMqWriteRole");


            // verify the required parameter 'rabbitMqWriteRoleRequest' is set
            if (rabbitMqWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'rabbitMqWriteRoleRequest' when calling Secrets->RabbitMqWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("rabbitmq_mount_path", ClientUtils.ParameterToString(rabbitmqMountPath)); // path parameter



            requestOptions.Data = rabbitMqWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{rabbitmq_mount_path}/roles/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RabbitMqWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureCaRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshConfigureCa(SshConfigureCaRequest sshConfigureCaRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'sshConfigureCaRequest' is set
            if (sshConfigureCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigureCaRequest' when calling Secrets->SshConfigureCa");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshConfigureCaRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshConfigureCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureCaRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshConfigureCaAsync(SshConfigureCaRequest sshConfigureCaRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'sshConfigureCaRequest' is set
            if (sshConfigureCaRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigureCaRequest' when calling Secrets->SshConfigureCa");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshConfigureCaRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshConfigureCa", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureZeroAddressRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshConfigureZeroAddress(SshConfigureZeroAddressRequest sshConfigureZeroAddressRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'sshConfigureZeroAddressRequest' is set
            if (sshConfigureZeroAddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigureZeroAddressRequest' when calling Secrets->SshConfigureZeroAddress");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshConfigureZeroAddressRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshConfigureZeroAddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshConfigureZeroAddressRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshConfigureZeroAddressAsync(SshConfigureZeroAddressRequest sshConfigureZeroAddressRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'sshConfigureZeroAddressRequest' is set
            if (sshConfigureZeroAddressRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshConfigureZeroAddressRequest' when calling Secrets->SshConfigureZeroAddress");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshConfigureZeroAddressRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshConfigureZeroAddress", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshDeleteCaConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteCaConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshDeleteCaConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteCaConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshDeleteRole(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshDeleteRoleAsync(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshDeleteZeroAddressConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteZeroAddressConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshDeleteZeroAddressConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshDeleteZeroAddressConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshGenerateCredentialsRequest"></param>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshGenerateCredentials(string role, SshGenerateCredentialsRequest sshGenerateCredentialsRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshGenerateCredentials");


            // verify the required parameter 'sshGenerateCredentialsRequest' is set
            if (sshGenerateCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshGenerateCredentialsRequest' when calling Secrets->SshGenerateCredentials");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshGenerateCredentialsRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/creds/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Creates a credential for establishing SSH connection with the remote host. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshGenerateCredentialsRequest"></param>
        /// <param name="role">[Required] Name of the role</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshGenerateCredentialsAsync(string role, SshGenerateCredentialsRequest sshGenerateCredentialsRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshGenerateCredentials");


            // verify the required parameter 'sshGenerateCredentialsRequest' is set
            if (sshGenerateCredentialsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshGenerateCredentialsRequest' when calling Secrets->SshGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshGenerateCredentialsRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/creds/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshIssueCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshIssueCertificate(string role, SshIssueCertificateRequest sshIssueCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshIssueCertificate");


            // verify the required parameter 'sshIssueCertificateRequest' is set
            if (sshIssueCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueCertificateRequest' when calling Secrets->SshIssueCertificate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshIssueCertificateRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/issue/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshIssueCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshIssueCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshIssueCertificateAsync(string role, SshIssueCertificateRequest sshIssueCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshIssueCertificate");


            // verify the required parameter 'sshIssueCertificateRequest' is set
            if (sshIssueCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshIssueCertificateRequest' when calling Secrets->SshIssueCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshIssueCertificateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/issue/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshIssueCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshListRoles(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshListRolesAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshListRolesByIpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshListRolesByIp(SshListRolesByIpRequest sshListRolesByIpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'sshListRolesByIpRequest' is set
            if (sshListRolesByIpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshListRolesByIpRequest' when calling Secrets->SshListRolesByIp");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshListRolesByIpRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshListRolesByIp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// List all the roles associated with the given IP address. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshListRolesByIpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshListRolesByIpAsync(SshListRolesByIpRequest sshListRolesByIpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'sshListRolesByIpRequest' is set
            if (sshListRolesByIpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshListRolesByIpRequest' when calling Secrets->SshListRolesByIp");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshListRolesByIpRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshListRolesByIp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshReadCaConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/config/ca", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadCaConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshReadCaConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/config/ca", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadCaConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshReadPublicKey(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/public_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the public key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshReadPublicKeyAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/public_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadPublicKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshReadRole(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshReadRoleAsync(string role, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshReadZeroAddressConfiguration(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadZeroAddressConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshReadZeroAddressConfigurationAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{ssh_mount_path}/config/zeroaddress", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshReadZeroAddressConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshSignCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshSignCertificate(string role, SshSignCertificateRequest sshSignCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshSignCertificate");


            // verify the required parameter 'sshSignCertificateRequest' is set
            if (sshSignCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignCertificateRequest' when calling Secrets->SshSignCertificate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshSignCertificateRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/sign/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshSignCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Request signing an SSH key using a certain role with the provided details. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshSignCertificateRequest"></param>
        /// <param name="role">The desired role with configuration for this request.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshSignCertificateAsync(string role, SshSignCertificateRequest sshSignCertificateRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshSignCertificate");


            // verify the required parameter 'sshSignCertificateRequest' is set
            if (sshSignCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshSignCertificateRequest' when calling Secrets->SshSignCertificate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshSignCertificateRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/sign/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshSignCertificate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// This endpoint removes the stored host keys used for the removed Dynamic Key feature, if present. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshTidyDynamicHostKeys(string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{ssh_mount_path}/tidy/dynamic-keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshTidyDynamicHostKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint removes the stored host keys used for the removed Dynamic Key feature, if present. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshTidyDynamicHostKeysAsync(string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{ssh_mount_path}/tidy/dynamic-keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshTidyDynamicHostKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyOtpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshVerifyOtp(SshVerifyOtpRequest sshVerifyOtpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'sshVerifyOtpRequest' is set
            if (sshVerifyOtpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyOtpRequest' when calling Secrets->SshVerifyOtp");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshVerifyOtpRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshVerifyOtp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Validate the OTP provided by Vault SSH Agent. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshVerifyOtpRequest"></param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshVerifyOtpAsync(SshVerifyOtpRequest sshVerifyOtpRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'sshVerifyOtpRequest' is set
            if (sshVerifyOtpRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshVerifyOtpRequest' when calling Secrets->SshVerifyOtp");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshVerifyOtpRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshVerifyOtp", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshWriteRoleRequest"></param>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> SshWriteRole(string role, SshWriteRoleRequest sshWriteRoleRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshWriteRole");


            // verify the required parameter 'sshWriteRoleRequest' is set
            if (sshWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshWriteRoleRequest' when calling Secrets->SshWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter





            requestOptions.Data = sshWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{ssh_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the &#x27;roles&#x27; that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="sshWriteRoleRequest"></param>
        /// <param name="role">[Required for all types] Name of the role being created.</param>
        /// <param name="sshMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> SshWriteRoleAsync(string role, SshWriteRoleRequest sshWriteRoleRequest, string sshMountPath = "ssh", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Secrets->SshWriteRole");


            // verify the required parameter 'sshWriteRoleRequest' is set
            if (sshWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'sshWriteRoleRequest' when calling Secrets->SshWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter


            requestOptions.PathParameters.Add("ssh_mount_path", ClientUtils.ParameterToString(sshMountPath)); // path parameter



            requestOptions.Data = sshWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{ssh_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("SshWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudConfigureRequest"></param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudConfigure(TerraformCloudConfigureRequest terraformCloudConfigureRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'terraformCloudConfigureRequest' is set
            if (terraformCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformCloudConfigureRequest' when calling Secrets->TerraformCloudConfigure");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter





            requestOptions.Data = terraformCloudConfigureRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudConfigureRequest"></param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudConfigureAsync(TerraformCloudConfigureRequest terraformCloudConfigureRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'terraformCloudConfigureRequest' is set
            if (terraformCloudConfigureRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformCloudConfigureRequest' when calling Secrets->TerraformCloudConfigure");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            requestOptions.Data = terraformCloudConfigureRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudConfigure", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudDeleteConfiguration(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudDeleteConfigurationAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudDeleteConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudDeleteRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudDeleteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudDeleteRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudDeleteRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudDeleteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudGenerateCredentials(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudGenerateCredentials");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/creds/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudGenerateCredentialsAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudGenerateCredentials");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/creds/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudGenerateCredentials", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudListRoles(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudListRolesAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudListRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudReadConfiguration(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudReadConfigurationAsync(string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudReadConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudReadRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudReadRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudReadRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudReadRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudReadRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudRotateRole(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudRotateRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/rotate-role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudRotateRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the team or organization role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudRotateRoleAsync(string name, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudRotateRole");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/rotate-role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudRotateRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TerraformCloudWriteRole(string name, TerraformCloudWriteRoleRequest terraformCloudWriteRoleRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudWriteRole");


            // verify the required parameter 'terraformCloudWriteRoleRequest' is set
            if (terraformCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformCloudWriteRoleRequest' when calling Secrets->TerraformCloudWriteRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter





            requestOptions.Data = terraformCloudWriteRoleRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{terraform_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="terraformCloudWriteRoleRequest"></param>
        /// <param name="name">Name of the role</param>
        /// <param name="terraformMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TerraformCloudWriteRoleAsync(string name, TerraformCloudWriteRoleRequest terraformCloudWriteRoleRequest, string terraformMountPath = "terraform", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TerraformCloudWriteRole");


            // verify the required parameter 'terraformCloudWriteRoleRequest' is set
            if (terraformCloudWriteRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'terraformCloudWriteRoleRequest' when calling Secrets->TerraformCloudWriteRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("terraform_mount_path", ClientUtils.ParameterToString(terraformMountPath)); // path parameter



            requestOptions.Data = terraformCloudWriteRoleRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{terraform_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TerraformCloudWriteRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpCreateKeyRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpCreateKey(string name, TotpCreateKeyRequest totpCreateKeyRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpCreateKey");


            // verify the required parameter 'totpCreateKeyRequest' is set
            if (totpCreateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCreateKeyRequest' when calling Secrets->TotpCreateKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter





            requestOptions.Data = totpCreateKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpCreateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpCreateKeyRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpCreateKeyAsync(string name, TotpCreateKeyRequest totpCreateKeyRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpCreateKey");


            // verify the required parameter 'totpCreateKeyRequest' is set
            if (totpCreateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpCreateKeyRequest' when calling Secrets->TotpCreateKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            requestOptions.Data = totpCreateKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpCreateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpDeleteKey(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpDeleteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpDeleteKeyAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpDeleteKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpGenerateCode(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpGenerateCode");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpGenerateCode", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpGenerateCodeAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpGenerateCode");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpGenerateCode", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpListKeys(string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Manage the keys that can be created with this backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpListKeysAsync(string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpReadKey(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpReadKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{totp_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpReadKeyAsync(string name, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpReadKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{totp_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpValidateCodeRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TotpValidateCode(string name, TotpValidateCodeRequest totpValidateCodeRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpValidateCode");


            // verify the required parameter 'totpValidateCodeRequest' is set
            if (totpValidateCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpValidateCodeRequest' when calling Secrets->TotpValidateCode");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter





            requestOptions.Data = totpValidateCodeRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{totp_mount_path}/code/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpValidateCode", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="totpValidateCodeRequest"></param>
        /// <param name="name">Name of the key.</param>
        /// <param name="totpMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TotpValidateCodeAsync(string name, TotpValidateCodeRequest totpValidateCodeRequest, string totpMountPath = "totp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TotpValidateCode");


            // verify the required parameter 'totpValidateCodeRequest' is set
            if (totpValidateCodeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'totpValidateCodeRequest' when calling Secrets->TotpValidateCode");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("totp_mount_path", ClientUtils.ParameterToString(totpMountPath)); // path parameter



            requestOptions.Data = totpValidateCodeRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{totp_mount_path}/code/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TotpValidateCode", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitBackUpKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitBackUpKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/backup/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitBackUpKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Backup the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitBackUpKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitBackUpKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/backup/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitBackUpKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Securely export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitByokKey(string destination, string source, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'destination' is set
            if (destination == null)
                throw new VaultApiException(400, "Missing required parameter 'destination' when calling Secrets->TransitByokKey");

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitByokKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("destination", ClientUtils.ParameterToString(destination)); // path parameter


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/byok-export/{destination}/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitByokKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Securely export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitByokKeyAsync(string destination, string source, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'destination' is set
            if (destination == null)
                throw new VaultApiException(400, "Missing required parameter 'destination' when calling Secrets->TransitByokKey");

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitByokKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("destination", ClientUtils.ParameterToString(destination)); // path parameter


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/byok-export/{destination}/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitByokKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Securely export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="version">Optional version of the key to export, else all key versions are exported.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitByokKeyVersion(string destination, string source, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'destination' is set
            if (destination == null)
                throw new VaultApiException(400, "Missing required parameter 'destination' when calling Secrets->TransitByokKeyVersion");

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitByokKeyVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->TransitByokKeyVersion");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("destination", ClientUtils.ParameterToString(destination)); // path parameter


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/byok-export/{destination}/{source}/{version}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitByokKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Securely export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="destination">Destination key to export to; usually the public wrapping key of another Transit instance.</param>
        /// <param name="source">Source key to export; could be any present key within Transit.</param>
        /// <param name="version">Optional version of the key to export, else all key versions are exported.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitByokKeyVersionAsync(string destination, string source, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'destination' is set
            if (destination == null)
                throw new VaultApiException(400, "Missing required parameter 'destination' when calling Secrets->TransitByokKeyVersion");

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitByokKeyVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->TransitByokKeyVersion");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("destination", ClientUtils.ParameterToString(destination)); // path parameter


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/byok-export/{destination}/{source}/{version}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitByokKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureCacheRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitConfigureCache(TransitConfigureCacheRequest transitConfigureCacheRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'transitConfigureCacheRequest' is set
            if (transitConfigureCacheRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureCacheRequest' when calling Secrets->TransitConfigureCache");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitConfigureCacheRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureCache", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configures a new cache of the specified size 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureCacheRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitConfigureCacheAsync(TransitConfigureCacheRequest transitConfigureCacheRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'transitConfigureCacheRequest' is set
            if (transitConfigureCacheRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureCacheRequest' when calling Secrets->TransitConfigureCache");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitConfigureCacheRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureCache", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitConfigureKey(string name, TransitConfigureKeyRequest transitConfigureKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitConfigureKey");


            // verify the required parameter 'transitConfigureKeyRequest' is set
            if (transitConfigureKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureKeyRequest' when calling Secrets->TransitConfigureKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitConfigureKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Configure a named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitConfigureKeyAsync(string name, TransitConfigureKeyRequest transitConfigureKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitConfigureKey");


            // verify the required parameter 'transitConfigureKeyRequest' is set
            if (transitConfigureKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureKeyRequest' when calling Secrets->TransitConfigureKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitConfigureKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeysRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitConfigureKeys(TransitConfigureKeysRequest transitConfigureKeysRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'transitConfigureKeysRequest' is set
            if (transitConfigureKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureKeysRequest' when calling Secrets->TransitConfigureKeys");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitConfigureKeysRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitConfigureKeysRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitConfigureKeysAsync(TransitConfigureKeysRequest transitConfigureKeysRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'transitConfigureKeysRequest' is set
            if (transitConfigureKeysRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitConfigureKeysRequest' when calling Secrets->TransitConfigureKeys");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitConfigureKeysRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitConfigureKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCreateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitCreateKey(string name, TransitCreateKeyRequest transitCreateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitCreateKey");


            // verify the required parameter 'transitCreateKeyRequest' is set
            if (transitCreateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCreateKeyRequest' when calling Secrets->TransitCreateKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitCreateKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitCreateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitCreateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitCreateKeyAsync(string name, TransitCreateKeyRequest transitCreateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitCreateKey");


            // verify the required parameter 'transitCreateKeyRequest' is set
            if (transitCreateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitCreateKeyRequest' when calling Secrets->TransitCreateKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitCreateKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitCreateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitDecrypt(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitDecrypt");


            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->TransitDecrypt");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitDecryptRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/decrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitDecrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Decrypt a ciphertext value using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitDecryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitDecryptAsync(string name, TransitDecryptRequest transitDecryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitDecrypt");


            // verify the required parameter 'transitDecryptRequest' is set
            if (transitDecryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitDecryptRequest' when calling Secrets->TransitDecrypt");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitDecryptRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/decrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitDecrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitDeleteKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitDeleteKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Delete<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitDeleteKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitDeleteKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitDeleteKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitEncrypt(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitEncrypt");


            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->TransitEncrypt");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitEncryptRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/encrypt/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitEncrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Encrypt a plaintext value or a batch of plaintext blocks using a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitEncryptRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitEncryptAsync(string name, TransitEncryptRequest transitEncryptRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitEncrypt");


            // verify the required parameter 'transitEncryptRequest' is set
            if (transitEncryptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitEncryptRequest' when calling Secrets->TransitEncrypt");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitEncryptRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/encrypt/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitEncrypt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitExportKey(string name, string type, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitExportKey");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->TransitExportKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/export/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitExportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitExportKeyAsync(string name, string type, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitExportKey");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->TransitExportKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/export/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitExportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitExportKeyVersion(string name, string type, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitExportKeyVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->TransitExportKeyVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->TransitExportKeyVersion");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter


            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/export/{type}/{name}/{version}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitExportKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Export named encryption or signing key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="type">Type of key to export (encryption-key, signing-key, hmac-key, public-key)</param>
        /// <param name="version">Version of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitExportKeyVersionAsync(string name, string type, string version, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitExportKeyVersion");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling Secrets->TransitExportKeyVersion");

            // verify the required parameter 'version' is set
            if (version == null)
                throw new VaultApiException(400, "Missing required parameter 'version' when calling Secrets->TransitExportKeyVersion");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter


            requestOptions.PathParameters.Add("version", ClientUtils.ParameterToString(version)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/export/{type}/{name}/{version}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitExportKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateDataKeyRequest"></param>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateDataKey(string name, string plaintext, TransitGenerateDataKeyRequest transitGenerateDataKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateDataKey");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->TransitGenerateDataKey");


            // verify the required parameter 'transitGenerateDataKeyRequest' is set
            if (transitGenerateDataKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateDataKeyRequest' when calling Secrets->TransitGenerateDataKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateDataKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/datakey/{plaintext}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateDataKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate a data key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateDataKeyRequest"></param>
        /// <param name="name">The backend key used for encrypting the data key</param>
        /// <param name="plaintext">\&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateDataKeyAsync(string name, string plaintext, TransitGenerateDataKeyRequest transitGenerateDataKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateDataKey");

            // verify the required parameter 'plaintext' is set
            if (plaintext == null)
                throw new VaultApiException(400, "Missing required parameter 'plaintext' when calling Secrets->TransitGenerateDataKey");


            // verify the required parameter 'transitGenerateDataKeyRequest' is set
            if (transitGenerateDataKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateDataKeyRequest' when calling Secrets->TransitGenerateDataKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("plaintext", ClientUtils.ParameterToString(plaintext)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateDataKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/datakey/{plaintext}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateDataKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateHmac(string name, TransitGenerateHmacRequest transitGenerateHmacRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateHmac");


            // verify the required parameter 'transitGenerateHmacRequest' is set
            if (transitGenerateHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateHmacRequest' when calling Secrets->TransitGenerateHmac");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateHmacRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hmac/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateHmac", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateHmacAsync(string name, TransitGenerateHmacRequest transitGenerateHmacRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateHmac");


            // verify the required parameter 'transitGenerateHmacRequest' is set
            if (transitGenerateHmacRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateHmacRequest' when calling Secrets->TransitGenerateHmac");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateHmacRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hmac/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateHmac", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacWithAlgorithmRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateHmacWithAlgorithm(string name, string urlalgorithm, TransitGenerateHmacWithAlgorithmRequest transitGenerateHmacWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateHmacWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitGenerateHmacWithAlgorithm");


            // verify the required parameter 'transitGenerateHmacWithAlgorithmRequest' is set
            if (transitGenerateHmacWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateHmacWithAlgorithmRequest' when calling Secrets->TransitGenerateHmacWithAlgorithm");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateHmacWithAlgorithmRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hmac/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateHmacWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate an HMAC for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateHmacWithAlgorithmRequest"></param>
        /// <param name="name">The key to use for the HMAC function</param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateHmacWithAlgorithmAsync(string name, string urlalgorithm, TransitGenerateHmacWithAlgorithmRequest transitGenerateHmacWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitGenerateHmacWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitGenerateHmacWithAlgorithm");


            // verify the required parameter 'transitGenerateHmacWithAlgorithmRequest' is set
            if (transitGenerateHmacWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateHmacWithAlgorithmRequest' when calling Secrets->TransitGenerateHmacWithAlgorithm");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateHmacWithAlgorithmRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hmac/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateHmacWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateRandom(TransitGenerateRandomRequest transitGenerateRandomRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'transitGenerateRandomRequest' is set
            if (transitGenerateRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomRequest' when calling Secrets->TransitGenerateRandom");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateRandomRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateRandomAsync(TransitGenerateRandomRequest transitGenerateRandomRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'transitGenerateRandomRequest' is set
            if (transitGenerateRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomRequest' when calling Secrets->TransitGenerateRandom");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateRandomRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithBytesRequest"></param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateRandomWithBytes(string urlbytes, TransitGenerateRandomWithBytesRequest transitGenerateRandomWithBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->TransitGenerateRandomWithBytes");


            // verify the required parameter 'transitGenerateRandomWithBytesRequest' is set
            if (transitGenerateRandomWithBytesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithBytesRequest' when calling Secrets->TransitGenerateRandomWithBytes");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateRandomWithBytesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithBytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithBytesRequest"></param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateRandomWithBytesAsync(string urlbytes, TransitGenerateRandomWithBytesRequest transitGenerateRandomWithBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->TransitGenerateRandomWithBytes");


            // verify the required parameter 'transitGenerateRandomWithBytesRequest' is set
            if (transitGenerateRandomWithBytesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithBytesRequest' when calling Secrets->TransitGenerateRandomWithBytes");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateRandomWithBytesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithBytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateRandomWithSource(string source, TransitGenerateRandomWithSourceRequest transitGenerateRandomWithSourceRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitGenerateRandomWithSource");


            // verify the required parameter 'transitGenerateRandomWithSourceRequest' is set
            if (transitGenerateRandomWithSourceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithSourceRequest' when calling Secrets->TransitGenerateRandomWithSource");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateRandomWithSourceRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateRandomWithSourceAsync(string source, TransitGenerateRandomWithSourceRequest transitGenerateRandomWithSourceRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitGenerateRandomWithSource");


            // verify the required parameter 'transitGenerateRandomWithSourceRequest' is set
            if (transitGenerateRandomWithSourceRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithSourceRequest' when calling Secrets->TransitGenerateRandomWithSource");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateRandomWithSourceRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceAndBytesRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitGenerateRandomWithSourceAndBytes(string source, string urlbytes, TransitGenerateRandomWithSourceAndBytesRequest transitGenerateRandomWithSourceAndBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");


            // verify the required parameter 'transitGenerateRandomWithSourceAndBytesRequest' is set
            if (transitGenerateRandomWithSourceAndBytesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithSourceAndBytesRequest' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitGenerateRandomWithSourceAndBytesRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/random/{source}/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithSourceAndBytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitGenerateRandomWithSourceAndBytesRequest"></param>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitGenerateRandomWithSourceAndBytesAsync(string source, string urlbytes, TransitGenerateRandomWithSourceAndBytesRequest transitGenerateRandomWithSourceAndBytesRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");


            // verify the required parameter 'transitGenerateRandomWithSourceAndBytesRequest' is set
            if (transitGenerateRandomWithSourceAndBytesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitGenerateRandomWithSourceAndBytesRequest' when calling Secrets->TransitGenerateRandomWithSourceAndBytes");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter


            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitGenerateRandomWithSourceAndBytesRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/random/{source}/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitGenerateRandomWithSourceAndBytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitHash(TransitHashRequest transitHashRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->TransitHash");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitHashRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hash", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitHashAsync(TransitHashRequest transitHashRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'transitHashRequest' is set
            if (transitHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashRequest' when calling Secrets->TransitHash");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitHashRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hash", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashWithAlgorithmRequest"></param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitHashWithAlgorithm(string urlalgorithm, TransitHashWithAlgorithmRequest transitHashWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitHashWithAlgorithm");


            // verify the required parameter 'transitHashWithAlgorithmRequest' is set
            if (transitHashWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashWithAlgorithmRequest' when calling Secrets->TransitHashWithAlgorithm");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitHashWithAlgorithmRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/hash/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitHashWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitHashWithAlgorithmRequest"></param>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitHashWithAlgorithmAsync(string urlalgorithm, TransitHashWithAlgorithmRequest transitHashWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitHashWithAlgorithm");


            // verify the required parameter 'transitHashWithAlgorithmRequest' is set
            if (transitHashWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitHashWithAlgorithmRequest' when calling Secrets->TransitHashWithAlgorithm");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitHashWithAlgorithmRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/hash/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitHashWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitImportKey(string name, TransitImportKeyRequest transitImportKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitImportKey");


            // verify the required parameter 'transitImportKeyRequest' is set
            if (transitImportKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitImportKeyRequest' when calling Secrets->TransitImportKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitImportKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/import", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitImportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into a new transit key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitImportKeyAsync(string name, TransitImportKeyRequest transitImportKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitImportKey");


            // verify the required parameter 'transitImportKeyRequest' is set
            if (transitImportKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitImportKeyRequest' when calling Secrets->TransitImportKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitImportKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/import", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitImportKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyVersionRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitImportKeyVersion(string name, TransitImportKeyVersionRequest transitImportKeyVersionRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitImportKeyVersion");


            // verify the required parameter 'transitImportKeyVersionRequest' is set
            if (transitImportKeyVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitImportKeyVersionRequest' when calling Secrets->TransitImportKeyVersion");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitImportKeyVersionRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/import_version", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitImportKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Imports an externally-generated key into an existing imported key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitImportKeyVersionRequest"></param>
        /// <param name="name">The name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitImportKeyVersionAsync(string name, TransitImportKeyVersionRequest transitImportKeyVersionRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitImportKeyVersion");


            // verify the required parameter 'transitImportKeyVersionRequest' is set
            if (transitImportKeyVersionRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitImportKeyVersionRequest' when calling Secrets->TransitImportKeyVersion");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitImportKeyVersionRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/import_version", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitImportKeyVersion", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitListKeys(string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));





            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Managed named encryption keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitListKeysAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", "true"));


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitListKeys", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitReadCacheConfiguration(string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/cache-config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadCacheConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Returns the size of the active cache 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitReadCacheConfigurationAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/cache-config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadCacheConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitReadKey(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitReadKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/keys/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitReadKeyAsync(string name, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitReadKey");



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/keys/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitReadKeysConfiguration(string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/config/keys", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadKeysConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitReadKeysConfigurationAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/config/keys", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadKeysConfiguration", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitReadWrappingKey(string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter






            // make the HTTP request
            var response = this.Client.Get<Object>("/{transit_mount_path}/wrapping_key", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Returns the public key to use for wrapping imported keys 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitReadWrappingKeyAsync(string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {



            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {

            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/{transit_mount_path}/wrapping_key", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitReadWrappingKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreAndRenameKeyRequest"></param>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitRestoreAndRenameKey(string name, TransitRestoreAndRenameKeyRequest transitRestoreAndRenameKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRestoreAndRenameKey");


            // verify the required parameter 'transitRestoreAndRenameKeyRequest' is set
            if (transitRestoreAndRenameKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreAndRenameKeyRequest' when calling Secrets->TransitRestoreAndRenameKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitRestoreAndRenameKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/restore/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRestoreAndRenameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreAndRenameKeyRequest"></param>
        /// <param name="name">If set, this will be the name of the restored key.</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitRestoreAndRenameKeyAsync(string name, TransitRestoreAndRenameKeyRequest transitRestoreAndRenameKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRestoreAndRenameKey");


            // verify the required parameter 'transitRestoreAndRenameKeyRequest' is set
            if (transitRestoreAndRenameKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreAndRenameKeyRequest' when calling Secrets->TransitRestoreAndRenameKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitRestoreAndRenameKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/restore/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRestoreAndRenameKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreKeyRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitRestoreKey(TransitRestoreKeyRequest transitRestoreKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {


            // verify the required parameter 'transitRestoreKeyRequest' is set
            if (transitRestoreKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreKeyRequest' when calling Secrets->TransitRestoreKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitRestoreKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/restore", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRestoreKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Restore the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRestoreKeyRequest"></param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitRestoreKeyAsync(TransitRestoreKeyRequest transitRestoreKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {


            // verify the required parameter 'transitRestoreKeyRequest' is set
            if (transitRestoreKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRestoreKeyRequest' when calling Secrets->TransitRestoreKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitRestoreKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/restore", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRestoreKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitRewrap(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRewrap");


            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->TransitRewrap");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitRewrapRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/rewrap/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRewrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Rewrap ciphertext 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRewrapRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitRewrapAsync(string name, TransitRewrapRequest transitRewrapRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRewrap");


            // verify the required parameter 'transitRewrapRequest' is set
            if (transitRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRewrapRequest' when calling Secrets->TransitRewrap");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitRewrapRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/rewrap/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRewrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRotateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitRotateKey(string name, TransitRotateKeyRequest transitRotateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRotateKey");


            // verify the required parameter 'transitRotateKeyRequest' is set
            if (transitRotateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRotateKeyRequest' when calling Secrets->TransitRotateKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitRotateKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Rotate named encryption key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitRotateKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitRotateKeyAsync(string name, TransitRotateKeyRequest transitRotateKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitRotateKey");


            // verify the required parameter 'transitRotateKeyRequest' is set
            if (transitRotateKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitRotateKeyRequest' when calling Secrets->TransitRotateKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitRotateKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitRotateKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitSign(string name, TransitSignRequest transitSignRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitSign");


            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->TransitSign");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitSignRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/sign/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitSignAsync(string name, TransitSignRequest transitSignRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitSign");


            // verify the required parameter 'transitSignRequest' is set
            if (transitSignRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignRequest' when calling Secrets->TransitSign");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitSignRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/sign/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitSign", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitSignWithAlgorithm(string name, string urlalgorithm, TransitSignWithAlgorithmRequest transitSignWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitSignWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitSignWithAlgorithm");


            // verify the required parameter 'transitSignWithAlgorithmRequest' is set
            if (transitSignWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignWithAlgorithmRequest' when calling Secrets->TransitSignWithAlgorithm");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitSignWithAlgorithmRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/sign/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitSignWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Generate a signature for input data using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitSignWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitSignWithAlgorithmAsync(string name, string urlalgorithm, TransitSignWithAlgorithmRequest transitSignWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitSignWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitSignWithAlgorithm");


            // verify the required parameter 'transitSignWithAlgorithmRequest' is set
            if (transitSignWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitSignWithAlgorithmRequest' when calling Secrets->TransitSignWithAlgorithm");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitSignWithAlgorithmRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/sign/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitSignWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitTrimKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitTrimKey(string name, TransitTrimKeyRequest transitTrimKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitTrimKey");


            // verify the required parameter 'transitTrimKeyRequest' is set
            if (transitTrimKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitTrimKeyRequest' when calling Secrets->TransitTrimKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitTrimKeyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/keys/{name}/trim", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Trim key versions of a named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitTrimKeyRequest"></param>
        /// <param name="name">Name of the key</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitTrimKeyAsync(string name, TransitTrimKeyRequest transitTrimKeyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitTrimKey");


            // verify the required parameter 'transitTrimKeyRequest' is set
            if (transitTrimKeyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitTrimKeyRequest' when calling Secrets->TransitTrimKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitTrimKeyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/keys/{name}/trim", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitTrimKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitVerify(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitVerify");


            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->TransitVerify");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitVerifyRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/verify/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitVerifyAsync(string name, TransitVerifyRequest transitVerifyRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitVerify");


            // verify the required parameter 'transitVerifyRequest' is set
            if (transitVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyRequest' when calling Secrets->TransitVerify");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "",
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitVerifyRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/verify/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> TransitVerifyWithAlgorithm(string name, string urlalgorithm, TransitVerifyWithAlgorithmRequest transitVerifyWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null)
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitVerifyWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitVerifyWithAlgorithm");


            // verify the required parameter 'transitVerifyWithAlgorithmRequest' is set
            if (transitVerifyWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyWithAlgorithmRequest' when calling Secrets->TransitVerifyWithAlgorithm");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                ""
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter





            requestOptions.Data = transitVerifyWithAlgorithmRequest;


            // make the HTTP request
            var response = this.Client.Post<Object>("/{transit_mount_path}/verify/{name}/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitVerifyWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }


        /// <summary>
        /// Verify a signature or HMAC for input data created using the named key 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="transitVerifyWithAlgorithmRequest"></param>
        /// <param name="name">The key to use</param>
        /// <param name="urlalgorithm">Hash algorithm to use (POST URL parameter)</param>
        /// <param name="transitMountPath">Path that the backend was mounted at</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> TransitVerifyWithAlgorithmAsync(string name, string urlalgorithm, TransitVerifyWithAlgorithmRequest transitVerifyWithAlgorithmRequest, string transitMountPath = "transit", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Secrets->TransitVerifyWithAlgorithm");

            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling Secrets->TransitVerifyWithAlgorithm");


            // verify the required parameter 'transitVerifyWithAlgorithmRequest' is set
            if (transitVerifyWithAlgorithmRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'transitVerifyWithAlgorithmRequest' when calling Secrets->TransitVerifyWithAlgorithm");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                ""
            };

            // to determine the Accept header
            string[] _accepts = new string[] {

            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter


            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter


            requestOptions.PathParameters.Add("transit_mount_path", ClientUtils.ParameterToString(transitMountPath)); // path parameter



            requestOptions.Data = transitVerifyWithAlgorithmRequest;
            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/{transit_mount_path}/verify/{name}/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("TransitVerifyWithAlgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<Object>(response.RawContent);
        }
    }
}
